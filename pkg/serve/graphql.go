// Package serve provides unified GraphQL support for Petri-pilot services.
package serve

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"regexp"
	"sort"
	"strings"
)

// UnifiedGraphQL combines multiple service schemas into a single GraphQL endpoint.
type UnifiedGraphQL struct {
	services      map[string]GraphQLService
	schema        string
	resolvers     map[string]resolverEntry
	introspection map[string]any // cached introspection result
}

type resolverEntry struct {
	serviceName string
	resolver    GraphQLResolver
}

// NewUnifiedGraphQL creates a new unified GraphQL handler from the given services.
func NewUnifiedGraphQL(services []GraphQLService) *UnifiedGraphQL {
	ug := &UnifiedGraphQL{
		services:  make(map[string]GraphQLService),
		resolvers: make(map[string]resolverEntry),
	}

	for _, svc := range services {
		name := svc.Name()
		ug.services[name] = svc

		// Register all resolvers from this service
		for opName, resolver := range svc.GraphQLResolvers() {
			ug.resolvers[opName] = resolverEntry{
				serviceName: name,
				resolver:    resolver,
			}
		}
	}

	// Combine schemas
	ug.schema = ug.combineSchemas()

	// Build introspection result from schema
	ug.introspection = ug.buildIntrospection()

	return ug
}

// Schema returns the combined GraphQL schema.
func (ug *UnifiedGraphQL) Schema() string {
	return ug.schema
}

// combineSchemas merges all service schemas into a unified schema.
func (ug *UnifiedGraphQL) combineSchemas() string {
	var queries []string
	var mutations []string
	var types []string

	// Sort service names for deterministic output
	names := make([]string, 0, len(ug.services))
	for name := range ug.services {
		names = append(names, name)
	}
	sort.Strings(names)

	for _, name := range names {
		svc := ug.services[name]
		schema := svc.GraphQLSchema()
		if schema == "" {
			continue
		}

		// Extract and namespace the schema components
		q, m, t := ug.extractAndNamespace(name, schema)
		queries = append(queries, q...)
		mutations = append(mutations, m...)
		types = append(types, t...)
	}

	// Build combined schema
	var sb strings.Builder
	sb.WriteString("# Unified GraphQL Schema - Generated by Petri-Pilot\n\n")
	sb.WriteString("scalar Time\n\n")

	// Query type
	sb.WriteString("type Query {\n")
	for _, q := range queries {
		sb.WriteString("  " + q + "\n")
	}
	sb.WriteString("}\n\n")

	// Mutation type
	if len(mutations) > 0 {
		sb.WriteString("type Mutation {\n")
		for _, m := range mutations {
			sb.WriteString("  " + m + "\n")
		}
		sb.WriteString("}\n\n")
	}

	// Type definitions
	for _, t := range types {
		sb.WriteString(t + "\n\n")
	}

	return sb.String()
}

// extractAndNamespace parses a service schema and prefixes types/operations with the service name.
func (ug *UnifiedGraphQL) extractAndNamespace(serviceName, schema string) (queries, mutations, types []string) {
	// Convert service name to prefix (e.g., "erc20-token" -> "Erc20token")
	prefix := toPascalCase(strings.ReplaceAll(serviceName, "-", ""))
	lowerPrefix := strings.ToLower(prefix)

	// First pass: collect all type/input names defined in this schema
	definedTypes := make(map[string]bool)
	for _, line := range strings.Split(schema, "\n") {
		trimmed := strings.TrimSpace(line)
		if strings.HasPrefix(trimmed, "type ") && strings.HasSuffix(trimmed, "{") {
			name := strings.TrimSpace(strings.TrimSuffix(strings.TrimPrefix(trimmed, "type "), "{"))
			if name != "Query" && name != "Mutation" {
				definedTypes[name] = true
			}
		} else if strings.HasPrefix(trimmed, "input ") && strings.HasSuffix(trimmed, "{") {
			name := strings.TrimSpace(strings.TrimSuffix(strings.TrimPrefix(trimmed, "input "), "{"))
			definedTypes[name] = true
		}
	}

	// Build rename map: sort by length descending to avoid substring collisions
	// e.g., "AggregateState" must be replaced before "State"
	renameMap := make(map[string]string)
	var sortedNames []string
	for typeName := range definedTypes {
		renameMap[typeName] = prefix + typeName
		sortedNames = append(sortedNames, typeName)
	}
	sort.Slice(sortedNames, func(i, j int) bool {
		return len(sortedNames[i]) > len(sortedNames[j])
	})

	// Parse the schema into sections
	lines := strings.Split(schema, "\n")
	var currentSection string
	var typeBuffer strings.Builder
	var inType bool

	for _, line := range lines {
		trimmed := strings.TrimSpace(line)

		// Detect section changes
		if strings.HasPrefix(trimmed, "type Query") {
			currentSection = "query"
			continue
		} else if strings.HasPrefix(trimmed, "type Mutation") {
			currentSection = "mutation"
			continue
		} else if (strings.HasPrefix(trimmed, "type ") || strings.HasPrefix(trimmed, "input ")) && strings.HasSuffix(trimmed, "{") {
			// Start of a type definition
			inType = true
			typeBuffer.Reset()
			typeBuffer.WriteString(line + "\n")
			currentSection = "type"
			continue
		} else if trimmed == "}" && inType {
			// End of type definition
			typeBuffer.WriteString(line)
			typeDef := typeBuffer.String()

			// Namespace the type definition
			typeDef = namespaceTypeDef(typeDef, prefix, sortedNames, renameMap)
			types = append(types, typeDef)

			inType = false
			typeBuffer.Reset()
			continue
		}

		if inType {
			typeBuffer.WriteString(line + "\n")
			continue
		}

		// Skip empty lines and comments in query/mutation sections
		if trimmed == "" || strings.HasPrefix(trimmed, "#") {
			continue
		}

		// Skip closing braces for Query/Mutation types
		if trimmed == "}" {
			currentSection = ""
			continue
		}

		switch currentSection {
		case "query":
			field := namespaceQueryField(trimmed, lowerPrefix, prefix, sortedNames, renameMap)
			queries = append(queries, field)
		case "mutation":
			field := namespaceMutationField(trimmed, lowerPrefix, prefix, sortedNames, renameMap)
			mutations = append(mutations, field)
		}
	}

	return queries, mutations, types
}

// applyTypeRenames replaces type references using word-boundary regexes,
// processing longer names first to avoid substring collisions.
func applyTypeRenames(s, _ string, sortedNames []string, renameMap map[string]string) string {
	result := s
	for _, name := range sortedNames {
		newName := renameMap[name]
		// Use word boundary to avoid "State" matching inside "AggregateState"
		re := regexp.MustCompile(`\b` + regexp.QuoteMeta(name) + `\b`)
		result = re.ReplaceAllString(result, newName)
	}
	return result
}

// namespaceQueryField renames types in a query field and prefixes un-prefixed field names.
func namespaceQueryField(field, lowerPrefix, prefix string, sortedNames []string, renameMap map[string]string) string {
	result := applyTypeRenames(field, prefix, sortedNames, renameMap)

	// Prefix field names that don't already start with the service prefix
	// e.g., "adminStats:" -> "blogpostAdminStats:", but "blogpostList" stays as-is
	fieldName := strings.TrimSpace(field)
	nameEnd := strings.IndexAny(fieldName, "(:")
	if nameEnd > 0 {
		name := strings.TrimSpace(fieldName[:nameEnd])
		if !strings.HasPrefix(name, lowerPrefix) {
			// Prefix it
			result = lowerPrefix + strings.ToUpper(name[:1]) + name[1:] + result[nameEnd:]
		}
	}

	return result
}

// namespaceMutationField renames types and transforms mutation names.
func namespaceMutationField(field, lowerPrefix, prefix string, sortedNames []string, renameMap map[string]string) string {
	// Apply type renames
	result := applyTypeRenames(field, prefix, sortedNames, renameMap)

	// Transform mutation names: "createFoo:" -> "prefix_create:", "transfer(" -> "prefix_transfer("
	trimmed := strings.TrimSpace(result)
	nameEnd := strings.IndexAny(trimmed, "(:")
	if nameEnd > 0 {
		name := strings.TrimSpace(trimmed[:nameEnd])
		sep := trimmed[nameEnd]
		rest := trimmed[nameEnd:]

		if strings.HasPrefix(name, "create") && sep == ':' {
			// Instance creation (no args): "createBlogPost: ..." -> "blogpost_create: ..."
			result = lowerPrefix + "_create" + rest
		} else {
			// Transition with args or non-create: "transfer(input: ...)" -> "prefix_transfer(input: ...)"
			result = lowerPrefix + "_" + name + rest
		}
	}

	return result
}

// namespaceTypeDef renames a type definition and its field type references.
func namespaceTypeDef(typeDef, prefix string, sortedNames []string, renameMap map[string]string) string {
	return applyTypeRenames(typeDef, prefix, sortedNames, renameMap)
}

// toPascalCase converts a string to PascalCase.
func toPascalCase(s string) string {
	if s == "" {
		return ""
	}
	// Capitalize first letter
	return strings.ToUpper(s[:1]) + s[1:]
}

// ServeHTTP handles GraphQL requests.
// Browser GET requests (Accept: text/html) are redirected to the interactive playground.
func (ug *UnifiedGraphQL) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	if r.Method == http.MethodGet {
		accept := r.Header.Get("Accept")
		if strings.Contains(accept, "text/html") {
			http.Redirect(w, r, "/graphql/i", http.StatusSeeOther)
			return
		}
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}
	if r.Method != http.MethodPost {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	var req struct {
		Query         string         `json:"query"`
		OperationName string         `json:"operationName"`
		Variables     map[string]any `json:"variables"`
	}

	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}

	result := ug.executeGraphQL(r.Context(), req.Query, req.OperationName, req.Variables)

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(result)
}

// executeGraphQL executes a GraphQL query or mutation.
func (ug *UnifiedGraphQL) executeGraphQL(ctx context.Context, query, _ string, variables map[string]any) map[string]any {
	// Handle introspection queries
	if strings.Contains(query, "__schema") || strings.Contains(query, "__type") {
		return ug.introspection
	}

	result := make(map[string]any)
	data := make(map[string]any)
	var errors []map[string]any

	// Detect mutation vs query
	isMutation := strings.Contains(query, "mutation")

	// Find all operation names in the query
	operations := ug.parseOperations(query, isMutation)

	for _, op := range operations {
		entry, ok := ug.resolvers[op]
		if !ok {
			continue
		}

		// Execute the resolver
		res, err := entry.resolver(ctx, variables)
		if err != nil {
			errors = append(errors, map[string]any{"message": err.Error()})
		} else {
			data[op] = res
		}
	}

	result["data"] = data
	if len(errors) > 0 {
		result["errors"] = errors
	}

	return result
}

// parseOperations extracts operation names from a GraphQL query.
func (ug *UnifiedGraphQL) parseOperations(query string, _ bool) []string {
	var operations []string

	// Look for registered resolver names in the query
	for opName := range ug.resolvers {
		// Check if this operation is in the query
		// Match "opName(" or "opName {" or "opName\n"
		pattern := regexp.MustCompile(`\b` + regexp.QuoteMeta(opName) + `\s*[(\{]`)
		if pattern.MatchString(query) {
			operations = append(operations, opName)
		}
	}

	return operations
}

// Handler returns the HTTP handler for the unified GraphQL endpoint.
func (ug *UnifiedGraphQL) Handler() http.Handler {
	return ug
}

// SchemaHandler returns an HTTP handler that serves the schema.
func (ug *UnifiedGraphQL) SchemaHandler() http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		fmt.Fprint(w, ug.schema)
	}
}

// buildIntrospection parses the combined SDL schema into a GraphQL introspection result.
func (ug *UnifiedGraphQL) buildIntrospection() map[string]any {
	lines := strings.Split(ug.schema, "\n")

	var types []map[string]any
	typeMap := make(map[string]map[string]any)

	// Built-in scalars
	for _, scalar := range []string{"String", "Int", "Float", "Boolean", "ID", "Time"} {
		t := map[string]any{
			"kind":          "SCALAR",
			"name":          scalar,
			"description":   nil,
			"fields":        nil,
			"inputFields":   nil,
			"interfaces":    nil,
			"enumValues":    nil,
			"possibleTypes": nil,
		}
		types = append(types, t)
		typeMap[scalar] = t
	}

	// Parse schema SDL
	var currentType map[string]any
	var currentFields []map[string]any
	var currentInputFields []map[string]any
	var currentSection string // "query", "mutation", or ""

	for _, line := range lines {
		trimmed := strings.TrimSpace(line)
		if trimmed == "" || strings.HasPrefix(trimmed, "#") || trimmed == "scalar Time" {
			continue
		}

		// Detect type definitions
		if strings.HasPrefix(trimmed, "type Query {") {
			currentSection = "query"
			currentFields = nil
			continue
		}
		if strings.HasPrefix(trimmed, "type Mutation {") {
			currentSection = "mutation"
			currentFields = nil
			continue
		}
		if strings.HasPrefix(trimmed, "type ") && strings.HasSuffix(trimmed, "{") {
			name := strings.TrimSuffix(strings.TrimPrefix(trimmed, "type "), " {")
			name = strings.TrimSpace(name)
			currentType = map[string]any{
				"kind":          "OBJECT",
				"name":          name,
				"description":   nil,
				"interfaces":    []any{},
				"enumValues":    nil,
				"possibleTypes": nil,
			}
			currentFields = nil
			currentSection = ""
			continue
		}
		if strings.HasPrefix(trimmed, "input ") && strings.HasSuffix(trimmed, "{") {
			name := strings.TrimSuffix(strings.TrimPrefix(trimmed, "input "), " {")
			name = strings.TrimSpace(name)
			currentType = map[string]any{
				"kind":          "INPUT_OBJECT",
				"name":          name,
				"description":   nil,
				"interfaces":    nil,
				"enumValues":    nil,
				"possibleTypes": nil,
			}
			currentInputFields = nil
			currentSection = ""
			continue
		}

		// End of type/section
		if trimmed == "}" {
			if currentSection == "query" {
				qt := map[string]any{
					"kind":          "OBJECT",
					"name":          "Query",
					"description":   nil,
					"fields":        currentFields,
					"interfaces":    []any{},
					"enumValues":    nil,
					"possibleTypes": nil,
					"inputFields":   nil,
				}
				types = append(types, qt)
				typeMap["Query"] = qt
				currentSection = ""
			} else if currentSection == "mutation" {
				mt := map[string]any{
					"kind":          "OBJECT",
					"name":          "Mutation",
					"description":   nil,
					"fields":        currentFields,
					"interfaces":    []any{},
					"enumValues":    nil,
					"possibleTypes": nil,
					"inputFields":   nil,
				}
				types = append(types, mt)
				typeMap["Mutation"] = mt
				currentSection = ""
			} else if currentType != nil {
				kind := currentType["kind"].(string)
				if kind == "INPUT_OBJECT" {
					currentType["inputFields"] = currentInputFields
					currentType["fields"] = nil
				} else {
					currentType["fields"] = currentFields
					currentType["inputFields"] = nil
				}
				types = append(types, currentType)
				typeMap[currentType["name"].(string)] = currentType
				currentType = nil
			}
			continue
		}

		// Parse field lines
		if currentSection == "query" || currentSection == "mutation" || currentType != nil {
			field := parseSchemaField(trimmed)
			if field != nil {
				kind := ""
				if currentType != nil {
					kind = currentType["kind"].(string)
				}
				if kind == "INPUT_OBJECT" {
					currentInputFields = append(currentInputFields, field)
				} else {
					currentFields = append(currentFields, field)
				}
			}
		}
	}

	// Build the __schema response
	schema := map[string]any{
		"queryType":        map[string]any{"name": "Query"},
		"types":            types,
		"directives":       []any{},
		"subscriptionType": nil,
	}
	if _, ok := typeMap["Mutation"]; ok {
		schema["mutationType"] = map[string]any{"name": "Mutation"}
	} else {
		schema["mutationType"] = nil
	}

	return map[string]any{
		"data": map[string]any{
			"__schema": schema,
		},
	}
}

// parseSchemaField parses a GraphQL field definition line like:
//
//	fieldName(arg: Type!): ReturnType!
func parseSchemaField(line string) map[string]any {
	line = strings.TrimSpace(line)
	if line == "" || strings.HasPrefix(line, "#") {
		return nil
	}

	field := map[string]any{}

	// Extract field name
	nameEnd := strings.IndexAny(line, "(:")
	if nameEnd < 0 {
		return nil
	}
	field["name"] = strings.TrimSpace(line[:nameEnd])

	// Extract args if present (must be non-nil empty slice for introspection compliance)
	args := make([]map[string]any, 0)
	if line[nameEnd] == '(' {
		argsEnd := strings.Index(line, ")")
		if argsEnd > nameEnd {
			argsStr := line[nameEnd+1 : argsEnd]
			for _, argDef := range strings.Split(argsStr, ",") {
				argDef = strings.TrimSpace(argDef)
				if argDef == "" {
					continue
				}
				parts := strings.SplitN(argDef, ":", 2)
				if len(parts) == 2 {
					args = append(args, map[string]any{
						"name":         strings.TrimSpace(parts[0]),
						"description":  nil,
						"type":         parseTypeRef(strings.TrimSpace(parts[1])),
						"defaultValue": nil,
					})
				}
			}
			// Move past args to find return type
			line = line[argsEnd+1:]
			nameEnd = 0
		}
	}
	field["args"] = args

	// Extract return type
	colonIdx := strings.Index(line[nameEnd:], ":")
	if colonIdx >= 0 {
		returnType := strings.TrimSpace(line[nameEnd+colonIdx+1:])
		field["type"] = parseTypeRef(returnType)
	} else {
		field["type"] = map[string]any{"kind": "SCALAR", "name": "String", "ofType": nil}
	}

	field["description"] = nil
	field["isDeprecated"] = false
	field["deprecationReason"] = nil

	return field
}

// parseTypeRef converts a GraphQL type string like "[String!]!" into a type reference.
func parseTypeRef(typeStr string) map[string]any {
	typeStr = strings.TrimSpace(typeStr)

	// NON_NULL wrapper
	if strings.HasSuffix(typeStr, "!") {
		inner := typeStr[:len(typeStr)-1]
		return map[string]any{
			"kind":   "NON_NULL",
			"name":   nil,
			"ofType": parseTypeRef(inner),
		}
	}

	// LIST wrapper
	if strings.HasPrefix(typeStr, "[") && strings.HasSuffix(typeStr, "]") {
		inner := typeStr[1 : len(typeStr)-1]
		return map[string]any{
			"kind":   "LIST",
			"name":   nil,
			"ofType": parseTypeRef(inner),
		}
	}

	// Named type â€” determine kind
	kind := "OBJECT"
	switch typeStr {
	case "String", "Int", "Float", "Boolean", "ID", "Time":
		kind = "SCALAR"
	}
	// Input types
	if strings.HasSuffix(typeStr, "Input") {
		kind = "INPUT_OBJECT"
	}

	return map[string]any{
		"kind":   kind,
		"name":   typeStr,
		"ofType": nil,
	}
}
