// Package serve provides unified GraphQL support for Petri-pilot services.
package serve

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"regexp"
	"sort"
	"strings"
)

// UnifiedGraphQL combines multiple service schemas into a single GraphQL endpoint.
type UnifiedGraphQL struct {
	services      map[string]GraphQLService
	schema        string
	resolvers     map[string]resolverEntry
	introspection map[string]any // cached introspection result
}

type resolverEntry struct {
	serviceName string
	resolver    GraphQLResolver
}

// NewUnifiedGraphQL creates a new unified GraphQL handler from the given services.
func NewUnifiedGraphQL(services []GraphQLService) *UnifiedGraphQL {
	ug := &UnifiedGraphQL{
		services:  make(map[string]GraphQLService),
		resolvers: make(map[string]resolverEntry),
	}

	for _, svc := range services {
		name := svc.Name()
		ug.services[name] = svc

		// Register all resolvers from this service
		for opName, resolver := range svc.GraphQLResolvers() {
			ug.resolvers[opName] = resolverEntry{
				serviceName: name,
				resolver:    resolver,
			}
		}
	}

	// Combine schemas
	ug.schema = ug.combineSchemas()

	// Build introspection result from schema
	ug.introspection = ug.buildIntrospection()

	return ug
}

// Schema returns the combined GraphQL schema.
func (ug *UnifiedGraphQL) Schema() string {
	return ug.schema
}

// combineSchemas merges all service schemas into a unified schema.
func (ug *UnifiedGraphQL) combineSchemas() string {
	var queries []string
	var mutations []string
	var types []string

	// Sort service names for deterministic output
	names := make([]string, 0, len(ug.services))
	for name := range ug.services {
		names = append(names, name)
	}
	sort.Strings(names)

	for _, name := range names {
		svc := ug.services[name]
		schema := svc.GraphQLSchema()
		if schema == "" {
			continue
		}

		// Extract and namespace the schema components
		q, m, t := ug.extractAndNamespace(name, schema)
		queries = append(queries, q...)
		mutations = append(mutations, m...)
		types = append(types, t...)
	}

	// Build combined schema
	var sb strings.Builder
	sb.WriteString("# Unified GraphQL Schema - Generated by Petri-Pilot\n\n")
	sb.WriteString("scalar Time\n\n")

	// Query type
	sb.WriteString("type Query {\n")
	for _, q := range queries {
		sb.WriteString("  " + q + "\n")
	}
	sb.WriteString("}\n\n")

	// Mutation type
	if len(mutations) > 0 {
		sb.WriteString("type Mutation {\n")
		for _, m := range mutations {
			sb.WriteString("  " + m + "\n")
		}
		sb.WriteString("}\n\n")
	}

	// Type definitions
	for _, t := range types {
		sb.WriteString(t + "\n\n")
	}

	return sb.String()
}

// extractAndNamespace parses a service schema and prefixes types/operations with the service name.
func (ug *UnifiedGraphQL) extractAndNamespace(serviceName, schema string) (queries, mutations, types []string) {
	// Convert service name to prefix (e.g., "erc20-token" -> "Erc20token")
	prefix := toPascalCase(strings.ReplaceAll(serviceName, "-", ""))
	lowerPrefix := strings.ToLower(prefix)

	// Parse the schema into sections
	lines := strings.Split(schema, "\n")
	var currentSection string
	var currentType string
	var typeBuffer strings.Builder
	var inType bool

	// Types that should be namespaced
	typeNames := map[string]bool{
		"AggregateState":   true,
		"State":            true,
		"Places":           true,
		"TransitionResult": true,
		"AggregateList":    true,
		"AdminStats":       true,
		"PlaceCount":       true,
		"Event":            true,
	}

	// Rename map for this service
	renameMap := make(map[string]string)
	for typeName := range typeNames {
		renameMap[typeName] = prefix + typeName
	}

	for _, line := range lines {
		trimmed := strings.TrimSpace(line)

		// Detect section changes
		if strings.HasPrefix(trimmed, "type Query") {
			currentSection = "query"
			continue
		} else if strings.HasPrefix(trimmed, "type Mutation") {
			currentSection = "mutation"
			continue
		} else if strings.HasPrefix(trimmed, "type ") || strings.HasPrefix(trimmed, "input ") {
			// Start of a type definition
			inType = true
			currentType = trimmed
			typeBuffer.Reset()
			typeBuffer.WriteString(line + "\n")
			currentSection = "type"
			continue
		} else if trimmed == "}" && inType {
			// End of type definition
			typeBuffer.WriteString(line)
			typeDef := typeBuffer.String()

			// Namespace the type definition
			typeDef = namespaceType(typeDef, prefix, renameMap)
			types = append(types, typeDef)

			inType = false
			currentType = ""
			typeBuffer.Reset()
			continue
		}

		if inType {
			typeBuffer.WriteString(line + "\n")
			continue
		}

		// Skip empty lines and comments in query/mutation sections
		if trimmed == "" || strings.HasPrefix(trimmed, "#") {
			continue
		}

		// Skip closing braces for Query/Mutation types
		if trimmed == "}" {
			currentSection = ""
			continue
		}

		switch currentSection {
		case "query":
			// Namespace query fields
			// e.g., "erc20token(id: ID!): AggregateState" -> "erc20token(id: ID!): Erc20tokenAggregateState"
			field := namespaceField(trimmed, lowerPrefix, prefix, renameMap)
			queries = append(queries, field)
		case "mutation":
			// Namespace mutation fields
			// e.g., "createErc20token: AggregateState!" -> "erc20token_create: Erc20tokenAggregateState!"
			field := namespaceMutation(trimmed, lowerPrefix, prefix, renameMap, currentType)
			mutations = append(mutations, field)
		}
	}

	return queries, mutations, types
}

// namespaceField renames types in a query field definition.
func namespaceField(field, _, prefix string, renameMap map[string]string) string {
	result := field
	for oldName, newName := range renameMap {
		result = strings.ReplaceAll(result, oldName, newName)
	}
	// Also rename input types
	inputRe := regexp.MustCompile(`(\w+)Input`)
	result = inputRe.ReplaceAllString(result, prefix+"${1}Input")
	return result
}

// namespaceMutation renames types and transforms mutation names.
func namespaceMutation(field, _, prefix string, renameMap map[string]string, _ string) string {
	lowerPrefix := strings.ToLower(prefix)
	result := field

	// Replace types
	for oldName, newName := range renameMap {
		result = strings.ReplaceAll(result, oldName, newName)
	}

	// Transform mutation names: "createFoo" -> "foo_create", "transfer" -> "foo_transfer"
	if strings.HasPrefix(result, "create") {
		// "createErc20token: ..." -> "erc20token_create: ..."
		result = strings.Replace(result, "create", lowerPrefix+"_create", 1)
		// Remove the model name after create if it exists
		result = regexp.MustCompile(`_create\w*:`).ReplaceAllString(result, "_create:")
	} else {
		// Other transitions: "transfer(input: TransferInput!)" -> "erc20token_transfer(input: ...)"
		parts := strings.SplitN(result, "(", 2)
		if len(parts) == 2 {
			transitionName := strings.TrimSpace(parts[0])
			rest := parts[1]
			result = lowerPrefix + "_" + transitionName + "(" + rest
		} else if strings.Contains(result, ":") {
			parts = strings.SplitN(result, ":", 2)
			transitionName := strings.TrimSpace(parts[0])
			rest := parts[1]
			result = lowerPrefix + "_" + transitionName + ":" + rest
		}
	}

	// Rename input types
	inputRe := regexp.MustCompile(`(\w+)Input`)
	result = inputRe.ReplaceAllString(result, prefix+"${1}Input")

	return result
}

// namespaceType renames a type definition and its field types.
func namespaceType(typeDef, prefix string, renameMap map[string]string) string {
	result := typeDef

	// Rename the type itself
	for oldName, newName := range renameMap {
		// Match "type OldName" or "input OldName"
		result = regexp.MustCompile(`(type|input)\s+`+oldName+`\b`).ReplaceAllString(result, "${1} "+newName)
		// Also rename references to the type
		result = regexp.MustCompile(`:\s*`+oldName+`\b`).ReplaceAllString(result, ": "+newName)
		result = regexp.MustCompile(`\[`+oldName+`\b`).ReplaceAllString(result, "["+newName)
	}

	// Rename input types
	result = regexp.MustCompile(`(type|input)\s+(\w+)Input\b`).ReplaceAllString(result, "${1} "+prefix+"${2}Input")
	result = regexp.MustCompile(`:\s*(\w+)Input\b`).ReplaceAllString(result, ": "+prefix+"${1}Input")

	return result
}

// toPascalCase converts a string to PascalCase.
func toPascalCase(s string) string {
	if s == "" {
		return ""
	}
	// Capitalize first letter
	return strings.ToUpper(s[:1]) + s[1:]
}

// ServeHTTP handles GraphQL requests.
// Browser GET requests (Accept: text/html) are redirected to the interactive playground.
func (ug *UnifiedGraphQL) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	if r.Method == http.MethodGet {
		accept := r.Header.Get("Accept")
		if strings.Contains(accept, "text/html") {
			http.Redirect(w, r, "/graphql/i", http.StatusSeeOther)
			return
		}
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}
	if r.Method != http.MethodPost {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	var req struct {
		Query         string         `json:"query"`
		OperationName string         `json:"operationName"`
		Variables     map[string]any `json:"variables"`
	}

	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}

	result := ug.executeGraphQL(r.Context(), req.Query, req.OperationName, req.Variables)

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(result)
}

// executeGraphQL executes a GraphQL query or mutation.
func (ug *UnifiedGraphQL) executeGraphQL(ctx context.Context, query, _ string, variables map[string]any) map[string]any {
	// Handle introspection queries
	if strings.Contains(query, "__schema") || strings.Contains(query, "__type") {
		return ug.introspection
	}

	result := make(map[string]any)
	data := make(map[string]any)
	var errors []map[string]any

	// Detect mutation vs query
	isMutation := strings.Contains(query, "mutation")

	// Find all operation names in the query
	operations := ug.parseOperations(query, isMutation)

	for _, op := range operations {
		entry, ok := ug.resolvers[op]
		if !ok {
			continue
		}

		// Execute the resolver
		res, err := entry.resolver(ctx, variables)
		if err != nil {
			errors = append(errors, map[string]any{"message": err.Error()})
		} else {
			data[op] = res
		}
	}

	result["data"] = data
	if len(errors) > 0 {
		result["errors"] = errors
	}

	return result
}

// parseOperations extracts operation names from a GraphQL query.
func (ug *UnifiedGraphQL) parseOperations(query string, _ bool) []string {
	var operations []string

	// Look for registered resolver names in the query
	for opName := range ug.resolvers {
		// Check if this operation is in the query
		// Match "opName(" or "opName {" or "opName\n"
		pattern := regexp.MustCompile(`\b` + regexp.QuoteMeta(opName) + `\s*[(\{]`)
		if pattern.MatchString(query) {
			operations = append(operations, opName)
		}
	}

	return operations
}

// Handler returns the HTTP handler for the unified GraphQL endpoint.
func (ug *UnifiedGraphQL) Handler() http.Handler {
	return ug
}

// SchemaHandler returns an HTTP handler that serves the schema.
func (ug *UnifiedGraphQL) SchemaHandler() http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		fmt.Fprint(w, ug.schema)
	}
}

// buildIntrospection parses the combined SDL schema into a GraphQL introspection result.
func (ug *UnifiedGraphQL) buildIntrospection() map[string]any {
	lines := strings.Split(ug.schema, "\n")

	var types []map[string]any
	typeMap := make(map[string]map[string]any)

	// Built-in scalars
	for _, scalar := range []string{"String", "Int", "Float", "Boolean", "ID", "Time"} {
		t := map[string]any{
			"kind": "SCALAR",
			"name": scalar,
		}
		types = append(types, t)
		typeMap[scalar] = t
	}

	// Parse schema SDL
	var currentType map[string]any
	var currentFields []map[string]any
	var currentInputFields []map[string]any
	var currentSection string // "query", "mutation", or ""

	for _, line := range lines {
		trimmed := strings.TrimSpace(line)
		if trimmed == "" || strings.HasPrefix(trimmed, "#") || trimmed == "scalar Time" {
			continue
		}

		// Detect type definitions
		if strings.HasPrefix(trimmed, "type Query {") {
			currentSection = "query"
			currentFields = nil
			continue
		}
		if strings.HasPrefix(trimmed, "type Mutation {") {
			currentSection = "mutation"
			currentFields = nil
			continue
		}
		if strings.HasPrefix(trimmed, "type ") && strings.HasSuffix(trimmed, "{") {
			name := strings.TrimSuffix(strings.TrimPrefix(trimmed, "type "), " {")
			name = strings.TrimSpace(name)
			currentType = map[string]any{"kind": "OBJECT", "name": name}
			currentFields = nil
			currentSection = ""
			continue
		}
		if strings.HasPrefix(trimmed, "input ") && strings.HasSuffix(trimmed, "{") {
			name := strings.TrimSuffix(strings.TrimPrefix(trimmed, "input "), " {")
			name = strings.TrimSpace(name)
			currentType = map[string]any{"kind": "INPUT_OBJECT", "name": name}
			currentInputFields = nil
			currentSection = ""
			continue
		}

		// End of type/section
		if trimmed == "}" {
			if currentSection == "query" {
				qt := map[string]any{
					"kind":   "OBJECT",
					"name":   "Query",
					"fields": currentFields,
				}
				types = append(types, qt)
				typeMap["Query"] = qt
				currentSection = ""
			} else if currentSection == "mutation" {
				mt := map[string]any{
					"kind":   "OBJECT",
					"name":   "Mutation",
					"fields": currentFields,
				}
				types = append(types, mt)
				typeMap["Mutation"] = mt
				currentSection = ""
			} else if currentType != nil {
				kind := currentType["kind"].(string)
				if kind == "INPUT_OBJECT" {
					currentType["inputFields"] = currentInputFields
					currentType["fields"] = nil
				} else {
					currentType["fields"] = currentFields
				}
				types = append(types, currentType)
				typeMap[currentType["name"].(string)] = currentType
				currentType = nil
			}
			continue
		}

		// Parse field lines
		if currentSection == "query" || currentSection == "mutation" || currentType != nil {
			field := parseSchemaField(trimmed)
			if field != nil {
				kind := ""
				if currentType != nil {
					kind = currentType["kind"].(string)
				}
				if kind == "INPUT_OBJECT" {
					currentInputFields = append(currentInputFields, field)
				} else {
					currentFields = append(currentFields, field)
				}
			}
		}
	}

	// Build the __schema response
	schema := map[string]any{
		"queryType":        map[string]any{"name": "Query"},
		"types":            types,
		"directives":       []any{},
		"subscriptionType": nil,
	}
	if _, ok := typeMap["Mutation"]; ok {
		schema["mutationType"] = map[string]any{"name": "Mutation"}
	} else {
		schema["mutationType"] = nil
	}

	return map[string]any{
		"data": map[string]any{
			"__schema": schema,
		},
	}
}

// parseSchemaField parses a GraphQL field definition line like:
//
//	fieldName(arg: Type!): ReturnType!
func parseSchemaField(line string) map[string]any {
	line = strings.TrimSpace(line)
	if line == "" || strings.HasPrefix(line, "#") {
		return nil
	}

	field := map[string]any{}

	// Extract field name
	nameEnd := strings.IndexAny(line, "(:")
	if nameEnd < 0 {
		return nil
	}
	field["name"] = strings.TrimSpace(line[:nameEnd])

	// Extract args if present
	var args []map[string]any
	if line[nameEnd] == '(' {
		argsEnd := strings.Index(line, ")")
		if argsEnd > nameEnd {
			argsStr := line[nameEnd+1 : argsEnd]
			for _, argDef := range strings.Split(argsStr, ",") {
				argDef = strings.TrimSpace(argDef)
				if argDef == "" {
					continue
				}
				parts := strings.SplitN(argDef, ":", 2)
				if len(parts) == 2 {
					args = append(args, map[string]any{
						"name":         strings.TrimSpace(parts[0]),
						"type":         parseTypeRef(strings.TrimSpace(parts[1])),
						"defaultValue": nil,
					})
				}
			}
			// Move past args to find return type
			line = line[argsEnd+1:]
			nameEnd = 0
		}
	}
	field["args"] = args

	// Extract return type
	colonIdx := strings.Index(line[nameEnd:], ":")
	if colonIdx >= 0 {
		returnType := strings.TrimSpace(line[nameEnd+colonIdx+1:])
		field["type"] = parseTypeRef(returnType)
	} else {
		field["type"] = map[string]any{"kind": "SCALAR", "name": "String", "ofType": nil}
	}

	return field
}

// parseTypeRef converts a GraphQL type string like "[String!]!" into a type reference.
func parseTypeRef(typeStr string) map[string]any {
	typeStr = strings.TrimSpace(typeStr)

	// NON_NULL wrapper
	if strings.HasSuffix(typeStr, "!") {
		inner := typeStr[:len(typeStr)-1]
		return map[string]any{
			"kind":   "NON_NULL",
			"name":   nil,
			"ofType": parseTypeRef(inner),
		}
	}

	// LIST wrapper
	if strings.HasPrefix(typeStr, "[") && strings.HasSuffix(typeStr, "]") {
		inner := typeStr[1 : len(typeStr)-1]
		return map[string]any{
			"kind":   "LIST",
			"name":   nil,
			"ofType": parseTypeRef(inner),
		}
	}

	// Named type â€” determine kind
	kind := "OBJECT"
	switch typeStr {
	case "String", "Int", "Float", "Boolean", "ID", "Time":
		kind = "SCALAR"
	}
	// Input types
	if strings.HasSuffix(typeStr, "Input") {
		kind = "INPUT_OBJECT"
	}

	return map[string]any{
		"kind":   kind,
		"name":   typeStr,
		"ofType": nil,
	}
}
