// Package serve provides unified GraphQL support for Petri-pilot services.
package serve

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"regexp"
	"sort"
	"strings"
)

// UnifiedGraphQL combines multiple service schemas into a single GraphQL endpoint.
type UnifiedGraphQL struct {
	services  map[string]GraphQLService
	schema    string
	resolvers map[string]resolverEntry
}

type resolverEntry struct {
	serviceName string
	resolver    GraphQLResolver
}

// NewUnifiedGraphQL creates a new unified GraphQL handler from the given services.
func NewUnifiedGraphQL(services []GraphQLService) *UnifiedGraphQL {
	ug := &UnifiedGraphQL{
		services:  make(map[string]GraphQLService),
		resolvers: make(map[string]resolverEntry),
	}

	for _, svc := range services {
		name := svc.Name()
		ug.services[name] = svc

		// Register all resolvers from this service
		for opName, resolver := range svc.GraphQLResolvers() {
			ug.resolvers[opName] = resolverEntry{
				serviceName: name,
				resolver:    resolver,
			}
		}
	}

	// Combine schemas
	ug.schema = ug.combineSchemas()

	return ug
}

// Schema returns the combined GraphQL schema.
func (ug *UnifiedGraphQL) Schema() string {
	return ug.schema
}

// combineSchemas merges all service schemas into a unified schema.
func (ug *UnifiedGraphQL) combineSchemas() string {
	var queries []string
	var mutations []string
	var types []string

	// Sort service names for deterministic output
	names := make([]string, 0, len(ug.services))
	for name := range ug.services {
		names = append(names, name)
	}
	sort.Strings(names)

	for _, name := range names {
		svc := ug.services[name]
		schema := svc.GraphQLSchema()
		if schema == "" {
			continue
		}

		// Extract and namespace the schema components
		q, m, t := ug.extractAndNamespace(name, schema)
		queries = append(queries, q...)
		mutations = append(mutations, m...)
		types = append(types, t...)
	}

	// Build combined schema
	var sb strings.Builder
	sb.WriteString("# Unified GraphQL Schema - Generated by Petri-Pilot\n\n")
	sb.WriteString("scalar Time\n\n")

	// Query type
	sb.WriteString("type Query {\n")
	for _, q := range queries {
		sb.WriteString("  " + q + "\n")
	}
	sb.WriteString("}\n\n")

	// Mutation type
	if len(mutations) > 0 {
		sb.WriteString("type Mutation {\n")
		for _, m := range mutations {
			sb.WriteString("  " + m + "\n")
		}
		sb.WriteString("}\n\n")
	}

	// Type definitions
	for _, t := range types {
		sb.WriteString(t + "\n\n")
	}

	return sb.String()
}

// extractAndNamespace parses a service schema and prefixes types/operations with the service name.
func (ug *UnifiedGraphQL) extractAndNamespace(serviceName, schema string) (queries, mutations, types []string) {
	// Convert service name to prefix (e.g., "erc20-token" -> "Erc20token")
	prefix := toPascalCase(strings.ReplaceAll(serviceName, "-", ""))
	lowerPrefix := strings.ToLower(prefix)

	// Parse the schema into sections
	lines := strings.Split(schema, "\n")
	var currentSection string
	var currentType string
	var typeBuffer strings.Builder
	var inType bool

	// Types that should be namespaced
	typeNames := map[string]bool{
		"AggregateState":   true,
		"State":            true,
		"Places":           true,
		"TransitionResult": true,
		"AggregateList":    true,
		"AdminStats":       true,
		"PlaceCount":       true,
		"Event":            true,
	}

	// Rename map for this service
	renameMap := make(map[string]string)
	for typeName := range typeNames {
		renameMap[typeName] = prefix + typeName
	}

	for _, line := range lines {
		trimmed := strings.TrimSpace(line)

		// Detect section changes
		if strings.HasPrefix(trimmed, "type Query") {
			currentSection = "query"
			continue
		} else if strings.HasPrefix(trimmed, "type Mutation") {
			currentSection = "mutation"
			continue
		} else if strings.HasPrefix(trimmed, "type ") || strings.HasPrefix(trimmed, "input ") {
			// Start of a type definition
			inType = true
			currentType = trimmed
			typeBuffer.Reset()
			typeBuffer.WriteString(line + "\n")
			currentSection = "type"
			continue
		} else if trimmed == "}" && inType {
			// End of type definition
			typeBuffer.WriteString(line)
			typeDef := typeBuffer.String()

			// Namespace the type definition
			typeDef = namespaceType(typeDef, prefix, renameMap)
			types = append(types, typeDef)

			inType = false
			currentType = ""
			typeBuffer.Reset()
			continue
		}

		if inType {
			typeBuffer.WriteString(line + "\n")
			continue
		}

		// Skip empty lines and comments in query/mutation sections
		if trimmed == "" || strings.HasPrefix(trimmed, "#") {
			continue
		}

		// Skip closing braces for Query/Mutation types
		if trimmed == "}" {
			currentSection = ""
			continue
		}

		switch currentSection {
		case "query":
			// Namespace query fields
			// e.g., "erc20token(id: ID!): AggregateState" -> "erc20token(id: ID!): Erc20tokenAggregateState"
			field := namespaceField(trimmed, lowerPrefix, prefix, renameMap)
			queries = append(queries, field)
		case "mutation":
			// Namespace mutation fields
			// e.g., "createErc20token: AggregateState!" -> "erc20token_create: Erc20tokenAggregateState!"
			field := namespaceMutation(trimmed, lowerPrefix, prefix, renameMap, currentType)
			mutations = append(mutations, field)
		}
	}

	return queries, mutations, types
}

// namespaceField renames types in a query field definition.
func namespaceField(field, _, prefix string, renameMap map[string]string) string {
	result := field
	for oldName, newName := range renameMap {
		result = strings.ReplaceAll(result, oldName, newName)
	}
	// Also rename input types
	inputRe := regexp.MustCompile(`(\w+)Input`)
	result = inputRe.ReplaceAllString(result, prefix+"${1}Input")
	return result
}

// namespaceMutation renames types and transforms mutation names.
func namespaceMutation(field, _, prefix string, renameMap map[string]string, _ string) string {
	lowerPrefix := strings.ToLower(prefix)
	result := field

	// Replace types
	for oldName, newName := range renameMap {
		result = strings.ReplaceAll(result, oldName, newName)
	}

	// Transform mutation names: "createFoo" -> "foo_create", "transfer" -> "foo_transfer"
	if strings.HasPrefix(result, "create") {
		// "createErc20token: ..." -> "erc20token_create: ..."
		result = strings.Replace(result, "create", lowerPrefix+"_create", 1)
		// Remove the model name after create if it exists
		result = regexp.MustCompile(`_create\w*:`).ReplaceAllString(result, "_create:")
	} else {
		// Other transitions: "transfer(input: TransferInput!)" -> "erc20token_transfer(input: ...)"
		parts := strings.SplitN(result, "(", 2)
		if len(parts) == 2 {
			transitionName := strings.TrimSpace(parts[0])
			rest := parts[1]
			result = lowerPrefix + "_" + transitionName + "(" + rest
		} else if strings.Contains(result, ":") {
			parts = strings.SplitN(result, ":", 2)
			transitionName := strings.TrimSpace(parts[0])
			rest := parts[1]
			result = lowerPrefix + "_" + transitionName + ":" + rest
		}
	}

	// Rename input types
	inputRe := regexp.MustCompile(`(\w+)Input`)
	result = inputRe.ReplaceAllString(result, prefix+"${1}Input")

	return result
}

// namespaceType renames a type definition and its field types.
func namespaceType(typeDef, prefix string, renameMap map[string]string) string {
	result := typeDef

	// Rename the type itself
	for oldName, newName := range renameMap {
		// Match "type OldName" or "input OldName"
		result = regexp.MustCompile(`(type|input)\s+`+oldName+`\b`).ReplaceAllString(result, "${1} "+newName)
		// Also rename references to the type
		result = regexp.MustCompile(`:\s*`+oldName+`\b`).ReplaceAllString(result, ": "+newName)
		result = regexp.MustCompile(`\[`+oldName+`\b`).ReplaceAllString(result, "["+newName)
	}

	// Rename input types
	result = regexp.MustCompile(`(type|input)\s+(\w+)Input\b`).ReplaceAllString(result, "${1} "+prefix+"${2}Input")
	result = regexp.MustCompile(`:\s*(\w+)Input\b`).ReplaceAllString(result, ": "+prefix+"${1}Input")

	return result
}

// toPascalCase converts a string to PascalCase.
func toPascalCase(s string) string {
	if s == "" {
		return ""
	}
	// Capitalize first letter
	return strings.ToUpper(s[:1]) + s[1:]
}

// ServeHTTP handles GraphQL requests.
func (ug *UnifiedGraphQL) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	var req struct {
		Query         string         `json:"query"`
		OperationName string         `json:"operationName"`
		Variables     map[string]any `json:"variables"`
	}

	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}

	result := ug.executeGraphQL(r.Context(), req.Query, req.OperationName, req.Variables)

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(result)
}

// executeGraphQL executes a GraphQL query or mutation.
func (ug *UnifiedGraphQL) executeGraphQL(ctx context.Context, query, _ string, variables map[string]any) map[string]any {
	result := make(map[string]any)
	data := make(map[string]any)
	var errors []map[string]any

	// Detect mutation vs query
	isMutation := strings.Contains(query, "mutation")

	// Find all operation names in the query
	operations := ug.parseOperations(query, isMutation)

	for _, op := range operations {
		entry, ok := ug.resolvers[op]
		if !ok {
			continue
		}

		// Execute the resolver
		res, err := entry.resolver(ctx, variables)
		if err != nil {
			errors = append(errors, map[string]any{"message": err.Error()})
		} else {
			data[op] = res
		}
	}

	result["data"] = data
	if len(errors) > 0 {
		result["errors"] = errors
	}

	return result
}

// parseOperations extracts operation names from a GraphQL query.
func (ug *UnifiedGraphQL) parseOperations(query string, _ bool) []string {
	var operations []string

	// Look for registered resolver names in the query
	for opName := range ug.resolvers {
		// Check if this operation is in the query
		// Match "opName(" or "opName {" or "opName\n"
		pattern := regexp.MustCompile(`\b` + regexp.QuoteMeta(opName) + `\s*[(\{]`)
		if pattern.MatchString(query) {
			operations = append(operations, opName)
		}
	}

	return operations
}

// Handler returns the HTTP handler for the unified GraphQL endpoint.
func (ug *UnifiedGraphQL) Handler() http.Handler {
	return ug
}

// SchemaHandler returns an HTTP handler that serves the schema.
func (ug *UnifiedGraphQL) SchemaHandler() http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		fmt.Fprint(w, ug.schema)
	}
}
