// Package serve provides unified GraphQL support for Petri-pilot services.
package serve

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"regexp"
	"sort"
	"strings"

	gopflowgql "github.com/pflow-xyz/go-pflow/graphql"
)

// UnifiedGraphQL combines multiple service schemas into a single GraphQL endpoint.
type UnifiedGraphQL struct {
	services      map[string]GraphQLService
	schema        string
	resolvers     map[string]resolverEntry
	introspection map[string]any // cached introspection result

	// gopflowServer is set when using NewUnifiedGraphQLFromGoPflow
	// When set, query execution is delegated to go-pflow's Server
	gopflowServer *gopflowgql.Server
}

type resolverEntry struct {
	serviceName string
	resolver    GraphQLResolver
}

// NewUnifiedGraphQL creates a new unified GraphQL handler from the given services.
func NewUnifiedGraphQL(services []GraphQLService) *UnifiedGraphQL {
	ug := &UnifiedGraphQL{
		services:  make(map[string]GraphQLService),
		resolvers: make(map[string]resolverEntry),
	}

	for _, svc := range services {
		name := svc.Name()
		ug.services[name] = svc

		// Register all resolvers from this service
		for opName, resolver := range svc.GraphQLResolvers() {
			ug.resolvers[opName] = resolverEntry{
				serviceName: name,
				resolver:    resolver,
			}
		}
	}

	// Combine schemas
	ug.schema = ug.combineSchemas()

	// Build introspection result from schema (using go-pflow's graphql package)
	ug.introspection = gopflowgql.BuildIntrospection(ug.schema)

	return ug
}

// Schema returns the combined GraphQL schema.
func (ug *UnifiedGraphQL) Schema() string {
	return ug.schema
}

// combineSchemas merges all service schemas into a unified schema.
func (ug *UnifiedGraphQL) combineSchemas() string {
	var queries []string
	var mutations []string
	var types []string

	// Sort service names for deterministic output
	names := make([]string, 0, len(ug.services))
	for name := range ug.services {
		names = append(names, name)
	}
	sort.Strings(names)

	for _, name := range names {
		svc := ug.services[name]
		schema := svc.GraphQLSchema()
		if schema == "" {
			continue
		}

		// Extract and namespace the schema components
		q, m, t := ug.extractAndNamespace(name, schema)
		queries = append(queries, q...)
		mutations = append(mutations, m...)
		types = append(types, t...)
	}

	// Build combined schema
	var sb strings.Builder
	sb.WriteString("# Unified GraphQL Schema - Generated by Petri-Pilot\n\n")
	sb.WriteString("scalar Time\n\n")

	// Query type
	sb.WriteString("type Query {\n")
	for _, q := range queries {
		sb.WriteString("  " + q + "\n")
	}
	sb.WriteString("}\n\n")

	// Mutation type
	if len(mutations) > 0 {
		sb.WriteString("type Mutation {\n")
		for _, m := range mutations {
			sb.WriteString("  " + m + "\n")
		}
		sb.WriteString("}\n\n")
	}

	// Type definitions
	for _, t := range types {
		sb.WriteString(t + "\n\n")
	}

	return sb.String()
}

// extractAndNamespace parses a service schema and prefixes types/operations with the service name.
func (ug *UnifiedGraphQL) extractAndNamespace(serviceName, schema string) (queries, mutations, types []string) {
	// Convert service name to prefix (e.g., "erc20-token" -> "Erc20token")
	prefix := toPascalCase(strings.ReplaceAll(serviceName, "-", ""))
	lowerPrefix := strings.ToLower(prefix)

	// First pass: collect all type/input names defined in this schema
	definedTypes := make(map[string]bool)
	for _, line := range strings.Split(schema, "\n") {
		trimmed := strings.TrimSpace(line)
		if strings.HasPrefix(trimmed, "type ") && strings.HasSuffix(trimmed, "{") {
			name := strings.TrimSpace(strings.TrimSuffix(strings.TrimPrefix(trimmed, "type "), "{"))
			if name != "Query" && name != "Mutation" {
				definedTypes[name] = true
			}
		} else if strings.HasPrefix(trimmed, "input ") && strings.HasSuffix(trimmed, "{") {
			name := strings.TrimSpace(strings.TrimSuffix(strings.TrimPrefix(trimmed, "input "), "{"))
			definedTypes[name] = true
		}
	}

	// Build rename map: sort by length descending to avoid substring collisions
	// e.g., "AggregateState" must be replaced before "State"
	renameMap := make(map[string]string)
	var sortedNames []string
	for typeName := range definedTypes {
		renameMap[typeName] = prefix + typeName
		sortedNames = append(sortedNames, typeName)
	}
	sort.Slice(sortedNames, func(i, j int) bool {
		return len(sortedNames[i]) > len(sortedNames[j])
	})

	// Parse the schema into sections
	lines := strings.Split(schema, "\n")
	var currentSection string
	var typeBuffer strings.Builder
	var inType bool

	for _, line := range lines {
		trimmed := strings.TrimSpace(line)

		// Detect section changes
		if strings.HasPrefix(trimmed, "type Query") {
			currentSection = "query"
			continue
		} else if strings.HasPrefix(trimmed, "type Mutation") {
			currentSection = "mutation"
			continue
		} else if (strings.HasPrefix(trimmed, "type ") || strings.HasPrefix(trimmed, "input ")) && strings.HasSuffix(trimmed, "{") {
			// Start of a type definition
			inType = true
			typeBuffer.Reset()
			typeBuffer.WriteString(line + "\n")
			currentSection = "type"
			continue
		} else if trimmed == "}" && inType {
			// End of type definition
			typeBuffer.WriteString(line)
			typeDef := typeBuffer.String()

			// Namespace the type definition
			typeDef = namespaceTypeDef(typeDef, prefix, sortedNames, renameMap)
			types = append(types, typeDef)

			inType = false
			typeBuffer.Reset()
			continue
		}

		if inType {
			typeBuffer.WriteString(line + "\n")
			continue
		}

		// Skip empty lines and comments in query/mutation sections
		if trimmed == "" || strings.HasPrefix(trimmed, "#") {
			continue
		}

		// Skip closing braces for Query/Mutation types
		if trimmed == "}" {
			currentSection = ""
			continue
		}

		switch currentSection {
		case "query":
			field := namespaceQueryField(trimmed, lowerPrefix, prefix, sortedNames, renameMap)
			queries = append(queries, field)
		case "mutation":
			field := namespaceMutationField(trimmed, lowerPrefix, prefix, sortedNames, renameMap)
			mutations = append(mutations, field)
		}
	}

	return queries, mutations, types
}

// applyTypeRenames replaces type references using word-boundary regexes,
// processing longer names first to avoid substring collisions.
func applyTypeRenames(s, _ string, sortedNames []string, renameMap map[string]string) string {
	result := s
	for _, name := range sortedNames {
		newName := renameMap[name]
		// Use word boundary to avoid "State" matching inside "AggregateState"
		re := regexp.MustCompile(`\b` + regexp.QuoteMeta(name) + `\b`)
		result = re.ReplaceAllString(result, newName)
	}
	return result
}

// namespaceQueryField renames types in a query field and prefixes un-prefixed field names.
func namespaceQueryField(field, lowerPrefix, prefix string, sortedNames []string, renameMap map[string]string) string {
	result := applyTypeRenames(field, prefix, sortedNames, renameMap)

	// Prefix field names that don't already start with the service prefix
	// e.g., "adminStats:" -> "blogpostAdminStats:", but "blogpostList" stays as-is
	fieldName := strings.TrimSpace(field)
	nameEnd := strings.IndexAny(fieldName, "(:")
	if nameEnd > 0 {
		name := strings.TrimSpace(fieldName[:nameEnd])
		if !strings.HasPrefix(name, lowerPrefix) {
			// Prefix it
			result = lowerPrefix + strings.ToUpper(name[:1]) + name[1:] + result[nameEnd:]
		}
	}

	return result
}

// namespaceMutationField renames types and transforms mutation names.
func namespaceMutationField(field, lowerPrefix, prefix string, sortedNames []string, renameMap map[string]string) string {
	// Apply type renames
	result := applyTypeRenames(field, prefix, sortedNames, renameMap)

	// Transform mutation names: "createFoo:" -> "prefix_create:", "transfer(" -> "prefix_transfer("
	trimmed := strings.TrimSpace(result)
	nameEnd := strings.IndexAny(trimmed, "(:")
	if nameEnd > 0 {
		name := strings.TrimSpace(trimmed[:nameEnd])
		sep := trimmed[nameEnd]
		rest := trimmed[nameEnd:]

		if strings.HasPrefix(name, "create") && sep == ':' {
			// Instance creation (no args): "createBlogPost: ..." -> "blogpost_create: ..."
			result = lowerPrefix + "_create" + rest
		} else {
			// Transition with args or non-create: "transfer(input: ...)" -> "prefix_transfer(input: ...)"
			result = lowerPrefix + "_" + name + rest
		}
	}

	return result
}

// namespaceTypeDef renames a type definition and its field type references.
func namespaceTypeDef(typeDef, prefix string, sortedNames []string, renameMap map[string]string) string {
	return applyTypeRenames(typeDef, prefix, sortedNames, renameMap)
}

// toPascalCase converts a string to PascalCase.
func toPascalCase(s string) string {
	if s == "" {
		return ""
	}
	// Capitalize first letter
	return strings.ToUpper(s[:1]) + s[1:]
}

// ServeHTTP handles GraphQL requests.
// Browser GET requests (Accept: text/html) are redirected to the interactive playground.
func (ug *UnifiedGraphQL) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	// Delegate to go-pflow's server if available
	if ug.gopflowServer != nil {
		ug.gopflowServer.ServeHTTP(w, r)
		return
	}

	// Legacy implementation
	if r.Method == http.MethodGet {
		accept := r.Header.Get("Accept")
		if strings.Contains(accept, "text/html") {
			http.Redirect(w, r, "/graphql/i", http.StatusSeeOther)
			return
		}
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}
	if r.Method != http.MethodPost {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	var req struct {
		Query         string         `json:"query"`
		OperationName string         `json:"operationName"`
		Variables     map[string]any `json:"variables"`
	}

	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}

	result := ug.executeGraphQL(r.Context(), req.Query, req.OperationName, req.Variables)

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(result)
}

// executeGraphQL executes a GraphQL query or mutation.
func (ug *UnifiedGraphQL) executeGraphQL(ctx context.Context, query, _ string, variables map[string]any) map[string]any {
	// Handle introspection queries (using go-pflow's graphql package)
	if gopflowgql.IsIntrospectionQuery(query) {
		return ug.introspection
	}

	result := make(map[string]any)
	data := make(map[string]any)
	var errors []map[string]any

	// Find all operation names in the query (using go-pflow's graphql package)
	knownOps := make([]string, 0, len(ug.resolvers))
	for opName := range ug.resolvers {
		knownOps = append(knownOps, opName)
	}
	operations := gopflowgql.ParseOperationNames(query, knownOps)

	for _, op := range operations {
		entry, ok := ug.resolvers[op]
		if !ok {
			continue
		}

		// Execute the resolver
		res, err := entry.resolver(ctx, variables)
		if err != nil {
			errors = append(errors, map[string]any{"message": err.Error()})
		} else {
			data[op] = res
		}
	}

	result["data"] = data
	if len(errors) > 0 {
		result["errors"] = errors
	}

	return result
}


// Handler returns the HTTP handler for the unified GraphQL endpoint.
func (ug *UnifiedGraphQL) Handler() http.Handler {
	return ug
}

// SchemaHandler returns an HTTP handler that serves the schema.
func (ug *UnifiedGraphQL) SchemaHandler() http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		fmt.Fprint(w, ug.schema)
	}
}

// Note: Introspection is now provided by github.com/pflow-xyz/go-pflow/graphql.BuildIntrospection()

// ToExternalService converts a GraphQLService to a go-pflow ExternalService.
// This allows petri-pilot services to be used with go-pflow's GraphQL Server.
func ToExternalService(svc GraphQLService) gopflowgql.ExternalService {
	resolvers := make(map[string]gopflowgql.ExternalResolver)
	for name, resolver := range svc.GraphQLResolvers() {
		// Copy the resolver - the signatures are compatible
		resolvers[name] = gopflowgql.ExternalResolver(resolver)
	}

	return gopflowgql.ExternalService{
		Name:      svc.Name(),
		Schema:    svc.GraphQLSchema(),
		Resolvers: resolvers,
	}
}

// NewUnifiedGraphQLFromGoPflow creates a UnifiedGraphQL handler using go-pflow's Server internally.
// Query execution is fully delegated to go-pflow's Server.
func NewUnifiedGraphQLFromGoPflow(services []GraphQLService) *UnifiedGraphQL {
	// Convert services to ExternalServices
	var externals []gopflowgql.ExternalService
	for _, svc := range services {
		externals = append(externals, ToExternalService(svc))
	}

	// Create go-pflow server
	opts := []gopflowgql.Option{
		gopflowgql.WithPlayground("/graphql/i"),
	}
	for _, ext := range externals {
		opts = append(opts, gopflowgql.WithExternalService(ext))
	}

	server := gopflowgql.NewServer(opts...)

	// Build resolver map for compatibility (used by old code paths if needed)
	resolverMap := make(map[string]resolverEntry)
	for _, svc := range services {
		name := svc.Name()
		for opName, resolver := range svc.GraphQLResolvers() {
			resolverMap[opName] = resolverEntry{
				serviceName: name,
				resolver:    resolver,
			}
		}
	}

	// Return a wrapper that delegates to go-pflow's server
	return &UnifiedGraphQL{
		services:      makeServiceMap(services),
		schema:        server.Schema(),
		resolvers:     resolverMap,
		introspection: gopflowgql.BuildIntrospection(server.Schema()),
		gopflowServer: server,
	}
}

func makeServiceMap(services []GraphQLService) map[string]GraphQLService {
	m := make(map[string]GraphQLService)
	for _, svc := range services {
		m[svc.Name()] = svc
	}
	return m
}
