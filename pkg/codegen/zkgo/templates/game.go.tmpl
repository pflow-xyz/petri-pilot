// Code generated by petri-pilot zkgo generator. DO NOT EDIT.
package {{.PackageName}}

import (
	"fmt"
	"math/big"
)

// PetriGame tracks the full Petri net state for ZK proof generation.
type PetriGame struct {
	Marking Marking
	Roots   []*big.Int // state root after each transition
}

// NewPetriGame creates a new game with the initial Petri net marking.
func NewPetriGame() *PetriGame {
	m := InitialMarking()
	root := ComputeMarkingRoot(m)
	return &PetriGame{
		Marking: m,
		Roots:   []*big.Int{root},
	}
}

// CurrentRoot returns the current marking's state root.
func (g *PetriGame) CurrentRoot() *big.Int {
	return g.Roots[len(g.Roots)-1]
}

// PetriTransitionWitness contains all values needed to generate a ZK proof.
type PetriTransitionWitness struct {
	PreStateRoot  *big.Int
	PostStateRoot *big.Int
	Transition    int
	PreMarking    Marking
	PostMarking   Marking
}

// FireTransition fires a transition and returns the witness for proof generation.
func (g *PetriGame) FireTransition(t int) (*PetriTransitionWitness, error) {
	if t < 0 || t >= NumTransitions {
		return nil, fmt.Errorf("invalid transition index: %d", t)
	}

	preMarking := g.Marking
	preRoot := g.CurrentRoot()

	newMarking, err := Fire(g.Marking, t)
	if err != nil {
		return nil, fmt.Errorf("transition %s failed: %w", TransitionNames[t], err)
	}

	postRoot := ComputeMarkingRoot(newMarking)

	witness := &PetriTransitionWitness{
		PreStateRoot:  preRoot,
		PostStateRoot: postRoot,
		Transition:    t,
		PreMarking:    preMarking,
		PostMarking:   newMarking,
	}

	g.Marking = newMarking
	g.Roots = append(g.Roots, postRoot)

	return witness, nil
}

// PetriPlaceWitness contains values for proving a place has tokens.
type PetriPlaceWitness struct {
	StateRoot   *big.Int
	TargetPlace int
	Marking     Marking
}

// GetPlaceWitness returns a witness for proving a place has tokens.
// Returns nil if the place has no tokens.
func (g *PetriGame) GetPlaceWitness(place int) *PetriPlaceWitness {
	if place < 0 || place >= NumPlaces {
		return nil
	}
	if g.Marking[place] == 0 {
		return nil
	}
	return &PetriPlaceWitness{
		StateRoot:   g.CurrentRoot(),
		TargetPlace: place,
		Marking:     g.Marking,
	}
}

// ToPetriTransitionAssignment converts a witness to a circuit assignment.
func (w *PetriTransitionWitness) ToPetriTransitionAssignment() *PetriTransitionCircuit {
	c := &PetriTransitionCircuit{
		PreStateRoot:  w.PreStateRoot,
		PostStateRoot: w.PostStateRoot,
		Transition:    w.Transition,
	}
	for i := 0; i < NumPlaces; i++ {
		c.PreMarking[i] = int(w.PreMarking[i])
		c.PostMarking[i] = int(w.PostMarking[i])
	}
	return c
}

// ToPetriWinAssignment converts a witness to a circuit assignment.
func (w *PetriPlaceWitness) ToPetriWinAssignment() *PetriWinCircuit {
	c := &PetriWinCircuit{
		StateRoot:   w.StateRoot,
		TargetPlace: w.TargetPlace,
	}
	for i := 0; i < NumPlaces; i++ {
		c.Marking[i] = int(w.Marking[i])
	}
	return c
}

// String returns a human-readable representation of the marking.
func (m Marking) String() string {
	var s string
	for i := 0; i < NumPlaces; i++ {
		if m[i] > 0 {
			s += fmt.Sprintf("%s: %d\n", PlaceNames[i], m[i])
		}
	}
	if s == "" {
		s = "(empty marking)\n"
	}
	return s
}
