// Code generated by petri-pilot zkgo generator. DO NOT EDIT.
package {{.PackageName}}

import (
	"github.com/consensys/gnark/frontend"
	"github.com/consensys/gnark/std/hash/mimc"
)

// PetriTransitionCircuit proves that firing a transition on the Petri net is valid.
//
// This encodes the FULL Petri net state ({{.NumPlaces}} places), not just a simplified view.
// All game logic (turns, win conditions, etc.) comes from the net topology.
//
// Public inputs:
//   - PreStateRoot:  MiMC hash of marking before transition
//   - PostStateRoot: MiMC hash of marking after transition
//   - Transition:    which transition fired (0-{{sub .NumTransitions 1}})
//
// Private inputs:
//   - PreMarking:  token counts for all {{.NumPlaces}} places before firing
//   - PostMarking: token counts for all {{.NumPlaces}} places after firing
type PetriTransitionCircuit struct {
	// Public
	PreStateRoot  frontend.Variable `gnark:",public"`
	PostStateRoot frontend.Variable `gnark:",public"`
	Transition    frontend.Variable `gnark:",public"`

	// Private
	PreMarking  [NumPlaces]frontend.Variable
	PostMarking [NumPlaces]frontend.Variable
}

// Define declares the constraints for valid Petri net transition firing.
func (c *PetriTransitionCircuit) Define(api frontend.API) error {
	// 1. Verify pre-state root matches the private marking
	preRoot := petriMimcHash(api, c.PreMarking[:])
	api.AssertIsEqual(preRoot, c.PreStateRoot)

	// 2. Verify post-state root matches the private marking
	postRoot := petriMimcHash(api, c.PostMarking[:])
	api.AssertIsEqual(postRoot, c.PostStateRoot)

	// 3. Compute expected input/output deltas based on which transition fired
	var deltas [NumPlaces]frontend.Variable
	for p := 0; p < NumPlaces; p++ {
		deltas[p] = frontend.Variable(0)
	}

	// For each transition, conditionally add its effect
	for t := 0; t < NumTransitions; t++ {
		isThis := api.IsZero(api.Sub(c.Transition, t))

		// Subtract 1 from input places
		for _, p := range Topology[t].Inputs {
			deltas[p] = api.Sub(deltas[p], isThis)
		}
		// Add 1 to output places
		for _, p := range Topology[t].Outputs {
			deltas[p] = api.Add(deltas[p], isThis)
		}
	}

	// 4. Verify the marking change matches the computed deltas
	for p := 0; p < NumPlaces; p++ {
		expected := api.Add(c.PreMarking[p], deltas[p])
		api.AssertIsEqual(c.PostMarking[p], expected)
	}

	// 5. Verify enabledness: for the selected transition, all input places must have >= 1 token
	for p := 0; p < NumPlaces; p++ {
		isInput := frontend.Variable(0)
		for t := 0; t < NumTransitions; t++ {
			isThis := api.IsZero(api.Sub(c.Transition, t))
			for _, inp := range Topology[t].Inputs {
				if inp == p {
					isInput = api.Add(isInput, isThis)
				}
			}
		}
		// pre[p] - isInput must be non-negative
		diff := api.Sub(c.PreMarking[p], isInput)
		api.ToBinary(diff, 8)
	}

	return nil
}

// petriMimcHash computes MiMC hash of marking values.
func petriMimcHash(api frontend.API, values []frontend.Variable) frontend.Variable {
	h, _ := mimc.NewMiMC(api)
	for _, v := range values {
		h.Write(v)
	}
	return h.Sum()
}

// PetriWinCircuit proves that a specific place has tokens.
// This is generic - can be used to prove any place condition.
type PetriWinCircuit struct {
	// Public
	StateRoot   frontend.Variable `gnark:",public"`
	TargetPlace frontend.Variable `gnark:",public"` // place index to check

	// Private
	Marking [NumPlaces]frontend.Variable
}

// Define declares the constraints for place verification.
func (c *PetriWinCircuit) Define(api frontend.API) error {
	// 1. Verify state root matches the private marking
	root := petriMimcHash(api, c.Marking[:])
	api.AssertIsEqual(root, c.StateRoot)

	// 2. Verify the target place has at least 1 token
	tokens := frontend.Variable(0)
	for p := 0; p < NumPlaces; p++ {
		isTarget := api.IsZero(api.Sub(c.TargetPlace, p))
		tokens = api.Add(tokens, api.Mul(c.Marking[p], isTarget))
	}

	// tokens >= 1
	api.ToBinary(api.Sub(tokens, 1), 8)

	return nil
}
