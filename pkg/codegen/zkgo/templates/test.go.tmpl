// Code generated by petri-pilot zkgo generator. DO NOT EDIT.
package {{.PackageName}}

import (
	"testing"

	"github.com/consensys/gnark-crypto/ecc"
	"github.com/consensys/gnark/frontend"
	"github.com/consensys/gnark/frontend/cs/r1cs"
	"github.com/consensys/gnark/test"
)

func TestPetriTransitionCircuit_Compiles(t *testing.T) {
	_, err := frontend.Compile(ecc.BN254.ScalarField(), r1cs.NewBuilder, &PetriTransitionCircuit{})
	if err != nil {
		t.Fatalf("PetriTransitionCircuit compilation failed: %v", err)
	}
}

func TestPetriWinCircuit_Compiles(t *testing.T) {
	_, err := frontend.Compile(ecc.BN254.ScalarField(), r1cs.NewBuilder, &PetriWinCircuit{})
	if err != nil {
		t.Fatalf("PetriWinCircuit compilation failed: %v", err)
	}
}

func TestPetriTransitionCircuit_ValidTransition(t *testing.T) {
	game := NewPetriGame()

	// Find first enabled transition
	enabled := EnabledTransitions(game.Marking)
	if len(enabled) == 0 {
		t.Skip("no enabled transitions in initial state")
	}

	witness, err := game.FireTransition(enabled[0])
	if err != nil {
		t.Fatal(err)
	}

	assignment := witness.ToPetriTransitionAssignment()
	assert := test.NewAssert(t)
	assert.ProverSucceeded(&PetriTransitionCircuit{}, assignment, test.WithCurves(ecc.BN254))
}

func TestPetriTransitionCircuit_InvalidTransition(t *testing.T) {
	game := NewPetriGame()

	// Find a disabled transition
	var disabled int = -1
	for tr := 0; tr < NumTransitions; tr++ {
		if !IsEnabled(game.Marking, tr) {
			disabled = tr
			break
		}
	}
	if disabled == -1 {
		t.Skip("all transitions are enabled")
	}

	// Trying to fire disabled transition should fail
	_, err := game.FireTransition(disabled)
	if err == nil {
		t.Fatal("expected error for disabled transition")
	}
}

func TestMarkingRootConsistency(t *testing.T) {
	m1 := InitialMarking()
	r1 := ComputeMarkingRoot(m1)
	r2 := ComputeMarkingRoot(m1)

	if r1.Cmp(r2) != 0 {
		t.Fatal("marking root not deterministic")
	}
}

func TestInitialMarking(t *testing.T) {
	m := InitialMarking()

	// Verify some places have expected initial values
	nonZero := 0
	for i := 0; i < NumPlaces; i++ {
		if m[i] > 0 {
			nonZero++
		}
	}

	if nonZero == 0 {
		t.Log("Warning: initial marking has no tokens")
	}
}

func TestTopologyConsistency(t *testing.T) {
	// Verify all arc references are valid place indices
	for tr := 0; tr < NumTransitions; tr++ {
		for _, p := range Topology[tr].Inputs {
			if p < 0 || p >= NumPlaces {
				t.Errorf("transition %s has invalid input place index %d", TransitionNames[tr], p)
			}
		}
		for _, p := range Topology[tr].Outputs {
			if p < 0 || p >= NumPlaces {
				t.Errorf("transition %s has invalid output place index %d", TransitionNames[tr], p)
			}
		}
	}
}
