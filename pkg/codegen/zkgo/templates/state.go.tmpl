// Code generated by petri-pilot zkgo generator. DO NOT EDIT.
package {{.PackageName}}

import (
	"fmt"
	"math/big"

	"github.com/consensys/gnark-crypto/ecc/bn254/fr"
	"github.com/consensys/gnark-crypto/ecc/bn254/fr/mimc"
)

// NumPlaces is the number of places in the {{.ModelName}} Petri net.
const NumPlaces = {{.NumPlaces}}

// NumTransitions is the number of transitions in the {{.ModelName}} Petri net.
const NumTransitions = {{.NumTransitions}}

// Place indices for the {{.ModelName}} Petri net.
const (
{{- range .Places}}
	{{.VarName}} = {{.Index}}
{{- end}}
)

// PlaceNames maps place indices to their IDs.
var PlaceNames = [NumPlaces]string{
{{- range .Places}}
	"{{.ID}}",
{{- end}}
}

// Transition indices for the {{.ModelName}} Petri net.
const (
{{- range .Transitions}}
	{{.VarName}} = {{.Index}}
{{- end}}
)

// TransitionNames maps transition indices to their IDs.
var TransitionNames = [NumTransitions]string{
{{- range .Transitions}}
	"{{.ID}}",
{{- end}}
}

// ArcDef represents input and output arcs for a transition.
type ArcDef struct {
	Inputs  []int // places consumed
	Outputs []int // places produced
}

// Topology defines the Petri net arcs.
var Topology = [NumTransitions]ArcDef{
{{- range .Transitions}}
	{{.VarName}}: {Inputs: {{.InputsStr}}, Outputs: {{.OutputsStr}}},
{{- end}}
}

// Marking represents the token counts for all places in the Petri net.
type Marking [NumPlaces]uint8

// InitialMarking returns the initial marking from the model.
func InitialMarking() Marking {
	return Marking{
{{- range $i, $p := .Places}}
		{{$i}}: {{$p.Initial}}, // {{$p.ID}}
{{- end}}
	}
}

// ComputeMarkingRoot computes a MiMC hash of the full marking.
func ComputeMarkingRoot(m Marking) *big.Int {
	h := mimc.NewMiMC()
	for _, tokens := range m {
		var elem fr.Element
		elem.SetUint64(uint64(tokens))
		b := elem.Bytes()
		h.Write(b[:])
	}
	sum := h.Sum(nil)
	return new(big.Int).SetBytes(sum)
}

// IsEnabled checks if a transition can fire with the current marking.
func IsEnabled(m Marking, t int) bool {
	if t < 0 || t >= NumTransitions {
		return false
	}
	for _, p := range Topology[t].Inputs {
		if m[p] < 1 {
			return false
		}
	}
	return true
}

// Fire applies a transition and returns the new marking.
func Fire(m Marking, t int) (Marking, error) {
	if !IsEnabled(m, t) {
		return m, fmt.Errorf("transition %s is not enabled", TransitionNames[t])
	}

	newM := m
	for _, p := range Topology[t].Inputs {
		newM[p]--
	}
	for _, p := range Topology[t].Outputs {
		newM[p]++
	}
	return newM, nil
}

// EnabledTransitions returns all transitions that can fire.
func EnabledTransitions(m Marking) []int {
	var enabled []int
	for t := 0; t < NumTransitions; t++ {
		if IsEnabled(m, t) {
			enabled = append(enabled, t)
		}
	}
	return enabled
}
