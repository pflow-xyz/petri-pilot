// Code generated by petri-pilot. DO NOT EDIT.

package {{.PackageName}}

import (
	"log/slog"
	"net/http"
	"os"
	"time"

	"github.com/prometheus/client_golang/prometheus"
	"github.com/prometheus/client_golang/prometheus/promauto"
	"github.com/prometheus/client_golang/prometheus/promhttp"
)

// Metrics for the application.
var (
	httpRequestsTotal = promauto.NewCounterVec(
		prometheus.CounterOpts{
			Name: "http_requests_total",
			Help: "Total number of HTTP requests",
		},
		[]string{"method", "path", "status"},
	)

	httpRequestDuration = promauto.NewHistogramVec(
		prometheus.HistogramOpts{
			Name:    "http_request_duration_seconds",
			Help:    "HTTP request duration in seconds",
			Buckets: prometheus.DefBuckets,
		},
		[]string{"method", "path"},
	)

	transitionsFired = promauto.NewCounterVec(
		prometheus.CounterOpts{
			Name: "transitions_fired_total",
			Help: "Total number of transitions fired",
		},
		[]string{"transition", "status"},
	)

	eventsStored = promauto.NewCounter(
		prometheus.CounterOpts{
			Name: "events_stored_total",
			Help: "Total number of events stored",
		},
	)

	aggregatesLoaded = promauto.NewCounter(
		prometheus.CounterOpts{
			Name: "aggregates_loaded_total",
			Help: "Total number of aggregates loaded",
		},
	)
)

// SetupLogger configures the global slog logger.
func SetupLogger(cfg *Config) *slog.Logger {
	var handler slog.Handler

	opts := &slog.HandlerOptions{
		Level: parseLogLevel(cfg.LogLevel),
	}

	if cfg.LogFormat == "json" {
		handler = slog.NewJSONHandler(os.Stdout, opts)
	} else {
		handler = slog.NewTextHandler(os.Stdout, opts)
	}

	logger := slog.New(handler)
	slog.SetDefault(logger)

	return logger
}

func parseLogLevel(level string) slog.Level {
	switch level {
	case "debug":
		return slog.LevelDebug
	case "info":
		return slog.LevelInfo
	case "warn":
		return slog.LevelWarn
	case "error":
		return slog.LevelError
	default:
		return slog.LevelInfo
	}
}

// MetricsHandler returns the Prometheus metrics handler.
func MetricsHandler() http.Handler {
	return promhttp.Handler()
}

// LoggingMiddleware logs HTTP requests.
func LoggingMiddleware(logger *slog.Logger) func(http.Handler) http.Handler {
	return func(next http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			start := time.Now()

			// Wrap response writer to capture status code
			wrapped := &statusResponseWriter{ResponseWriter: w, status: http.StatusOK}

			next.ServeHTTP(wrapped, r)

			duration := time.Since(start)

			// Log the request
			logger.Info("http request",
				"method", r.Method,
				"path", r.URL.Path,
				"status", wrapped.status,
				"duration_ms", duration.Milliseconds(),
				"remote_addr", r.RemoteAddr,
				"user_agent", r.UserAgent(),
			)

			// Record metrics
			httpRequestsTotal.WithLabelValues(
				r.Method,
				r.URL.Path,
				http.StatusText(wrapped.status),
			).Inc()

			httpRequestDuration.WithLabelValues(
				r.Method,
				r.URL.Path,
			).Observe(duration.Seconds())
		})
	}
}

type statusResponseWriter struct {
	http.ResponseWriter
	status int
}

func (w *statusResponseWriter) WriteHeader(status int) {
	w.status = status
	w.ResponseWriter.WriteHeader(status)
}

// RecordTransitionFired records a transition being fired.
func RecordTransitionFired(transition string, success bool) {
	status := "success"
	if !success {
		status = "failure"
	}
	transitionsFired.WithLabelValues(transition, status).Inc()
}

// RecordEventStored records an event being stored.
func RecordEventStored() {
	eventsStored.Inc()
}

// RecordAggregateLoaded records an aggregate being loaded.
func RecordAggregateLoaded() {
	aggregatesLoaded.Inc()
}
