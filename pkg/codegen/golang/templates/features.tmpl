// Code generated by petri-pilot. DO NOT EDIT.

package {{.PackageName}}

import (
{{- if .HasInboundWebhooks}}
	"crypto/hmac"
	"crypto/sha256"
	"encoding/hex"
{{- end}}
	"database/sql"
{{- if or .HasTimers .HasNotifications .HasBatch .HasExport .HasInboundWebhooks .HasTags .HasComments .HasActivity .HasFavorites .HasTemplates .HasApprovals .HasRelationships .HasDocuments}}
	"encoding/json"
{{- end}}
{{- if or .HasTimers .HasTags .HasComments .HasActivity .HasFavorites .HasTemplates .HasApprovals .HasRelationships .HasNotifications .HasDocuments (and .HasSoftDelete .HasAccessControl)}}
	"fmt"
{{- end}}
	"net/http"
{{- if .HasExport}}
	"encoding/csv"
{{- end}}
{{- if or .HasTimers .HasNotifications .HasInboundWebhooks}}
	"os"
	"strings"
{{- end}}
	"time"

	"github.com/pflow-xyz/petri-pilot/pkg/runtime/api"
)

{{if .HasTimers}}
// ============================================================================
// TIMERS
// ============================================================================

// TimerManager handles scheduled and delayed transitions.
type TimerManager struct {
	db  *sql.DB
	app *Application
}

// Timer represents a scheduled timer.
type Timer struct {
	ID           string    `json:"id"`
	AggregateID  string    `json:"aggregateId"`
	Transition   string    `json:"transition"`
	FireAt       time.Time `json:"fireAt"`
	Condition    string    `json:"condition,omitempty"`
	Status       string    `json:"status"` // pending, fired, cancelled
	CreatedAt    time.Time `json:"createdAt"`
}

// NewTimerManager creates a new TimerManager.
func NewTimerManager(db *sql.DB, app *Application) *TimerManager {
	return &TimerManager{db: db, app: app}
}

// InitSchema creates the timers table.
func (tm *TimerManager) InitSchema() error {
	_, err := tm.db.Exec(`
		CREATE TABLE IF NOT EXISTS timers (
			id TEXT PRIMARY KEY,
			aggregate_id TEXT NOT NULL,
			transition TEXT NOT NULL,
			fire_at TEXT NOT NULL,
			condition TEXT,
			status TEXT NOT NULL DEFAULT 'pending',
			created_at TEXT NOT NULL
		);
		CREATE INDEX IF NOT EXISTS idx_timers_fire_at ON timers(fire_at) WHERE status = 'pending';
		CREATE INDEX IF NOT EXISTS idx_timers_aggregate ON timers(aggregate_id);
	`)
	return err
}

// Schedule creates a new timer.
func (tm *TimerManager) Schedule(aggregateID, transition string, fireAt time.Time, condition string) (*Timer, error) {
	id := fmt.Sprintf("timer_%d", time.Now().UnixNano())
	now := time.Now().UTC()

	_, err := tm.db.Exec(`
		INSERT INTO timers (id, aggregate_id, transition, fire_at, condition, status, created_at)
		VALUES (?, ?, ?, ?, ?, 'pending', ?)
	`, id, aggregateID, transition, fireAt.Format(time.RFC3339), condition, now.Format(time.RFC3339))
	if err != nil {
		return nil, err
	}

	return &Timer{
		ID:          id,
		AggregateID: aggregateID,
		Transition:  transition,
		FireAt:      fireAt,
		Condition:   condition,
		Status:      "pending",
		CreatedAt:   now,
	}, nil
}

// Cancel cancels a timer.
func (tm *TimerManager) Cancel(id string) error {
	_, err := tm.db.Exec(`UPDATE timers SET status = 'cancelled' WHERE id = ?`, id)
	return err
}

// ProcessDueTimers processes all timers that are due.
func (tm *TimerManager) ProcessDueTimers() error {
	now := time.Now().UTC()
	rows, err := tm.db.Query(`
		SELECT id, aggregate_id, transition, condition
		FROM timers WHERE status = 'pending' AND fire_at <= ?
	`, now.Format(time.RFC3339))
	if err != nil {
		return err
	}
	defer rows.Close()

	for rows.Next() {
		var id, aggregateID, transition, condition string
		if err := rows.Scan(&id, &aggregateID, &transition, &condition); err != nil {
			continue
		}

		// TODO: Evaluate condition if set
		// Fire the transition
		// _, err := tm.app.Execute(context.Background(), aggregateID, transition, nil)

		// Mark as fired
		tm.db.Exec(`UPDATE timers SET status = 'fired' WHERE id = ?`, id)
	}
	return nil
}

// HandleListTimers lists timers for an aggregate.
func (tm *TimerManager) HandleListTimers(w http.ResponseWriter, r *http.Request) {
	aggregateID := r.URL.Query().Get("aggregate_id")

	query := `SELECT id, aggregate_id, transition, fire_at, condition, status, created_at FROM timers`
	args := []interface{}{}
	if aggregateID != "" {
		query += ` WHERE aggregate_id = ?`
		args = append(args, aggregateID)
	}
	query += ` ORDER BY fire_at DESC LIMIT 100`

	rows, err := tm.db.Query(query, args...)
	if err != nil {
		api.Error(w, http.StatusInternalServerError, "QUERY_FAILED", err.Error())
		return
	}
	defer rows.Close()

	var timers []Timer
	for rows.Next() {
		var t Timer
		var fireAt, createdAt string
		if err := rows.Scan(&t.ID, &t.AggregateID, &t.Transition, &fireAt, &t.Condition, &t.Status, &createdAt); err != nil {
			continue
		}
		t.FireAt, _ = time.Parse(time.RFC3339, fireAt)
		t.CreatedAt, _ = time.Parse(time.RFC3339, createdAt)
		timers = append(timers, t)
	}

	api.JSON(w, http.StatusOK, map[string]interface{}{"timers": timers})
}
{{end}}

{{if .HasNotifications}}
// ============================================================================
// NOTIFICATIONS
// ============================================================================

// NotificationManager handles sending notifications.
type NotificationManager struct {
	db *sql.DB
}

// Notification represents a notification record.
type Notification struct {
	ID        string    `json:"id"`
	Channel   string    `json:"channel"`
	Recipient string    `json:"recipient"`
	Subject   string    `json:"subject,omitempty"`
	Body      string    `json:"body"`
	Status    string    `json:"status"` // pending, sent, failed
	CreatedAt time.Time `json:"createdAt"`
	SentAt    *time.Time `json:"sentAt,omitempty"`
	Error     string    `json:"error,omitempty"`
}

// NewNotificationManager creates a new NotificationManager.
func NewNotificationManager(db *sql.DB) *NotificationManager {
	return &NotificationManager{db: db}
}

// InitSchema creates the notifications table.
func (nm *NotificationManager) InitSchema() error {
	_, err := nm.db.Exec(`
		CREATE TABLE IF NOT EXISTS notifications (
			id TEXT PRIMARY KEY,
			channel TEXT NOT NULL,
			recipient TEXT NOT NULL,
			subject TEXT,
			body TEXT NOT NULL,
			status TEXT NOT NULL DEFAULT 'pending',
			created_at TEXT NOT NULL,
			sent_at TEXT,
			error TEXT
		);
		CREATE INDEX IF NOT EXISTS idx_notifications_status ON notifications(status);
	`)
	return err
}

// Send queues a notification for sending.
func (nm *NotificationManager) Send(channel, recipient, subject, body string) (*Notification, error) {
	id := fmt.Sprintf("notif_%d", time.Now().UnixNano())
	now := time.Now().UTC()

	_, err := nm.db.Exec(`
		INSERT INTO notifications (id, channel, recipient, subject, body, status, created_at)
		VALUES (?, ?, ?, ?, ?, 'pending', ?)
	`, id, channel, recipient, subject, body, now.Format(time.RFC3339))
	if err != nil {
		return nil, err
	}

	// Process immediately for webhooks
	if channel == "webhook" {
		go nm.processWebhook(id, recipient, body)
	}

	return &Notification{
		ID:        id,
		Channel:   channel,
		Recipient: recipient,
		Subject:   subject,
		Body:      body,
		Status:    "pending",
		CreatedAt: now,
	}, nil
}

func (nm *NotificationManager) processWebhook(id, url, body string) {
	resp, err := http.Post(url, "application/json", strings.NewReader(body))
	now := time.Now().UTC()

	if err != nil {
		nm.db.Exec(`UPDATE notifications SET status = 'failed', error = ?, sent_at = ? WHERE id = ?`,
			err.Error(), now.Format(time.RFC3339), id)
		return
	}
	defer resp.Body.Close()

	if resp.StatusCode >= 200 && resp.StatusCode < 300 {
		nm.db.Exec(`UPDATE notifications SET status = 'sent', sent_at = ? WHERE id = ?`,
			now.Format(time.RFC3339), id)
	} else {
		nm.db.Exec(`UPDATE notifications SET status = 'failed', error = ?, sent_at = ? WHERE id = ?`,
			fmt.Sprintf("HTTP %d", resp.StatusCode), now.Format(time.RFC3339), id)
	}
}

// HandleListNotifications lists recent notifications.
func (nm *NotificationManager) HandleListNotifications(w http.ResponseWriter, r *http.Request) {
	rows, err := nm.db.Query(`
		SELECT id, channel, recipient, subject, body, status, created_at, sent_at, error
		FROM notifications ORDER BY created_at DESC LIMIT 100
	`)
	if err != nil {
		api.Error(w, http.StatusInternalServerError, "QUERY_FAILED", err.Error())
		return
	}
	defer rows.Close()

	var notifications []Notification
	for rows.Next() {
		var n Notification
		var createdAt string
		var sentAt, errStr sql.NullString
		if err := rows.Scan(&n.ID, &n.Channel, &n.Recipient, &n.Subject, &n.Body, &n.Status, &createdAt, &sentAt, &errStr); err != nil {
			continue
		}
		n.CreatedAt, _ = time.Parse(time.RFC3339, createdAt)
		if sentAt.Valid {
			t, _ := time.Parse(time.RFC3339, sentAt.String)
			n.SentAt = &t
		}
		if errStr.Valid {
			n.Error = errStr.String
		}
		notifications = append(notifications, n)
	}

	api.JSON(w, http.StatusOK, map[string]interface{}{"notifications": notifications})
}
{{end}}

{{if .HasComments}}
// ============================================================================
// COMMENTS
// ============================================================================

// Comment represents a comment on an aggregate.
type Comment struct {
	ID          string    `json:"id"`
	AggregateID string    `json:"aggregateId"`
	UserID      string    `json:"userId"`
	UserName    string    `json:"userName,omitempty"`
	Content     string    `json:"content"`
	CreatedAt   time.Time `json:"createdAt"`
	UpdatedAt   time.Time `json:"updatedAt"`
}

// CommentStore manages comments.
type CommentStore struct {
	db        *sql.DB
	maxLength int
}

// NewCommentStore creates a new CommentStore.
func NewCommentStore(db *sql.DB) *CommentStore {
	return &CommentStore{db: db, maxLength: {{if .Comments.MaxLength}}{{.Comments.MaxLength}}{{else}}2000{{end}}}
}

// InitSchema creates the comments table.
func (cs *CommentStore) InitSchema() error {
	_, err := cs.db.Exec(`
		CREATE TABLE IF NOT EXISTS comments (
			id TEXT PRIMARY KEY,
			aggregate_id TEXT NOT NULL,
			user_id TEXT NOT NULL,
			user_name TEXT,
			content TEXT NOT NULL,
			created_at TEXT NOT NULL,
			updated_at TEXT NOT NULL
		);
		CREATE INDEX IF NOT EXISTS idx_comments_aggregate ON comments(aggregate_id);
	`)
	return err
}

// Add adds a comment.
func (cs *CommentStore) Add(aggregateID, userID, userName, content string) (*Comment, error) {
	if len(content) > cs.maxLength {
		return nil, fmt.Errorf("comment exceeds maximum length of %d", cs.maxLength)
	}

	id := fmt.Sprintf("comment_%d", time.Now().UnixNano())
	now := time.Now().UTC()

	_, err := cs.db.Exec(`
		INSERT INTO comments (id, aggregate_id, user_id, user_name, content, created_at, updated_at)
		VALUES (?, ?, ?, ?, ?, ?, ?)
	`, id, aggregateID, userID, userName, content, now.Format(time.RFC3339), now.Format(time.RFC3339))
	if err != nil {
		return nil, err
	}

	return &Comment{
		ID:          id,
		AggregateID: aggregateID,
		UserID:      userID,
		UserName:    userName,
		Content:     content,
		CreatedAt:   now,
		UpdatedAt:   now,
	}, nil
}

// List lists comments for an aggregate.
func (cs *CommentStore) List(aggregateID string) ([]Comment, error) {
	rows, err := cs.db.Query(`
		SELECT id, aggregate_id, user_id, user_name, content, created_at, updated_at
		FROM comments WHERE aggregate_id = ? ORDER BY created_at ASC
	`, aggregateID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var comments []Comment
	for rows.Next() {
		var c Comment
		var createdAt, updatedAt string
		if err := rows.Scan(&c.ID, &c.AggregateID, &c.UserID, &c.UserName, &c.Content, &createdAt, &updatedAt); err != nil {
			continue
		}
		c.CreatedAt, _ = time.Parse(time.RFC3339, createdAt)
		c.UpdatedAt, _ = time.Parse(time.RFC3339, updatedAt)
		comments = append(comments, c)
	}
	return comments, nil
}

// Delete deletes a comment.
func (cs *CommentStore) Delete(id, userID string, isAdmin bool) error {
	if !isAdmin {
		var ownerID string
		err := cs.db.QueryRow(`SELECT user_id FROM comments WHERE id = ?`, id).Scan(&ownerID)
		if err != nil {
			return err
		}
		if ownerID != userID {
			return fmt.Errorf("not authorized to delete this comment")
		}
	}
	_, err := cs.db.Exec(`DELETE FROM comments WHERE id = ?`, id)
	return err
}

// HandleAddComment handles adding a comment.
func (cs *CommentStore) HandleAddComment(w http.ResponseWriter, r *http.Request) {
	aggregateID := r.PathValue("id")
	if aggregateID == "" {
		api.Error(w, http.StatusBadRequest, "MISSING_ID", "aggregate ID required")
		return
	}

	userID, userName := getCommentUser(r)
	if userID == "" {
		api.Error(w, http.StatusUnauthorized, "UNAUTHORIZED", "authentication required")
		return
	}

	var req struct {
		Content string `json:"content"`
	}
	if err := api.DecodeJSON(r, &req); err != nil {
		api.Error(w, http.StatusBadRequest, "INVALID_REQUEST", err.Error())
		return
	}

	comment, err := cs.Add(aggregateID, userID, userName, req.Content)
	if err != nil {
		api.Error(w, http.StatusBadRequest, "ADD_FAILED", err.Error())
		return
	}

	api.JSON(w, http.StatusCreated, comment)
}

// HandleListComments handles listing comments.
func (cs *CommentStore) HandleListComments(w http.ResponseWriter, r *http.Request) {
	aggregateID := r.PathValue("id")
	if aggregateID == "" {
		api.Error(w, http.StatusBadRequest, "MISSING_ID", "aggregate ID required")
		return
	}

	comments, err := cs.List(aggregateID)
	if err != nil {
		api.Error(w, http.StatusInternalServerError, "LIST_FAILED", err.Error())
		return
	}

	api.JSON(w, http.StatusOK, map[string]interface{}{"comments": comments})
}

// HandleDeleteComment handles deleting a comment.
func (cs *CommentStore) HandleDeleteComment(w http.ResponseWriter, r *http.Request) {
	id := r.PathValue("commentId")
	if id == "" {
		api.Error(w, http.StatusBadRequest, "MISSING_ID", "comment ID required")
		return
	}

	userID, _ := getCommentUser(r)
	if userID == "" {
		api.Error(w, http.StatusUnauthorized, "UNAUTHORIZED", "authentication required")
		return
	}

	if err := cs.Delete(id, userID, isCommentAdmin(r)); err != nil {
		api.Error(w, http.StatusForbidden, "DELETE_FAILED", err.Error())
		return
	}

	api.JSON(w, http.StatusOK, map[string]interface{}{"success": true})
}

func getCommentUser(r *http.Request) (string, string) {
{{- if $.HasAccessControl}}
	user, ok := r.Context().Value("user").(*User)
	if !ok || user == nil {
		return "", ""
	}
	return fmt.Sprintf("%d", user.ID), user.Name
{{- else}}
	return "anonymous", "Anonymous"
{{- end}}
}

func isCommentAdmin(r *http.Request) bool {
{{- if $.HasAccessControl}}
	user, ok := r.Context().Value("user").(*User)
	if !ok || user == nil {
		return false
	}
	for _, role := range user.Roles {
		if role == "admin" {
			return true
		}
	}
	return false
{{- else}}
	_ = r
	return false
{{- end}}
}
{{end}}

{{if .HasTags}}
// ============================================================================
// TAGS
// ============================================================================

// Tag represents a tag on an aggregate.
type Tag struct {
	ID          string `json:"id"`
	AggregateID string `json:"aggregateId"`
	Name        string `json:"name"`
	Color       string `json:"color,omitempty"`
}

// TagStore manages tags.
type TagStore struct {
	db         *sql.DB
	predefined []string
	freeForm   bool
	maxTags    int
	colors     bool
}

// NewTagStore creates a new TagStore.
func NewTagStore(db *sql.DB) *TagStore {
	return &TagStore{
		db:         db,
		predefined: []string{ {{- range .Tags.Predefined}}"{{.}}", {{end}} },
		freeForm:   {{if .Tags.FreeForm}}true{{else}}false{{end}},
		maxTags:    {{if .Tags.MaxTags}}{{.Tags.MaxTags}}{{else}}10{{end}},
		colors:     {{if .Tags.Colors}}true{{else}}false{{end}},
	}
}

// InitSchema creates the tags table.
func (ts *TagStore) InitSchema() error {
	_, err := ts.db.Exec(`
		CREATE TABLE IF NOT EXISTS tags (
			id TEXT PRIMARY KEY,
			aggregate_id TEXT NOT NULL,
			name TEXT NOT NULL,
			color TEXT,
			UNIQUE(aggregate_id, name)
		);
		CREATE INDEX IF NOT EXISTS idx_tags_aggregate ON tags(aggregate_id);
		CREATE INDEX IF NOT EXISTS idx_tags_name ON tags(name);
	`)
	return err
}

// Add adds a tag to an aggregate.
func (ts *TagStore) Add(aggregateID, name, color string) (*Tag, error) {
	// Check if tag is allowed
	if !ts.freeForm && len(ts.predefined) > 0 {
		allowed := false
		for _, p := range ts.predefined {
			if p == name {
				allowed = true
				break
			}
		}
		if !allowed {
			return nil, fmt.Errorf("tag '%s' is not in predefined list", name)
		}
	}

	// Check max tags
	var count int
	ts.db.QueryRow(`SELECT COUNT(*) FROM tags WHERE aggregate_id = ?`, aggregateID).Scan(&count)
	if count >= ts.maxTags {
		return nil, fmt.Errorf("maximum of %d tags reached", ts.maxTags)
	}

	id := fmt.Sprintf("tag_%d", time.Now().UnixNano())
	if !ts.colors {
		color = ""
	}

	_, err := ts.db.Exec(`
		INSERT OR IGNORE INTO tags (id, aggregate_id, name, color) VALUES (?, ?, ?, ?)
	`, id, aggregateID, name, color)
	if err != nil {
		return nil, err
	}

	return &Tag{ID: id, AggregateID: aggregateID, Name: name, Color: color}, nil
}

// Remove removes a tag from an aggregate.
func (ts *TagStore) Remove(aggregateID, name string) error {
	_, err := ts.db.Exec(`DELETE FROM tags WHERE aggregate_id = ? AND name = ?`, aggregateID, name)
	return err
}

// List lists tags for an aggregate.
func (ts *TagStore) List(aggregateID string) ([]Tag, error) {
	rows, err := ts.db.Query(`SELECT id, aggregate_id, name, color FROM tags WHERE aggregate_id = ?`, aggregateID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var tags []Tag
	for rows.Next() {
		var t Tag
		var color sql.NullString
		if err := rows.Scan(&t.ID, &t.AggregateID, &t.Name, &color); err != nil {
			continue
		}
		if color.Valid {
			t.Color = color.String
		}
		tags = append(tags, t)
	}
	return tags, nil
}

// HandleAddTag handles adding a tag.
func (ts *TagStore) HandleAddTag(w http.ResponseWriter, r *http.Request) {
	aggregateID := r.PathValue("id")
	var req struct {
		Name  string `json:"name"`
		Color string `json:"color,omitempty"`
	}
	if err := api.DecodeJSON(r, &req); err != nil {
		api.Error(w, http.StatusBadRequest, "INVALID_REQUEST", err.Error())
		return
	}

	tag, err := ts.Add(aggregateID, req.Name, req.Color)
	if err != nil {
		api.Error(w, http.StatusBadRequest, "ADD_FAILED", err.Error())
		return
	}

	api.JSON(w, http.StatusCreated, tag)
}

// HandleRemoveTag handles removing a tag.
func (ts *TagStore) HandleRemoveTag(w http.ResponseWriter, r *http.Request) {
	aggregateID := r.PathValue("id")
	name := r.PathValue("name")

	if err := ts.Remove(aggregateID, name); err != nil {
		api.Error(w, http.StatusInternalServerError, "REMOVE_FAILED", err.Error())
		return
	}

	api.JSON(w, http.StatusOK, map[string]interface{}{"success": true})
}

// HandleListTags handles listing tags.
func (ts *TagStore) HandleListTags(w http.ResponseWriter, r *http.Request) {
	aggregateID := r.PathValue("id")
	tags, err := ts.List(aggregateID)
	if err != nil {
		api.Error(w, http.StatusInternalServerError, "LIST_FAILED", err.Error())
		return
	}

	api.JSON(w, http.StatusOK, map[string]interface{}{
		"tags":       tags,
		"predefined": ts.predefined,
		"freeForm":   ts.freeForm,
	})
}
{{end}}

{{if .HasFavorites}}
// ============================================================================
// FAVORITES
// ============================================================================

// Favorite represents a user's favorite.
type Favorite struct {
	ID          string    `json:"id"`
	UserID      string    `json:"userId"`
	AggregateID string    `json:"aggregateId"`
	CreatedAt   time.Time `json:"createdAt"`
}

// FavoriteStore manages favorites.
type FavoriteStore struct {
	db           *sql.DB
	maxFavorites int
}

// NewFavoriteStore creates a new FavoriteStore.
func NewFavoriteStore(db *sql.DB) *FavoriteStore {
	return &FavoriteStore{db: db, maxFavorites: {{if .Favorites.Max}}{{.Favorites.Max}}{{else}}100{{end}}}
}

// InitSchema creates the favorites table.
func (fs *FavoriteStore) InitSchema() error {
	_, err := fs.db.Exec(`
		CREATE TABLE IF NOT EXISTS favorites (
			id TEXT PRIMARY KEY,
			user_id TEXT NOT NULL,
			aggregate_id TEXT NOT NULL,
			created_at TEXT NOT NULL,
			UNIQUE(user_id, aggregate_id)
		);
		CREATE INDEX IF NOT EXISTS idx_favorites_user ON favorites(user_id);
	`)
	return err
}

// Add adds a favorite.
func (fs *FavoriteStore) Add(userID, aggregateID string) (*Favorite, error) {
	var count int
	fs.db.QueryRow(`SELECT COUNT(*) FROM favorites WHERE user_id = ?`, userID).Scan(&count)
	if count >= fs.maxFavorites {
		return nil, fmt.Errorf("maximum of %d favorites reached", fs.maxFavorites)
	}

	id := fmt.Sprintf("fav_%d", time.Now().UnixNano())
	now := time.Now().UTC()

	_, err := fs.db.Exec(`
		INSERT OR IGNORE INTO favorites (id, user_id, aggregate_id, created_at) VALUES (?, ?, ?, ?)
	`, id, userID, aggregateID, now.Format(time.RFC3339))
	if err != nil {
		return nil, err
	}

	return &Favorite{ID: id, UserID: userID, AggregateID: aggregateID, CreatedAt: now}, nil
}

// Remove removes a favorite.
func (fs *FavoriteStore) Remove(userID, aggregateID string) error {
	_, err := fs.db.Exec(`DELETE FROM favorites WHERE user_id = ? AND aggregate_id = ?`, userID, aggregateID)
	return err
}

// List lists a user's favorites.
func (fs *FavoriteStore) List(userID string) ([]Favorite, error) {
	rows, err := fs.db.Query(`
		SELECT id, user_id, aggregate_id, created_at FROM favorites WHERE user_id = ? ORDER BY created_at DESC
	`, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var favorites []Favorite
	for rows.Next() {
		var f Favorite
		var createdAt string
		if err := rows.Scan(&f.ID, &f.UserID, &f.AggregateID, &createdAt); err != nil {
			continue
		}
		f.CreatedAt, _ = time.Parse(time.RFC3339, createdAt)
		favorites = append(favorites, f)
	}
	return favorites, nil
}

// HandleToggleFavorite handles toggling a favorite.
func (fs *FavoriteStore) HandleToggleFavorite(w http.ResponseWriter, r *http.Request) {
	aggregateID := r.PathValue("id")
	userID := getFavoriteUserID(r)
	if userID == "" {
		api.Error(w, http.StatusUnauthorized, "UNAUTHORIZED", "authentication required")
		return
	}

	// Check if already favorited
	var exists int
	fs.db.QueryRow(`SELECT COUNT(*) FROM favorites WHERE user_id = ? AND aggregate_id = ?`, userID, aggregateID).Scan(&exists)

	if exists > 0 {
		fs.Remove(userID, aggregateID)
		api.JSON(w, http.StatusOK, map[string]interface{}{"favorited": false})
	} else {
		_, err := fs.Add(userID, aggregateID)
		if err != nil {
			api.Error(w, http.StatusBadRequest, "ADD_FAILED", err.Error())
			return
		}
		api.JSON(w, http.StatusOK, map[string]interface{}{"favorited": true})
	}
}

// HandleListFavorites handles listing favorites.
func (fs *FavoriteStore) HandleListFavorites(w http.ResponseWriter, r *http.Request) {
	userID := getFavoriteUserID(r)
	if userID == "" {
		api.Error(w, http.StatusUnauthorized, "UNAUTHORIZED", "authentication required")
		return
	}

	favorites, err := fs.List(userID)
	if err != nil {
		api.Error(w, http.StatusInternalServerError, "LIST_FAILED", err.Error())
		return
	}

	api.JSON(w, http.StatusOK, map[string]interface{}{"favorites": favorites})
}

func getFavoriteUserID(r *http.Request) string {
{{- if $.HasAccessControl}}
	user, ok := r.Context().Value("user").(*User)
	if !ok || user == nil {
		return ""
	}
	return fmt.Sprintf("%d", user.ID)
{{- else}}
	return "anonymous"
{{- end}}
}
{{end}}

{{if .HasActivity}}
// ============================================================================
// ACTIVITY FEED
// ============================================================================

// ActivityItem represents an activity feed item.
type ActivityItem struct {
	ID          string    `json:"id"`
	AggregateID string    `json:"aggregateId"`
	EventType   string    `json:"eventType"`
	UserID      string    `json:"userId,omitempty"`
	UserName    string    `json:"userName,omitempty"`
	Summary     string    `json:"summary"`
	Data        any       `json:"data,omitempty"`
	CreatedAt   time.Time `json:"createdAt"`
}

// ActivityStore manages activity feed.
type ActivityStore struct {
	db       *sql.DB
	maxItems int
}

// NewActivityStore creates a new ActivityStore.
func NewActivityStore(db *sql.DB) *ActivityStore {
	return &ActivityStore{db: db, maxItems: 100}
}

// InitSchema creates the activity table.
func (as *ActivityStore) InitSchema() error {
	_, err := as.db.Exec(`
		CREATE TABLE IF NOT EXISTS activity (
			id TEXT PRIMARY KEY,
			aggregate_id TEXT NOT NULL,
			event_type TEXT NOT NULL,
			user_id TEXT,
			user_name TEXT,
			summary TEXT NOT NULL,
			data TEXT,
			created_at TEXT NOT NULL
		);
		CREATE INDEX IF NOT EXISTS idx_activity_aggregate ON activity(aggregate_id);
		CREATE INDEX IF NOT EXISTS idx_activity_created ON activity(created_at DESC);
	`)
	return err
}

// Record records an activity.
func (as *ActivityStore) Record(aggregateID, eventType, userID, userName, summary string, data any) error {
	id := fmt.Sprintf("activity_%d", time.Now().UnixNano())
	now := time.Now().UTC()

	var dataJSON []byte
	if data != nil {
		dataJSON, _ = json.Marshal(data)
	}

	_, err := as.db.Exec(`
		INSERT INTO activity (id, aggregate_id, event_type, user_id, user_name, summary, data, created_at)
		VALUES (?, ?, ?, ?, ?, ?, ?, ?)
	`, id, aggregateID, eventType, userID, userName, summary, string(dataJSON), now.Format(time.RFC3339))
	return err
}

// List lists activity for an aggregate.
func (as *ActivityStore) List(aggregateID string, limit int) ([]ActivityItem, error) {
	if limit <= 0 || limit > as.maxItems {
		limit = as.maxItems
	}

	rows, err := as.db.Query(`
		SELECT id, aggregate_id, event_type, user_id, user_name, summary, data, created_at
		FROM activity WHERE aggregate_id = ? ORDER BY created_at DESC LIMIT ?
	`, aggregateID, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var items []ActivityItem
	for rows.Next() {
		var item ActivityItem
		var userID, userName, dataStr sql.NullString
		var createdAt string
		if err := rows.Scan(&item.ID, &item.AggregateID, &item.EventType, &userID, &userName, &item.Summary, &dataStr, &createdAt); err != nil {
			continue
		}
		if userID.Valid {
			item.UserID = userID.String
		}
		if userName.Valid {
			item.UserName = userName.String
		}
		if dataStr.Valid {
			json.Unmarshal([]byte(dataStr.String), &item.Data)
		}
		item.CreatedAt, _ = time.Parse(time.RFC3339, createdAt)
		items = append(items, item)
	}
	return items, nil
}

// HandleGetActivity handles getting activity.
func (as *ActivityStore) HandleGetActivity(w http.ResponseWriter, r *http.Request) {
	aggregateID := r.PathValue("id")
	items, err := as.List(aggregateID, as.maxItems)
	if err != nil {
		api.Error(w, http.StatusInternalServerError, "LIST_FAILED", err.Error())
		return
	}

	api.JSON(w, http.StatusOK, map[string]interface{}{"activity": items})
}
{{end}}

{{if .HasExport}}
// ============================================================================
// EXPORT
// ============================================================================

// ExportHandler handles data export.
type ExportHandler struct {
	app     *Application
	formats []string
	maxRows int
}

// NewExportHandler creates a new ExportHandler.
func NewExportHandler(db *sql.DB, app *Application) *ExportHandler {
	_ = db // unused, for future expansion
	return &ExportHandler{app: app, formats: []string{ {{- range .Export.Formats}}"{{.}}", {{end}} }, maxRows: {{if .Export.MaxRows}}{{.Export.MaxRows}}{{else}}10000{{end}}}
}

// HandleExport handles export requests.
func (eh *ExportHandler) HandleExport(w http.ResponseWriter, r *http.Request) {
	format := r.URL.Query().Get("format")
	if format == "" {
		format = "json"
	}

	// Validate format
	allowed := false
	for _, f := range eh.formats {
		if f == format {
			allowed = true
			break
		}
	}
	if !allowed {
		api.Error(w, http.StatusBadRequest, "INVALID_FORMAT", fmt.Sprintf("format must be one of: %v", eh.formats))
		return
	}

	// TODO: Implement actual data export based on format
	switch format {
	case "csv":
		w.Header().Set("Content-Type", "text/csv")
		w.Header().Set("Content-Disposition", "attachment; filename=export.csv")
		writer := csv.NewWriter(w)
		writer.Write([]string{"id", "status", "created_at"})
		writer.Flush()
	case "json":
		w.Header().Set("Content-Type", "application/json")
		w.Header().Set("Content-Disposition", "attachment; filename=export.json")
		json.NewEncoder(w).Encode(map[string]interface{}{"data": []interface{}{}})
	default:
		api.Error(w, http.StatusBadRequest, "UNSUPPORTED_FORMAT", "format not supported")
	}
}
{{end}}

{{if .HasSoftDelete}}
// ============================================================================
// SOFT DELETE
// ============================================================================

// SoftDeleteStore manages soft deletion.
type SoftDeleteStore struct {
	db            *sql.DB
	retentionDays int
}

// NewSoftDeleteStore creates a new SoftDeleteStore.
func NewSoftDeleteStore(db *sql.DB, retentionDays int) *SoftDeleteStore {
	return &SoftDeleteStore{db: db, retentionDays: retentionDays}
}

// InitSchema creates the soft_deletes table.
func (sds *SoftDeleteStore) InitSchema() error {
	_, err := sds.db.Exec(`
		CREATE TABLE IF NOT EXISTS soft_deletes (
			aggregate_id TEXT PRIMARY KEY,
			deleted_by TEXT,
			deleted_at TEXT NOT NULL,
			expires_at TEXT
		);
	`)
	return err
}

// SoftDelete marks an aggregate as deleted.
func (sds *SoftDeleteStore) SoftDelete(aggregateID, deletedBy string) error {
	now := time.Now().UTC()
	var expiresAt *time.Time
	if sds.retentionDays > 0 {
		exp := now.AddDate(0, 0, sds.retentionDays)
		expiresAt = &exp
	}

	var expiresAtStr interface{}
	if expiresAt != nil {
		expiresAtStr = expiresAt.Format(time.RFC3339)
	}

	_, err := sds.db.Exec(`
		INSERT OR REPLACE INTO soft_deletes (aggregate_id, deleted_by, deleted_at, expires_at)
		VALUES (?, ?, ?, ?)
	`, aggregateID, deletedBy, now.Format(time.RFC3339), expiresAtStr)
	return err
}

// Restore restores a soft-deleted aggregate.
func (sds *SoftDeleteStore) Restore(aggregateID string) error {
	_, err := sds.db.Exec(`DELETE FROM soft_deletes WHERE aggregate_id = ?`, aggregateID)
	return err
}

// IsDeleted checks if an aggregate is soft-deleted.
func (sds *SoftDeleteStore) IsDeleted(aggregateID string) bool {
	var count int
	sds.db.QueryRow(`SELECT COUNT(*) FROM soft_deletes WHERE aggregate_id = ?`, aggregateID).Scan(&count)
	return count > 0
}

// HandleSoftDelete handles soft delete requests.
func (sds *SoftDeleteStore) HandleSoftDelete(w http.ResponseWriter, r *http.Request) {
	aggregateID := r.PathValue("id")
	userID := getSoftDeleteUserID(r)

	if err := sds.SoftDelete(aggregateID, userID); err != nil {
		api.Error(w, http.StatusInternalServerError, "DELETE_FAILED", err.Error())
		return
	}

	api.JSON(w, http.StatusOK, map[string]interface{}{"success": true, "deleted": true})
}

// HandleRestore handles restore requests.
func (sds *SoftDeleteStore) HandleRestore(w http.ResponseWriter, r *http.Request) {
	aggregateID := r.PathValue("id")

	if err := sds.Restore(aggregateID); err != nil {
		api.Error(w, http.StatusInternalServerError, "RESTORE_FAILED", err.Error())
		return
	}

	api.JSON(w, http.StatusOK, map[string]interface{}{"success": true, "restored": true})
}

func getSoftDeleteUserID(r *http.Request) string {
{{- if $.HasAccessControl}}
	user, ok := r.Context().Value("user").(*User)
	if !ok || user == nil {
		return ""
	}
	return fmt.Sprintf("%d", user.ID)
{{- else}}
	return "anonymous"
{{- end}}
}
{{end}}

{{if .HasBatch}}
// ============================================================================
// BATCH OPERATIONS
// ============================================================================

// BatchRequest represents a batch operation request.
type BatchRequest struct {
	IDs        []string `json:"ids"`
	Transition string   `json:"transition"`
	Data       any      `json:"data,omitempty"`
}

// BatchResult represents a batch operation result.
type BatchResult struct {
	ID      string `json:"id"`
	Success bool   `json:"success"`
	Error   string `json:"error,omitempty"`
}

// BatchHandler handles batch operations.
type BatchHandler struct {
	app         *Application
	transitions []string
	maxSize     int
}

// NewBatchHandler creates a new BatchHandler.
func NewBatchHandler(db *sql.DB, app *Application) *BatchHandler {
	_ = db // unused, for future expansion
	return &BatchHandler{app: app, transitions: []string{ {{- range .Batch.Transitions}}"{{.}}", {{end}} }, maxSize: {{if .Batch.MaxSize}}{{.Batch.MaxSize}}{{else}}100{{end}}}
}

// InitSchema initializes the batch handler schema (placeholder).
func (bh *BatchHandler) InitSchema() error {
	return nil // No schema needed for batch operations
}

// HandleBatch handles batch operation requests.
func (bh *BatchHandler) HandleBatch(w http.ResponseWriter, r *http.Request) {
	var req BatchRequest
	if err := api.DecodeJSON(r, &req); err != nil {
		api.Error(w, http.StatusBadRequest, "INVALID_REQUEST", err.Error())
		return
	}

	if len(req.IDs) > bh.maxSize {
		api.Error(w, http.StatusBadRequest, "TOO_MANY", fmt.Sprintf("maximum batch size is %d", bh.maxSize))
		return
	}

	// Validate transition
	allowed := false
	for _, t := range bh.transitions {
		if t == req.Transition {
			allowed = true
			break
		}
	}
	if !allowed {
		api.Error(w, http.StatusBadRequest, "INVALID_TRANSITION", "transition not allowed in batch")
		return
	}

	results := make([]BatchResult, len(req.IDs))
	for i, id := range req.IDs {
		_, err := bh.app.Execute(r.Context(), id, req.Transition, req.Data)
		results[i] = BatchResult{ID: id, Success: err == nil}
		if err != nil {
			results[i].Error = err.Error()
		}
	}

	api.JSON(w, http.StatusOK, map[string]interface{}{"results": results})
}
{{end}}

{{if .HasInboundWebhooks}}
// ============================================================================
// INBOUND WEBHOOKS
// ============================================================================

// WebhookHandler handles inbound webhooks.
type WebhookHandler struct {
	app        *Application
	path       string
	secret     string
	transition string
	fieldMap   map[string]string
}

// NewWebhookHandler creates a new WebhookHandler.
func NewWebhookHandler(db *sql.DB, app *Application) *WebhookHandler {
	_ = db // unused, for future expansion
	return &WebhookHandler{app: app, path: "/api/webhooks", secret: "", transition: "", fieldMap: nil}
}

// InitSchema initializes the webhook handler schema (placeholder).
func (wh *WebhookHandler) InitSchema() error {
	return nil // No schema needed for webhook handler
}

// Handle handles an inbound webhook request.
func (wh *WebhookHandler) Handle(w http.ResponseWriter, r *http.Request) {
	// Verify signature if secret is set
	if wh.secret != "" {
		signature := r.Header.Get("X-Signature-256")
		if signature == "" {
			signature = r.Header.Get("X-Hub-Signature-256")
		}
		// TODO: Implement signature verification
		_ = signature
	}

	var payload map[string]interface{}
	if err := json.NewDecoder(r.Body).Decode(&payload); err != nil {
		api.Error(w, http.StatusBadRequest, "INVALID_PAYLOAD", err.Error())
		return
	}

	// Map fields
	data := make(map[string]interface{})
	for targetField, sourcePath := range wh.fieldMap {
		value := getNestedValue(payload, sourcePath)
		if value != nil {
			data[targetField] = value
		}
	}

	// Get aggregate ID from payload or create new
	aggregateID, _ := data["aggregate_id"].(string)
	if aggregateID == "" {
		// Create new aggregate
		var err error
		aggregateID, err = wh.app.Create(r.Context())
		if err != nil {
			api.Error(w, http.StatusInternalServerError, "CREATE_FAILED", err.Error())
			return
		}
	}

	// Execute transition
	_, err := wh.app.Execute(r.Context(), aggregateID, wh.transition, data)
	if err != nil {
		api.Error(w, http.StatusInternalServerError, "TRANSITION_FAILED", err.Error())
		return
	}

	api.JSON(w, http.StatusOK, map[string]interface{}{"success": true, "aggregateId": aggregateID})
}

func getNestedValue(data map[string]interface{}, path string) interface{} {
	parts := strings.Split(path, ".")
	current := interface{}(data)

	for _, part := range parts {
		if m, ok := current.(map[string]interface{}); ok {
			current = m[part]
		} else {
			return nil
		}
	}
	return current
}

func verifyWebhookSignature(payload []byte, signature, secret string) bool {
	mac := hmac.New(sha256.New, []byte(secret))
	mac.Write(payload)
	expected := "sha256=" + hex.EncodeToString(mac.Sum(nil))
	return hmac.Equal([]byte(expected), []byte(signature))
}
{{end}}

{{if .HasTemplates}}
// ============================================================================
// TEMPLATES (PRESETS)
// ============================================================================

// TemplateStore manages instance templates.
type TemplateStore struct {
	templates []InstanceTemplate
}

// InstanceTemplate represents a preset template.
type InstanceTemplate struct {
	ID          string         `json:"id"`
	Name        string         `json:"name"`
	Description string         `json:"description,omitempty"`
	Data        map[string]any `json:"data"`
	Roles       []string       `json:"roles,omitempty"`
	Default     bool           `json:"default"`
}

// NewTemplateStore creates a new TemplateStore.
func NewTemplateStore(db *sql.DB, app *Application) *TemplateStore {
	_, _ = db, app // unused, for future expansion
	return &TemplateStore{templates: nil}
}

// InitSchema initializes the template store schema (placeholder).
func (ts *TemplateStore) InitSchema() error {
	return nil // No schema needed, templates are static
}

// List returns all templates.
func (ts *TemplateStore) List(userRoles []string) []InstanceTemplate {
	var result []InstanceTemplate
	for _, t := range ts.templates {
		if len(t.Roles) == 0 {
			result = append(result, t)
			continue
		}
		for _, role := range userRoles {
			for _, allowed := range t.Roles {
				if role == allowed {
					result = append(result, t)
					break
				}
			}
		}
	}
	return result
}

// Get returns a template by ID.
func (ts *TemplateStore) Get(id string) *InstanceTemplate {
	for _, t := range ts.templates {
		if t.ID == id {
			return &t
		}
	}
	return nil
}

// HandleListTemplates handles listing templates.
func (ts *TemplateStore) HandleListTemplates(w http.ResponseWriter, r *http.Request) {
	roles := getTemplateUserRoles(r)
	templates := ts.List(roles)
	api.JSON(w, http.StatusOK, map[string]interface{}{"templates": templates})
}

// HandleGetTemplate handles getting a template.
func (ts *TemplateStore) HandleGetTemplate(w http.ResponseWriter, r *http.Request) {
	id := r.PathValue("id")
	t := ts.Get(id)
	if t == nil {
		api.Error(w, http.StatusNotFound, "NOT_FOUND", "template not found")
		return
	}
	api.JSON(w, http.StatusOK, t)
}

func getTemplateUserRoles(r *http.Request) []string {
{{- if $.HasAccessControl}}
	user, ok := r.Context().Value("user").(*User)
	if !ok || user == nil {
		return nil
	}
	return user.Roles
{{- else}}
	_ = r
	return nil
{{- end}}
}
{{end}}

{{if .HasIndexes}}
// ============================================================================
// SEARCH / INDEXES
// ============================================================================

// SearchHandler handles search requests.
type SearchHandler struct {
	db *sql.DB
}

// NewSearchHandler creates a new SearchHandler.
func NewSearchHandler(db *sql.DB, app *Application) *SearchHandler {
	_ = app // unused, for future expansion
	return &SearchHandler{db: db}
}

// InitSchema creates search indexes.
func (sh *SearchHandler) InitSchema() error {
	// Create full-text search table if needed
	_, err := sh.db.Exec(`
		CREATE VIRTUAL TABLE IF NOT EXISTS search_index USING fts5(
			aggregate_id,
			content,
			tokenize='porter'
		);
	`)
	return err
}

// Index indexes an aggregate's searchable content.
func (sh *SearchHandler) Index(aggregateID string, content string) error {
	// Remove old index entry
	sh.db.Exec(`DELETE FROM search_index WHERE aggregate_id = ?`, aggregateID)

	// Add new index entry
	_, err := sh.db.Exec(`INSERT INTO search_index (aggregate_id, content) VALUES (?, ?)`, aggregateID, content)
	return err
}

// Search performs a full-text search.
func (sh *SearchHandler) Search(query string, limit int) ([]string, error) {
	if limit <= 0 {
		limit = 50
	}

	rows, err := sh.db.Query(`
		SELECT aggregate_id FROM search_index WHERE content MATCH ? LIMIT ?
	`, query, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var ids []string
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			continue
		}
		ids = append(ids, id)
	}
	return ids, nil
}

// HandleSearch handles search requests.
func (sh *SearchHandler) HandleSearch(w http.ResponseWriter, r *http.Request) {
	query := r.URL.Query().Get("q")
	if query == "" {
		api.Error(w, http.StatusBadRequest, "MISSING_QUERY", "query parameter 'q' is required")
		return
	}

	ids, err := sh.Search(query, 50)
	if err != nil {
		api.Error(w, http.StatusInternalServerError, "SEARCH_FAILED", err.Error())
		return
	}

	api.JSON(w, http.StatusOK, map[string]interface{}{"results": ids, "count": len(ids)})
}
{{end}}

{{if .HasApprovals}}
// ============================================================================
// APPROVALS
// ============================================================================

// ApprovalStore manages approval chains.
type ApprovalStore struct {
	db     *sql.DB
	chains map[string]*ApprovalChainDef
}

// ApprovalChainDef defines an approval chain.
type ApprovalChainDef struct {
	ID            string
	Levels        []ApprovalLevelDef
	EscalateAfter string
	OnReject      string
	OnApprove     string
}

// ApprovalLevelDef defines an approval level.
type ApprovalLevelDef struct {
	Role      string
	Condition string
	Required  int
}

// Approval represents an approval request.
type Approval struct {
	ID          string    `json:"id"`
	ChainID     string    `json:"chainId"`
	AggregateID string    `json:"aggregateId"`
	Level       int       `json:"level"`
	Status      string    `json:"status"` // pending, approved, rejected
	Approvals   int       `json:"approvals"`
	Required    int       `json:"required"`
	CreatedAt   time.Time `json:"createdAt"`
	UpdatedAt   time.Time `json:"updatedAt"`
}

// NewApprovalStore creates a new ApprovalStore.
func NewApprovalStore(db *sql.DB, app *Application) *ApprovalStore {
	_ = app // unused, for future expansion
	return &ApprovalStore{db: db, chains: make(map[string]*ApprovalChainDef)}
}

// InitSchema creates the approvals tables.
func (as *ApprovalStore) InitSchema() error {
	_, err := as.db.Exec(`
		CREATE TABLE IF NOT EXISTS approvals (
			id TEXT PRIMARY KEY,
			chain_id TEXT NOT NULL,
			aggregate_id TEXT NOT NULL,
			level INTEGER NOT NULL,
			status TEXT NOT NULL DEFAULT 'pending',
			approvals INTEGER NOT NULL DEFAULT 0,
			required INTEGER NOT NULL,
			created_at TEXT NOT NULL,
			updated_at TEXT NOT NULL
		);
		CREATE TABLE IF NOT EXISTS approval_votes (
			id TEXT PRIMARY KEY,
			approval_id TEXT NOT NULL,
			user_id TEXT NOT NULL,
			vote TEXT NOT NULL,
			created_at TEXT NOT NULL,
			UNIQUE(approval_id, user_id)
		);
		CREATE INDEX IF NOT EXISTS idx_approvals_aggregate ON approvals(aggregate_id);
	`)
	return err
}

// Request creates a new approval request.
func (as *ApprovalStore) Request(chainID, aggregateID string) (*Approval, error) {
	chain, ok := as.chains[chainID]
	if !ok {
		return nil, fmt.Errorf("unknown approval chain: %s", chainID)
	}

	if len(chain.Levels) == 0 {
		return nil, fmt.Errorf("approval chain has no levels")
	}

	id := fmt.Sprintf("approval_%d", time.Now().UnixNano())
	now := time.Now().UTC()
	required := chain.Levels[0].Required
	if required == 0 {
		required = 1
	}

	_, err := as.db.Exec(`
		INSERT INTO approvals (id, chain_id, aggregate_id, level, status, approvals, required, created_at, updated_at)
		VALUES (?, ?, ?, 1, 'pending', 0, ?, ?, ?)
	`, id, chainID, aggregateID, required, now.Format(time.RFC3339), now.Format(time.RFC3339))
	if err != nil {
		return nil, err
	}

	return &Approval{
		ID:          id,
		ChainID:     chainID,
		AggregateID: aggregateID,
		Level:       1,
		Status:      "pending",
		Approvals:   0,
		Required:    required,
		CreatedAt:   now,
		UpdatedAt:   now,
	}, nil
}

// Vote records an approval vote.
func (as *ApprovalStore) Vote(approvalID, userID, vote string) error {
	voteID := fmt.Sprintf("vote_%d", time.Now().UnixNano())
	now := time.Now().UTC()

	_, err := as.db.Exec(`
		INSERT OR REPLACE INTO approval_votes (id, approval_id, user_id, vote, created_at)
		VALUES (?, ?, ?, ?, ?)
	`, voteID, approvalID, userID, vote, now.Format(time.RFC3339))
	if err != nil {
		return err
	}

	// Update approval count
	if vote == "approve" {
		as.db.Exec(`UPDATE approvals SET approvals = approvals + 1, updated_at = ? WHERE id = ?`,
			now.Format(time.RFC3339), approvalID)
	}

	return nil
}

// HandleVote handles approval vote requests.
func (as *ApprovalStore) HandleVote(w http.ResponseWriter, r *http.Request) {
	approvalID := r.PathValue("id")
	userID := getApprovalUserID(r)
	if userID == "" {
		api.Error(w, http.StatusUnauthorized, "UNAUTHORIZED", "authentication required")
		return
	}

	var req struct {
		Vote string `json:"vote"` // approve, reject
	}
	if err := api.DecodeJSON(r, &req); err != nil {
		api.Error(w, http.StatusBadRequest, "INVALID_REQUEST", err.Error())
		return
	}

	if req.Vote != "approve" && req.Vote != "reject" {
		api.Error(w, http.StatusBadRequest, "INVALID_VOTE", "vote must be 'approve' or 'reject'")
		return
	}

	if err := as.Vote(approvalID, userID, req.Vote); err != nil {
		api.Error(w, http.StatusInternalServerError, "VOTE_FAILED", err.Error())
		return
	}

	api.JSON(w, http.StatusOK, map[string]interface{}{"success": true})
}

func getApprovalUserID(r *http.Request) string {
{{- if $.HasAccessControl}}
	user, ok := r.Context().Value("user").(*User)
	if !ok || user == nil {
		return ""
	}
	return fmt.Sprintf("%d", user.ID)
{{- else}}
	return "anonymous"
{{- end}}
}
{{end}}

{{if .HasComputed}}
// ============================================================================
// COMPUTED FIELDS
// ============================================================================

// ComputedFieldEvaluator evaluates computed fields.
type ComputedFieldEvaluator struct {
	fields []ComputedFieldDef
}

// ComputedFieldDef defines a computed field.
type ComputedFieldDef struct {
	Name      string
	Expr      string
	DependsOn []string
}

// NewComputedFieldEvaluator creates a new ComputedFieldEvaluator.
func NewComputedFieldEvaluator(fields []ComputedFieldDef) *ComputedFieldEvaluator {
	return &ComputedFieldEvaluator{fields: fields}
}

// Evaluate evaluates all computed fields for a state.
func (cfe *ComputedFieldEvaluator) Evaluate(state map[string]interface{}) map[string]interface{} {
	result := make(map[string]interface{})
	for _, field := range cfe.fields {
		// TODO: Implement expression evaluation
		// For now, just return the expression as a placeholder
		result[field.Name] = field.Expr
	}
	return result
}
{{end}}

{{if .HasRelationships}}
// ============================================================================
// RELATIONSHIPS
// ============================================================================

// RelationshipStore manages relationships between aggregates.
type RelationshipStore struct {
	db *sql.DB
}

// Relationship represents a relationship between aggregates.
type RelationshipLink struct {
	ID        string    `json:"id"`
	FromID    string    `json:"fromId"`
	ToID      string    `json:"toId"`
	Type      string    `json:"type"` // hasMany, hasOne, belongsTo
	Name      string    `json:"name"`
	CreatedAt time.Time `json:"createdAt"`
}

// NewRelationshipStore creates a new RelationshipStore.
func NewRelationshipStore(db *sql.DB) *RelationshipStore {
	return &RelationshipStore{db: db}
}

// InitSchema creates the relationships table.
func (rs *RelationshipStore) InitSchema() error {
	_, err := rs.db.Exec(`
		CREATE TABLE IF NOT EXISTS relationships (
			id TEXT PRIMARY KEY,
			from_id TEXT NOT NULL,
			to_id TEXT NOT NULL,
			type TEXT NOT NULL,
			name TEXT NOT NULL,
			created_at TEXT NOT NULL,
			UNIQUE(from_id, to_id, name)
		);
		CREATE INDEX IF NOT EXISTS idx_relationships_from ON relationships(from_id);
		CREATE INDEX IF NOT EXISTS idx_relationships_to ON relationships(to_id);
	`)
	return err
}

// Link creates a relationship.
func (rs *RelationshipStore) Link(fromID, toID, relType, name string) (*RelationshipLink, error) {
	id := fmt.Sprintf("rel_%d", time.Now().UnixNano())
	now := time.Now().UTC()

	_, err := rs.db.Exec(`
		INSERT OR REPLACE INTO relationships (id, from_id, to_id, type, name, created_at)
		VALUES (?, ?, ?, ?, ?, ?)
	`, id, fromID, toID, relType, name, now.Format(time.RFC3339))
	if err != nil {
		return nil, err
	}

	return &RelationshipLink{
		ID:        id,
		FromID:    fromID,
		ToID:      toID,
		Type:      relType,
		Name:      name,
		CreatedAt: now,
	}, nil
}

// Unlink removes a relationship.
func (rs *RelationshipStore) Unlink(fromID, toID, name string) error {
	_, err := rs.db.Exec(`DELETE FROM relationships WHERE from_id = ? AND to_id = ? AND name = ?`,
		fromID, toID, name)
	return err
}

// GetRelated gets related aggregates.
func (rs *RelationshipStore) GetRelated(aggregateID, name string) ([]string, error) {
	rows, err := rs.db.Query(`
		SELECT to_id FROM relationships WHERE from_id = ? AND name = ?
	`, aggregateID, name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var ids []string
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			continue
		}
		ids = append(ids, id)
	}
	return ids, nil
}

// HandleGetRelated handles getting related aggregates.
func (rs *RelationshipStore) HandleGetRelated(w http.ResponseWriter, r *http.Request) {
	aggregateID := r.PathValue("id")
	name := r.PathValue("name")

	ids, err := rs.GetRelated(aggregateID, name)
	if err != nil {
		api.Error(w, http.StatusInternalServerError, "QUERY_FAILED", err.Error())
		return
	}

	api.JSON(w, http.StatusOK, map[string]interface{}{"related": ids})
}

// HandleLink handles linking aggregates.
func (rs *RelationshipStore) HandleLink(w http.ResponseWriter, r *http.Request) {
	fromID := r.PathValue("id")
	name := r.PathValue("name")

	var req struct {
		ToID string `json:"toId"`
	}
	if err := api.DecodeJSON(r, &req); err != nil {
		api.Error(w, http.StatusBadRequest, "INVALID_REQUEST", err.Error())
		return
	}

	link, err := rs.Link(fromID, req.ToID, "hasMany", name)
	if err != nil {
		api.Error(w, http.StatusInternalServerError, "LINK_FAILED", err.Error())
		return
	}

	api.JSON(w, http.StatusCreated, link)
}
{{end}}

{{if .HasDocuments}}
// ============================================================================
// DOCUMENTS
// ============================================================================

// DocumentGenerator generates documents from templates.
type DocumentGenerator struct {
	documents []DocumentDef
}

// DocumentDef defines a document template.
type DocumentDef struct {
	ID       string
	Name     string
	Template string
	Format   string
}

// NewDocumentGenerator creates a new DocumentGenerator.
func NewDocumentGenerator(app *Application) *DocumentGenerator {
	_ = app // unused, for future expansion
	return &DocumentGenerator{documents: nil}
}

// Generate generates a document.
func (dg *DocumentGenerator) Generate(docID string, data map[string]interface{}) ([]byte, string, error) {
	var doc *DocumentDef
	for _, d := range dg.documents {
		if d.ID == docID {
			doc = &d
			break
		}
	}
	if doc == nil {
		return nil, "", fmt.Errorf("unknown document: %s", docID)
	}

	// TODO: Implement actual document generation
	// For now, return JSON representation
	content, _ := json.MarshalIndent(data, "", "  ")
	return content, "application/json", nil
}

// HandleGenerate handles document generation requests.
func (dg *DocumentGenerator) HandleGenerate(w http.ResponseWriter, r *http.Request) {
	docID := r.PathValue("docId")

	var data map[string]interface{}
	if err := api.DecodeJSON(r, &data); err != nil {
		api.Error(w, http.StatusBadRequest, "INVALID_REQUEST", err.Error())
		return
	}

	content, contentType, err := dg.Generate(docID, data)
	if err != nil {
		api.Error(w, http.StatusBadRequest, "GENERATE_FAILED", err.Error())
		return
	}

	w.Header().Set("Content-Type", contentType)
	w.Write(content)
}

// HandleListDocuments handles listing available documents.
func (dg *DocumentGenerator) HandleListDocuments(w http.ResponseWriter, r *http.Request) {
	docs := make([]map[string]string, len(dg.documents))
	for i, d := range dg.documents {
		docs[i] = map[string]string{
			"id":     d.ID,
			"name":   d.Name,
			"format": d.Format,
		}
	}
	api.JSON(w, http.StatusOK, map[string]interface{}{"documents": docs})
}
{{end}}
