// Code generated by petri-pilot. DO NOT EDIT.

package main

import (
	"bytes"
	"context"
	"crypto/hmac"
	"crypto/sha256"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"time"
)

{{if .HasWebhooks}}
// WebhookConfig defines a webhook endpoint configuration.
type WebhookConfig struct {
	ID          string
	URL         string
	Events      []string
	Secret      string
	Enabled     bool
	MaxAttempts int
	BackoffMs   int
}

// WebhookRegistry manages webhook configurations and delivery.
type WebhookRegistry struct {
	webhooks map[string]*WebhookConfig
	client   *http.Client
}

// NewWebhookRegistry creates a new webhook registry.
func NewWebhookRegistry() *WebhookRegistry {
	registry := &WebhookRegistry{
		webhooks: make(map[string]*WebhookConfig),
		client: &http.Client{
			Timeout: 30 * time.Second,
		},
	}

	// Register webhooks
	{{range .Webhooks}}
	registry.webhooks["{{.ID}}"] = &WebhookConfig{
		ID:          "{{.ID}}",
		URL:         "{{.URL}}",
		Events:      []string{ {{range $i, $event := .Events}}{{if $i}}, {{end}}"{{$event}}"{{end}} },
		Secret:      "{{.Secret}}",
		Enabled:     {{.Enabled}},
		MaxAttempts: {{if .RetryPolicy}}{{.RetryPolicy.MaxAttempts}}{{else}}3{{end}},
		BackoffMs:   {{if .RetryPolicy}}{{.RetryPolicy.BackoffMs}}{{else}}1000{{end}},
	}
	{{end}}

	return registry
}

// OnEvent handles event notifications and triggers matching webhooks.
func (r *WebhookRegistry) OnEvent(ctx context.Context, eventType string, payload map[string]any) error {
	for _, webhook := range r.webhooks {
		if !webhook.Enabled {
			continue
		}

		// Check if this webhook is subscribed to this event
		if !r.isSubscribed(webhook, eventType) {
			continue
		}

		// Deliver webhook asynchronously
		go func(wh *WebhookConfig) {
			if err := r.deliverWithRetry(ctx, wh, eventType, payload); err != nil {
				log.Printf("Failed to deliver webhook %s: %v", wh.ID, err)
			}
		}(webhook)
	}

	return nil
}

// isSubscribed checks if a webhook is subscribed to an event type.
func (r *WebhookRegistry) isSubscribed(webhook *WebhookConfig, eventType string) bool {
	for _, subscribedEvent := range webhook.Events {
		if subscribedEvent == eventType || subscribedEvent == "*" {
			return true
		}
	}
	return false
}

// deliverWithRetry attempts to deliver a webhook with exponential backoff retry.
func (r *WebhookRegistry) deliverWithRetry(ctx context.Context, webhook *WebhookConfig, eventType string, payload map[string]any) error {
	var lastErr error

	for attempt := 1; attempt <= webhook.MaxAttempts; attempt++ {
		err := r.deliver(ctx, webhook, eventType, payload)
		if err == nil {
			log.Printf("Webhook %s delivered successfully on attempt %d", webhook.ID, attempt)
			return nil
		}

		lastErr = err
		log.Printf("Webhook %s delivery attempt %d failed: %v", webhook.ID, attempt, err)

		if attempt < webhook.MaxAttempts {
			// Exponential backoff
			backoff := time.Duration(webhook.BackoffMs*(1<<(attempt-1))) * time.Millisecond
			time.Sleep(backoff)
		}
	}

	return fmt.Errorf("webhook delivery failed after %d attempts: %w", webhook.MaxAttempts, lastErr)
}

// deliver sends a single webhook request.
func (r *WebhookRegistry) deliver(ctx context.Context, webhook *WebhookConfig, eventType string, payload map[string]any) error {
	// Build webhook payload
	webhookPayload := map[string]any{
		"event":     eventType,
		"timestamp": time.Now().Unix(),
		"data":      payload,
	}

	// Serialize payload
	body, err := json.Marshal(webhookPayload)
	if err != nil {
		return fmt.Errorf("failed to marshal payload: %w", err)
	}

	// Create HTTP request
	req, err := http.NewRequestWithContext(ctx, "POST", webhook.URL, bytes.NewReader(body))
	if err != nil {
		return fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("User-Agent", "petri-pilot-webhook/1.0")
	req.Header.Set("X-Webhook-ID", webhook.ID)
	req.Header.Set("X-Event-Type", eventType)

	// Sign request with HMAC-SHA256
	if webhook.Secret != "" {
		signature := r.signPayload(body, webhook.Secret)
		req.Header.Set("X-Webhook-Signature", signature)
	}

	// Send request
	resp, err := r.client.Do(req)
	if err != nil {
		return fmt.Errorf("failed to send request: %w", err)
	}
	defer resp.Body.Close()

	// Check response status
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return fmt.Errorf("webhook returned status %d", resp.StatusCode)
	}

	return nil
}

// signPayload generates an HMAC-SHA256 signature for the payload.
func (r *WebhookRegistry) signPayload(payload []byte, secret string) string {
	mac := hmac.New(sha256.New, []byte(secret))
	mac.Write(payload)
	return hex.EncodeToString(mac.Sum(nil))
}

// VerifyWebhookSignature verifies an incoming webhook signature.
// This can be used by webhook receivers to verify authenticity.
func VerifyWebhookSignature(payload []byte, signature string, secret string) bool {
	mac := hmac.New(sha256.New, []byte(secret))
	mac.Write(payload)
	expectedSignature := hex.EncodeToString(mac.Sum(nil))
	return hmac.Equal([]byte(signature), []byte(expectedSignature))
}
{{end}}
