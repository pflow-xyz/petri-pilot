// Code generated by petri-pilot. DO NOT EDIT.

package main

import (
	"context"
	"fmt"
	"net/http"
	"strings"

	"github.com/pflow-xyz/petri-pilot/pkg/dsl"
)

// Middleware provides access control for transitions.
type Middleware struct {
	sessions SessionStore
	rules    map[string]*AccessControl // transition ID -> access control
}

// AccessControl defines who can execute a transition.
type AccessControl struct {
	TransitionID string
	Roles        []string // Allowed roles (empty = any authenticated user)
	Guard        string   // Optional guard expression
}

// NewMiddleware creates a new middleware instance.
func NewMiddleware(sessions SessionStore, rules []*AccessControl) *Middleware {
	ruleMap := make(map[string]*AccessControl)
	for _, rule := range rules {
		ruleMap[rule.TransitionID] = rule
	}
	return &Middleware{
		sessions: sessions,
		rules:    ruleMap,
	}
}

// RequireAuth enforces authentication (any valid user).
func (m *Middleware) RequireAuth(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		user := UserFromContext(r.Context())
		if user == nil {
			http.Error(w, "unauthorized", http.StatusUnauthorized)
			return
		}
		next.ServeHTTP(w, r)
	})
}

// RequireRole enforces role-based access control.
// Accepts a list of allowed roles. User must have at least one.
func (m *Middleware) RequireRole(roles ...string) func(http.Handler) http.Handler {
	return func(next http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			user := UserFromContext(r.Context())
			if user == nil {
				http.Error(w, "unauthorized", http.StatusUnauthorized)
				return
			}

			// Extract user roles from context or user object
			userRoles := m.getUserRoles(user)
			
			// Check if user has any of the required roles
			if !m.hasAnyRole(userRoles, roles) {
				http.Error(w, "forbidden: insufficient permissions", http.StatusForbidden)
				return
			}

			next.ServeHTTP(w, r)
		})
	}
}

// RequirePermission enforces transition-level permission with optional guard evaluation.
func (m *Middleware) RequirePermission(transitionID string) func(http.Handler) http.Handler {
	return func(next http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			user := UserFromContext(r.Context())
			if user == nil {
				http.Error(w, "unauthorized", http.StatusUnauthorized)
				return
			}

			// Get access control rules for this transition
			rule, exists := m.rules[transitionID]
			if !exists {
				// No specific rule, allow any authenticated user
				next.ServeHTTP(w, r)
				return
			}

			// Check role requirements
			if len(rule.Roles) > 0 {
				userRoles := m.getUserRoles(user)
				if !m.hasAnyRole(userRoles, rule.Roles) {
					http.Error(w, fmt.Sprintf("forbidden: action '%s' requires role: %s", transitionID, strings.Join(rule.Roles, " or ")), http.StatusForbidden)
					return
				}
			}

			// Evaluate guard expression if present
			if rule.Guard != "" {
				// Build bindings for guard evaluation
				bindings := m.buildGuardBindings(user, r)
				
				allowed, err := dsl.Evaluate(rule.Guard, bindings, nil)
				if err != nil {
					http.Error(w, fmt.Sprintf("error evaluating access guard: %v", err), http.StatusInternalServerError)
					return
				}
				
				if !allowed {
					http.Error(w, fmt.Sprintf("forbidden: access guard failed for '%s'", transitionID), http.StatusForbidden)
					return
				}
			}

			next.ServeHTTP(w, r)
		})
	}
}

// getUserRoles extracts roles from a user.
// In a real implementation, this would query a role store.
// For now, we check if user login contains role indicators.
func (m *Middleware) getUserRoles(user *User) []string {
	// TODO: Implement proper role extraction from user claims/database
	// This is a placeholder implementation
	roles := []string{"user"}
	
	// Example: extract from user metadata
	// if user.Roles != nil {
	//     return user.Roles
	// }
	
	// Simple heuristic for demo: check login name
	login := strings.ToLower(user.Login)
	if strings.Contains(login, "admin") {
		roles = append(roles, "admin")
	}
	if strings.Contains(login, "customer") {
		roles = append(roles, "customer")
	}
	
	return roles
}

// hasAnyRole checks if user has at least one of the required roles.
func (m *Middleware) hasAnyRole(userRoles []string, requiredRoles []string) bool {
	if len(requiredRoles) == 0 {
		return true // No role requirement
	}
	
	for _, required := range requiredRoles {
		for _, userRole := range userRoles {
			if userRole == required {
				return true
			}
		}
	}
	return false
}

// buildGuardBindings creates bindings for guard expression evaluation.
func (m *Middleware) buildGuardBindings(user *User, r *http.Request) map[string]any {
	bindings := make(map[string]any)
	
	// Add user info to bindings
	bindings["user"] = map[string]any{
		"id":    user.ID,
		"login": user.Login,
		"email": user.Email,
	}
	
	// TODO: Add request parameters, aggregate state, etc.
	// bindings["request"] = extractRequestParams(r)
	// bindings["state"] = getCurrentState(r)
	
	return bindings
}

// EvaluateGuard evaluates a guard expression with the given bindings.
// This is a helper function for custom guard evaluation.
func EvaluateGuard(guard string, bindings map[string]any) (bool, error) {
	if guard == "" {
		return true, nil
	}
	return dsl.Evaluate(guard, bindings, nil)
}
