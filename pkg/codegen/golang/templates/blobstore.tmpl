// Code generated by petri-pilot. DO NOT EDIT.

package {{.PackageName}}

import (
	"crypto/rand"
	"database/sql"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"strings"
	"time"

	"github.com/pflow-xyz/petri-pilot/pkg/runtime/api"
)

// Blob represents a stored blob with metadata.
type Blob struct {
	ID          string            `json:"id"`
	OwnerID     string            `json:"ownerId"`
	ContentType string            `json:"contentType"`
	Size        int64             `json:"size"`
	Data        []byte            `json:"-"`
	CreatedAt   time.Time         `json:"createdAt"`
	UpdatedAt   time.Time         `json:"updatedAt"`
	Metadata    map[string]string `json:"metadata,omitempty"`
}

// BlobStore manages blob storage in SQLite.
type BlobStore struct {
	db           *sql.DB
	maxSize      int64
	allowedTypes []string
}

// NewBlobStore creates a new BlobStore instance.
func NewBlobStore(db *sql.DB, maxSize int64, allowedTypes []string) *BlobStore {
	return &BlobStore{
		db:           db,
		maxSize:      maxSize,
		allowedTypes: allowedTypes,
	}
}

// InitSchema creates the blobs table if it doesn't exist.
func (bs *BlobStore) InitSchema() error {
	_, err := bs.db.Exec(`
		CREATE TABLE IF NOT EXISTS blobs (
			id TEXT PRIMARY KEY,
			owner_id TEXT NOT NULL,
			content_type TEXT NOT NULL,
			size INTEGER NOT NULL,
			data BLOB NOT NULL,
			created_at TEXT NOT NULL,
			updated_at TEXT NOT NULL,
			metadata TEXT
		);
		CREATE INDEX IF NOT EXISTS idx_blobs_owner ON blobs(owner_id);
		CREATE INDEX IF NOT EXISTS idx_blobs_created_at ON blobs(created_at);
	`)
	return err
}

// generateBlobID creates a unique blob ID.
func generateBlobID() string {
	b := make([]byte, 16)
	rand.Read(b)
	return "blob_" + hex.EncodeToString(b)
}

// isTypeAllowed checks if a content type is allowed.
func (bs *BlobStore) isTypeAllowed(contentType string) bool {
	for _, allowed := range bs.allowedTypes {
		if allowed == "*/*" {
			return true
		}
		if allowed == contentType {
			return true
		}
		// Handle wildcard patterns like "image/*"
		if strings.HasSuffix(allowed, "/*") {
			prefix := strings.TrimSuffix(allowed, "/*")
			if strings.HasPrefix(contentType, prefix+"/") {
				return true
			}
		}
	}
	return false
}

// Upload stores a new blob and returns its metadata.
func (bs *BlobStore) Upload(ownerID, contentType string, data []byte, metadata map[string]string) (*Blob, error) {
	if int64(len(data)) > bs.maxSize {
		return nil, fmt.Errorf("blob size %d exceeds maximum allowed size %d", len(data), bs.maxSize)
	}

	if !bs.isTypeAllowed(contentType) {
		return nil, fmt.Errorf("content type %s is not allowed", contentType)
	}

	id := generateBlobID()
	now := time.Now().UTC()

	var metadataJSON []byte
	if metadata != nil {
		var err error
		metadataJSON, err = json.Marshal(metadata)
		if err != nil {
			return nil, fmt.Errorf("marshaling metadata: %w", err)
		}
	}

	_, err := bs.db.Exec(`
		INSERT INTO blobs (id, owner_id, content_type, size, data, created_at, updated_at, metadata)
		VALUES (?, ?, ?, ?, ?, ?, ?, ?)
	`, id, ownerID, contentType, len(data), data, now.Format(time.RFC3339), now.Format(time.RFC3339), metadataJSON)
	if err != nil {
		return nil, fmt.Errorf("inserting blob: %w", err)
	}

	return &Blob{
		ID:          id,
		OwnerID:     ownerID,
		ContentType: contentType,
		Size:        int64(len(data)),
		CreatedAt:   now,
		UpdatedAt:   now,
		Metadata:    metadata,
	}, nil
}

// Get retrieves a blob by ID including its data.
func (bs *BlobStore) Get(id string) (*Blob, error) {
	var blob Blob
	var createdAt, updatedAt string
	var metadataJSON sql.NullString

	err := bs.db.QueryRow(`
		SELECT id, owner_id, content_type, size, data, created_at, updated_at, metadata
		FROM blobs WHERE id = ?
	`, id).Scan(&blob.ID, &blob.OwnerID, &blob.ContentType, &blob.Size, &blob.Data, &createdAt, &updatedAt, &metadataJSON)
	if err == sql.ErrNoRows {
		return nil, fmt.Errorf("blob not found: %s", id)
	}
	if err != nil {
		return nil, fmt.Errorf("querying blob: %w", err)
	}

	blob.CreatedAt, _ = time.Parse(time.RFC3339, createdAt)
	blob.UpdatedAt, _ = time.Parse(time.RFC3339, updatedAt)

	if metadataJSON.Valid {
		json.Unmarshal([]byte(metadataJSON.String), &blob.Metadata)
	}

	return &blob, nil
}

// GetMeta retrieves blob metadata without the data.
func (bs *BlobStore) GetMeta(id string) (*Blob, error) {
	var blob Blob
	var createdAt, updatedAt string
	var metadataJSON sql.NullString

	err := bs.db.QueryRow(`
		SELECT id, owner_id, content_type, size, created_at, updated_at, metadata
		FROM blobs WHERE id = ?
	`, id).Scan(&blob.ID, &blob.OwnerID, &blob.ContentType, &blob.Size, &createdAt, &updatedAt, &metadataJSON)
	if err == sql.ErrNoRows {
		return nil, fmt.Errorf("blob not found: %s", id)
	}
	if err != nil {
		return nil, fmt.Errorf("querying blob: %w", err)
	}

	blob.CreatedAt, _ = time.Parse(time.RFC3339, createdAt)
	blob.UpdatedAt, _ = time.Parse(time.RFC3339, updatedAt)

	if metadataJSON.Valid {
		json.Unmarshal([]byte(metadataJSON.String), &blob.Metadata)
	}

	return &blob, nil
}

// ListByOwner returns all blobs owned by a user.
func (bs *BlobStore) ListByOwner(ownerID string) ([]*Blob, error) {
	rows, err := bs.db.Query(`
		SELECT id, owner_id, content_type, size, created_at, updated_at, metadata
		FROM blobs WHERE owner_id = ?
		ORDER BY created_at DESC
	`, ownerID)
	if err != nil {
		return nil, fmt.Errorf("querying blobs: %w", err)
	}
	defer rows.Close()

	var blobs []*Blob
	for rows.Next() {
		var blob Blob
		var createdAt, updatedAt string
		var metadataJSON sql.NullString

		if err := rows.Scan(&blob.ID, &blob.OwnerID, &blob.ContentType, &blob.Size, &createdAt, &updatedAt, &metadataJSON); err != nil {
			return nil, fmt.Errorf("scanning blob: %w", err)
		}

		blob.CreatedAt, _ = time.Parse(time.RFC3339, createdAt)
		blob.UpdatedAt, _ = time.Parse(time.RFC3339, updatedAt)

		if metadataJSON.Valid {
			json.Unmarshal([]byte(metadataJSON.String), &blob.Metadata)
		}

		blobs = append(blobs, &blob)
	}

	return blobs, nil
}

// TransferOwnership transfers blob ownership to a new user.
func (bs *BlobStore) TransferOwnership(id, currentOwnerID, newOwnerID string, isAdmin bool) error {
	// Get current blob to verify ownership
	blob, err := bs.GetMeta(id)
	if err != nil {
		return err
	}

	if !isAdmin && blob.OwnerID != currentOwnerID {
		return fmt.Errorf("not authorized to transfer this blob")
	}

	now := time.Now().UTC()
	_, err = bs.db.Exec(`
		UPDATE blobs SET owner_id = ?, updated_at = ? WHERE id = ?
	`, newOwnerID, now.Format(time.RFC3339), id)
	if err != nil {
		return fmt.Errorf("updating blob ownership: %w", err)
	}

	return nil
}

// Delete removes a blob.
func (bs *BlobStore) Delete(id, userID string, isAdmin bool) error {
	// Get current blob to verify ownership
	blob, err := bs.GetMeta(id)
	if err != nil {
		return err
	}

	if !isAdmin && blob.OwnerID != userID {
		return fmt.Errorf("not authorized to delete this blob")
	}

	_, err = bs.db.Exec(`DELETE FROM blobs WHERE id = ?`, id)
	if err != nil {
		return fmt.Errorf("deleting blob: %w", err)
	}

	return nil
}

// ValidateRefs checks that all blob IDs exist.
func (bs *BlobStore) ValidateRefs(ids []string) error {
	if len(ids) == 0 {
		return nil
	}

	// Build placeholders for IN clause
	placeholders := make([]string, len(ids))
	args := make([]interface{}, len(ids))
	for i, id := range ids {
		placeholders[i] = "?"
		args[i] = id
	}

	var count int
	err := bs.db.QueryRow(fmt.Sprintf(`
		SELECT COUNT(*) FROM blobs WHERE id IN (%s)
	`, strings.Join(placeholders, ",")), args...).Scan(&count)
	if err != nil {
		return fmt.Errorf("validating blob refs: %w", err)
	}

	if count != len(ids) {
		return fmt.Errorf("some blob references are invalid")
	}

	return nil
}

// HTTP Handlers

// HandleBlobUpload handles blob upload requests.
func (bs *BlobStore) HandleUpload(w http.ResponseWriter, r *http.Request) {
	// Get user ID from context
	userID := getBlobUserID(r)
	if userID == "" {
		api.Error(w, http.StatusUnauthorized, "UNAUTHORIZED", "authentication required")
		return
	}

	// Read body with size limit
	body, err := io.ReadAll(io.LimitReader(r.Body, bs.maxSize+1))
	if err != nil {
		api.Error(w, http.StatusBadRequest, "READ_ERROR", "failed to read request body")
		return
	}

	if int64(len(body)) > bs.maxSize {
		api.Error(w, http.StatusRequestEntityTooLarge, "TOO_LARGE", fmt.Sprintf("blob exceeds maximum size of %d bytes", bs.maxSize))
		return
	}

	contentType := r.Header.Get("Content-Type")
	if contentType == "" {
		contentType = "application/octet-stream"
	}

	// Extract metadata from headers
	var metadata map[string]string
	for key, values := range r.Header {
		if strings.HasPrefix(strings.ToLower(key), "x-blob-") {
			if metadata == nil {
				metadata = make(map[string]string)
			}
			metaKey := strings.TrimPrefix(strings.ToLower(key), "x-blob-")
			metadata[metaKey] = values[0]
		}
	}

	blob, err := bs.Upload(userID, contentType, body, metadata)
	if err != nil {
		api.Error(w, http.StatusBadRequest, "UPLOAD_FAILED", err.Error())
		return
	}

	api.JSON(w, http.StatusCreated, blob)
}

// HandleBlobGet handles blob retrieval requests.
func (bs *BlobStore) HandleGet(w http.ResponseWriter, r *http.Request) {
	id := r.PathValue("id")
	if id == "" {
		api.Error(w, http.StatusBadRequest, "MISSING_ID", "blob ID is required")
		return
	}

	blob, err := bs.Get(id)
	if err != nil {
		api.Error(w, http.StatusNotFound, "NOT_FOUND", err.Error())
		return
	}

	w.Header().Set("Content-Type", blob.ContentType)
	w.Header().Set("Content-Length", fmt.Sprintf("%d", blob.Size))
	w.Header().Set("X-Blob-Owner", blob.OwnerID)
	w.WriteHeader(http.StatusOK)
	w.Write(blob.Data)
}

// HandleBlobGetMeta handles blob metadata requests.
func (bs *BlobStore) HandleGetMeta(w http.ResponseWriter, r *http.Request) {
	id := r.PathValue("id")
	if id == "" {
		api.Error(w, http.StatusBadRequest, "MISSING_ID", "blob ID is required")
		return
	}

	blob, err := bs.GetMeta(id)
	if err != nil {
		api.Error(w, http.StatusNotFound, "NOT_FOUND", err.Error())
		return
	}

	api.JSON(w, http.StatusOK, blob)
}

// HandleBlobList handles blob listing requests.
func (bs *BlobStore) HandleList(w http.ResponseWriter, r *http.Request) {
	userID := getBlobUserID(r)
	if userID == "" {
		api.Error(w, http.StatusUnauthorized, "UNAUTHORIZED", "authentication required")
		return
	}

	// Check if listing for specific owner (admin only)
	ownerID := r.URL.Query().Get("owner")
	if ownerID == "" {
		ownerID = userID
	} else if ownerID != userID && !isBlobAdmin(r) {
		api.Error(w, http.StatusForbidden, "FORBIDDEN", "cannot list other users' blobs")
		return
	}

	blobs, err := bs.ListByOwner(ownerID)
	if err != nil {
		api.Error(w, http.StatusInternalServerError, "LIST_FAILED", err.Error())
		return
	}

	api.JSON(w, http.StatusOK, map[string]interface{}{
		"blobs": blobs,
	})
}

// HandleBlobTransfer handles blob ownership transfer requests.
func (bs *BlobStore) HandleTransfer(w http.ResponseWriter, r *http.Request) {
	id := r.PathValue("id")
	if id == "" {
		api.Error(w, http.StatusBadRequest, "MISSING_ID", "blob ID is required")
		return
	}

	userID := getBlobUserID(r)
	if userID == "" {
		api.Error(w, http.StatusUnauthorized, "UNAUTHORIZED", "authentication required")
		return
	}

	var req struct {
		OwnerID string `json:"ownerId"`
	}
	if err := api.DecodeJSON(r, &req); err != nil {
		api.Error(w, http.StatusBadRequest, "INVALID_REQUEST", err.Error())
		return
	}

	if req.OwnerID == "" {
		api.Error(w, http.StatusBadRequest, "MISSING_OWNER", "new owner ID is required")
		return
	}

	if err := bs.TransferOwnership(id, userID, req.OwnerID, isBlobAdmin(r)); err != nil {
		api.Error(w, http.StatusForbidden, "TRANSFER_FAILED", err.Error())
		return
	}

	api.JSON(w, http.StatusOK, map[string]interface{}{
		"success": true,
		"ownerId": req.OwnerID,
	})
}

// HandleBlobDelete handles blob deletion requests.
func (bs *BlobStore) HandleDelete(w http.ResponseWriter, r *http.Request) {
	id := r.PathValue("id")
	if id == "" {
		api.Error(w, http.StatusBadRequest, "MISSING_ID", "blob ID is required")
		return
	}

	userID := getBlobUserID(r)
	if userID == "" {
		api.Error(w, http.StatusUnauthorized, "UNAUTHORIZED", "authentication required")
		return
	}

	if err := bs.Delete(id, userID, isBlobAdmin(r)); err != nil {
		api.Error(w, http.StatusForbidden, "DELETE_FAILED", err.Error())
		return
	}

	api.JSON(w, http.StatusOK, map[string]interface{}{
		"success": true,
	})
}

// Helper functions to extract user info from context

func getBlobUserID(r *http.Request) string {
{{- if $.HasAccessControl}}
	user, ok := r.Context().Value("user").(*User)
	if !ok || user == nil {
		return ""
	}
	return fmt.Sprintf("%d", user.ID)
{{- else}}
	// No auth configured, use anonymous user
	return "anonymous"
{{- end}}
}

func isBlobAdmin(r *http.Request) bool {
{{- if $.HasAccessControl}}
	user, ok := r.Context().Value("user").(*User)
	if !ok || user == nil {
		return false
	}
	for _, role := range user.Roles {
		if role == "admin" {
			return true
		}
	}
	return false
{{- else}}
	_ = r
	return false
{{- end}}
}
