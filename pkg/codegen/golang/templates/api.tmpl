// Code generated by petri-pilot. DO NOT EDIT.

package main

import (
	"context"
	"encoding/json"
	"net/http"
	"strconv"

	"github.com/pflow-xyz/petri-pilot/pkg/runtime/api"
	"github.com/pflow-xyz/petri-pilot/pkg/runtime/eventstore"
)

// BuildRouter creates an HTTP router for the {{.ModelName}} workflow.
func BuildRouter(app *Application{{if .HasAccessControl}}, middleware *Middleware{{end}}{{if .HasNavigation}}, navigation *Navigation{{end}}) http.Handler {
	r := api.NewRouter()

	// Health check - always returns ok if server is running
	r.GET("/health", "Health check", func(w http.ResponseWriter, r *http.Request) {
		api.JSON(w, http.StatusOK, map[string]string{"status": "ok"})
	})

	// Readiness check - verifies dependencies (database, etc.)
	r.GET("/ready", "Readiness check", HandleReady(app))

	// Create new aggregate
	r.POST("/api/{{.PackageName}}", "Create new {{.ModelName}}", HandleCreate(app))

	// Get aggregate state
	r.GET("/api/{{.PackageName}}/{id}", "Get {{.ModelName}} state", HandleGetState(app))
{{if .HasViews}}
	// View definitions
	r.GET("/api/views", "Get view definitions", HandleGetViews())
{{end}}
{{if .HasNavigation}}
	// Navigation endpoint
	r.GET("/api/navigation", "Get navigation menu", HandleNavigation(navigation))
{{end}}
{{if .HasAdmin}}
	// Admin endpoints
	r.GET("/admin/stats", "Admin statistics", HandleAdminStats(app))
	r.GET("/admin/instances", "List instances", HandleAdminListInstances(app))
	r.GET("/admin/instances/{id}", "Get instance detail", HandleAdminGetInstance(app))
	r.GET("/admin/instances/{id}/events", "Get instance events", HandleAdminGetEvents(app))
{{end}}
	// Event replay endpoints
	r.GET("/api/{{.PackageName}}/{id}/events", "Get event history", HandleGetEvents(app))
	r.GET("/api/{{.PackageName}}/{id}/at/{version}", "Get state at version", HandleGetStateAtVersion(app))
{{if .HasSnapshots}}
	r.POST("/api/{{.PackageName}}/{id}/snapshot", "Create snapshot", HandleCreateSnapshot(app))
	r.POST("/api/{{.PackageName}}/{id}/replay", "Replay from snapshot", HandleReplay(app))
{{end}}
	// Transition endpoints
{{- range .Routes}}
	{{- if $.TransitionRequiresAuth .TransitionID}}
	r.Transition("{{.TransitionID}}", "{{.Path}}", "{{.Description}}", middleware.RequirePermission("{{.TransitionID}}")({{.HandlerName}}(app)))
	{{- else}}
	r.Transition("{{.TransitionID}}", "{{.Path}}", "{{.Description}}", {{.HandlerName}}(app))
	{{- end}}
{{- end}}

	return r.Build()
}

// HandleCreate creates a new aggregate instance.
func HandleCreate(app *Application) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()

		id, err := app.Create(ctx)
		if err != nil {
			api.Error(w, http.StatusInternalServerError, "CREATE_FAILED", err.Error())
			return
		}

		// Load the new aggregate to get initial state
		agg, err := app.Load(ctx, id)
		if err != nil {
			api.Error(w, http.StatusInternalServerError, "LOAD_FAILED", err.Error())
			return
		}

		api.JSON(w, http.StatusCreated, api.StateResponse{
			AggregateID:        agg.ID(),
			Version:            agg.Version(),
			State:              agg.State(),
			Places:             agg.Places(),
			EnabledTransitions: agg.EnabledTransitions(),
		})
	}
}

// HandleGetState returns the current state of an aggregate.
func HandleGetState(app *Application) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()
		id := r.PathValue("id")
		if id == "" {
			api.Error(w, http.StatusBadRequest, "MISSING_ID", "aggregate ID is required")
			return
		}

		agg, err := app.GetState(ctx, id)
		if err != nil {
			api.Error(w, http.StatusNotFound, "NOT_FOUND", err.Error())
			return
		}

		api.JSON(w, http.StatusOK, api.StateResponse{
			AggregateID:        agg.ID(),
			Version:            agg.Version(),
			State:              agg.State(),
			Places:             agg.Places(),
			EnabledTransitions: agg.EnabledTransitions(),
		})
	}
}

// HandleReady checks if the application is ready to serve requests.
// Returns 200 if all dependencies are available, 503 otherwise.
func HandleReady(app *Application) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		checks := make(map[string]string)
		ready := true

		// Check event store connectivity
		if err := app.HealthCheck(r.Context()); err != nil {
			checks["eventstore"] = err.Error()
			ready = false
		} else {
			checks["eventstore"] = "ok"
		}

		status := http.StatusOK
		statusText := "ready"
		if !ready {
			status = http.StatusServiceUnavailable
			statusText = "not ready"
		}

		api.JSON(w, status, map[string]any{
			"status": statusText,
			"checks": checks,
		})
	}
}

{{range .Transitions}}
// {{.HandlerName}} handles the {{.ID}} transition.
func {{.HandlerName}}(app *Application) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()

		var req api.TransitionRequest
		if err := api.DecodeJSON(r, &req); err != nil {
			api.Error(w, http.StatusBadRequest, "INVALID_REQUEST", err.Error())
			return
		}

		if req.AggregateID == "" {
			api.Error(w, http.StatusBadRequest, "MISSING_ID", "aggregate_id is required")
			return
		}

		agg, err := app.Execute(ctx, req.AggregateID, {{.ConstName}}, req.Data)
		if err != nil {
			api.Error(w, http.StatusConflict, "TRANSITION_FAILED", err.Error())
			return
		}

		api.JSON(w, http.StatusOK, api.TransitionResult{
			Success:     true,
			AggregateID: agg.ID(),
			Version:     agg.Version(),
			State:       agg.Places(),
		})
	}
}

{{end}}
{{- if .HasViews}}
// HandleGetViews returns the view definitions for the workflow.
func HandleGetViews() http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		data, err := ViewsJSON()
		if err != nil {
			api.Error(w, http.StatusInternalServerError, "VIEWS_ERROR", err.Error())
			return
		}
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusOK)
		w.Write(data)
	}
}
{{- end}}

{{if .HasNavigation}}
// HandleNavigation wraps the navigation handler.
func HandleNavigation(nav *Navigation) http.HandlerFunc {
return func(w http.ResponseWriter, r *http.Request) {
userRoles := getUserRoles(r)

items := []NavigationItem{}
for _, item := range nav.Items {
if len(item.Roles) == 0 {
items = append(items, item)
continue
}

if hasAnyRole(userRoles, item.Roles) {
items = append(items, item)
}
}

api.JSON(w, http.StatusOK, map[string]interface{}{
"brand": nav.Brand,
"items": items,
})
}
}
{{end}}

{{if .HasAdmin}}
// HandleAdminStats wraps the admin stats handler.
func HandleAdminStats(app *Application) http.HandlerFunc {
return func(w http.ResponseWriter, r *http.Request) {
ctx := r.Context()

adminStore, ok := app.store.(interface {
GetStats(ctx context.Context) (*eventstore.Stats, error)
})
if !ok {
api.Error(w, http.StatusInternalServerError, "UNSUPPORTED", "Admin operations not supported")
return
}

stats, err := adminStore.GetStats(ctx)
if err != nil {
api.Error(w, http.StatusInternalServerError, "STATS_FAILED", err.Error())
return
}

api.JSON(w, http.StatusOK, stats)
}
}

// HandleAdminListInstances wraps the admin list instances handler.
func HandleAdminListInstances(app *Application) http.HandlerFunc {
return func(w http.ResponseWriter, r *http.Request) {
ctx := r.Context()

place := r.URL.Query().Get("place")
from := r.URL.Query().Get("from")
to := r.URL.Query().Get("to")
page := getIntQueryParam(r, "page", 1)
perPage := getIntQueryParam(r, "per_page", 50)

adminStore, ok := app.store.(interface {
ListInstances(ctx context.Context, place, from, to string, page, perPage int) ([]eventstore.Instance, int, error)
})
if !ok {
api.Error(w, http.StatusInternalServerError, "UNSUPPORTED", "Admin operations not supported")
return
}

instances, total, err := adminStore.ListInstances(ctx, place, from, to, page, perPage)
if err != nil {
api.Error(w, http.StatusInternalServerError, "LIST_FAILED", err.Error())
return
}

api.JSON(w, http.StatusOK, map[string]interface{}{
"instances": instances,
"total":     total,
"page":      page,
"per_page":  perPage,
})
}
}

// HandleAdminGetInstance wraps the admin get instance handler.
func HandleAdminGetInstance(app *Application) http.HandlerFunc {
return func(w http.ResponseWriter, r *http.Request) {
ctx := r.Context()
id := r.PathValue("id")

agg, err := app.Load(ctx, id)
if err != nil {
api.Error(w, http.StatusNotFound, "NOT_FOUND", err.Error())
return
}

api.JSON(w, http.StatusOK, map[string]interface{}{
"id":      agg.ID(),
"version": agg.Version(),
"state":   agg.State(),
})
}
}

// HandleAdminGetEvents wraps the admin get events handler.
func HandleAdminGetEvents(app *Application) http.HandlerFunc {
return func(w http.ResponseWriter, r *http.Request) {
ctx := r.Context()
id := r.PathValue("id")
from := getIntQueryParam(r, "from", 0)

events, err := app.store.Read(ctx, id, from)
if err != nil {
api.Error(w, http.StatusInternalServerError, "READ_FAILED", err.Error())
return
}

api.JSON(w, http.StatusOK, map[string]interface{}{
"events": events,
})
}
}
{{end}}

// HandleGetEvents returns the event history for an aggregate.
func HandleGetEvents(app *Application) http.HandlerFunc {
return func(w http.ResponseWriter, r *http.Request) {
ctx := r.Context()
id := r.PathValue("id")
from := getIntQueryParam(r, "from", 0)

events, err := app.store.Read(ctx, id, from)
if err != nil {
api.Error(w, http.StatusInternalServerError, "READ_FAILED", err.Error())
return
}

api.JSON(w, http.StatusOK, map[string]interface{}{
"events": events,
})
}
}

// HandleGetStateAtVersion returns the aggregate state at a specific version.
func HandleGetStateAtVersion(app *Application) http.HandlerFunc {
return func(w http.ResponseWriter, r *http.Request) {
ctx := r.Context()
id := r.PathValue("id")
versionStr := r.PathValue("version")

version := getInt(versionStr, 0)
if version <= 0 {
api.Error(w, http.StatusBadRequest, "INVALID_VERSION", "version must be a positive integer")
return
}

events, err := app.store.Read(ctx, id, 0)
if err != nil {
api.Error(w, http.StatusInternalServerError, "READ_FAILED", err.Error())
return
}

// Create temporary aggregate and replay up to version
agg, err := app.engine.NewAggregate(id)
if err != nil {
api.Error(w, http.StatusInternalServerError, "CREATE_FAILED", err.Error())
return
}

for _, evt := range events {
if evt.Version > version {
break
}
if err := agg.Apply(evt); err != nil {
api.Error(w, http.StatusInternalServerError, "APPLY_FAILED", err.Error())
return
}
}

api.JSON(w, http.StatusOK, map[string]interface{}{
"id":      agg.ID(),
"version": version,
"state":   agg.State(),
})
}
}

{{if .HasSnapshots}}
// HandleCreateSnapshot creates a snapshot of the current aggregate state.
func HandleCreateSnapshot(app *Application) http.HandlerFunc {
return func(w http.ResponseWriter, r *http.Request) {
ctx := r.Context()
id := r.PathValue("id")

agg, err := app.Load(ctx, id)
if err != nil {
api.Error(w, http.StatusNotFound, "NOT_FOUND", err.Error())
return
}

snapshotStore, ok := app.store.(eventstore.SnapshotStore)
if !ok {
api.Error(w, http.StatusInternalServerError, "UNSUPPORTED", "Snapshots not supported")
return
}

stateBytes, err := json.Marshal(agg.State())
if err != nil {
api.Error(w, http.StatusInternalServerError, "MARSHAL_FAILED", err.Error())
return
}

snapshot := &eventstore.Snapshot{
StreamID: id,
Version:  agg.Version(),
State:    stateBytes,
}

if err := snapshotStore.Save(ctx, snapshot); err != nil {
api.Error(w, http.StatusInternalServerError, "SAVE_FAILED", err.Error())
return
}

api.JSON(w, http.StatusCreated, map[string]interface{}{
"message": "Snapshot created",
"version": agg.Version(),
})
}
}

// HandleReplay replays events from the latest snapshot.
func HandleReplay(app *Application) http.HandlerFunc {
return func(w http.ResponseWriter, r *http.Request) {
ctx := r.Context()
id := r.PathValue("id")

snapshotStore, ok := app.store.(eventstore.SnapshotStore)
if !ok {
api.Error(w, http.StatusInternalServerError, "UNSUPPORTED", "Snapshots not supported")
return
}

// Load latest snapshot
snap, err := snapshotStore.Load(ctx, id)
fromVersion := 0

agg, err := app.engine.NewAggregate(id)
if err != nil {
api.Error(w, http.StatusInternalServerError, "CREATE_FAILED", err.Error())
return
}

if snap != nil {
// Restore from snapshot
var state map[string]int
if err := json.Unmarshal(snap.State, &state); err != nil {
api.Error(w, http.StatusInternalServerError, "UNMARSHAL_FAILED", err.Error())
return
}

// This is a simplified restore - actual implementation depends on aggregate structure
fromVersion = snap.Version
}

// Load events after snapshot
events, err := app.store.Read(ctx, id, fromVersion)
if err != nil {
api.Error(w, http.StatusInternalServerError, "READ_FAILED", err.Error())
return
}

// Replay events
eventsApplied := 0
for _, evt := range events {
if evt.Version <= fromVersion {
continue
}
if err := agg.Apply(evt); err != nil {
api.Error(w, http.StatusInternalServerError, "APPLY_FAILED", err.Error())
return
}
eventsApplied++
}

api.JSON(w, http.StatusOK, map[string]interface{}{
"id":                      agg.ID(),
"version":                 agg.Version(),
"state":                   agg.State(),
"replayed_from_snapshot":  fromVersion,
"events_applied":          eventsApplied,
})
}
}
{{end}}

// Helper functions

func getIntQueryParam(r *http.Request, name string, defaultVal int) int {
val := r.URL.Query().Get(name)
return getInt(val, defaultVal)
}

func getInt(s string, defaultVal int) int {
if s == "" {
return defaultVal
}

intVal, err := strconv.Atoi(s)
if err != nil {
return defaultVal
}

return intVal
}
