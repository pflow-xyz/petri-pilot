// Code generated by petri-pilot. DO NOT EDIT.
package main

import (
	"encoding/json"
	"net/http"
	"strconv"
	
	"github.com/go-chi/chi/v5"
	"github.com/pflow-xyz/petri-pilot/pkg/runtime/eventstore"
)

// handleGetEvents returns the full event history for an aggregate.
// GET /api/{{.ModelName}}/{id}/events
func (s *Server) handleGetEvents(w http.ResponseWriter, r *http.Request) {
	id := chi.URLParam(r, "id")
	fromStr := r.URL.Query().Get("from")
	from := 0
	
	if fromStr != "" {
		var err error
		from, err = strconv.Atoi(fromStr)
		if err != nil {
			http.Error(w, "Invalid 'from' parameter", http.StatusBadRequest)
			return
		}
	}
	
	events, err := s.store.Read(r.Context(), id, from)
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}
	
	response := map[string]interface{}{
		"events": events,
	}
	
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(response)
}

// handleGetStateAtVersion returns the aggregate state at a specific version.
// GET /api/{{.ModelName}}/{id}/at/{version}
func (s *Server) handleGetStateAtVersion(w http.ResponseWriter, r *http.Request) {
	id := chi.URLParam(r, "id")
	versionStr := chi.URLParam(r, "version")
	
	version, err := strconv.Atoi(versionStr)
	if err != nil {
		http.Error(w, "Invalid version parameter", http.StatusBadRequest)
		return
	}
	
	// Load events up to version
	events, err := s.store.Read(r.Context(), id, 0)
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}
	
	// Replay events up to version
	agg := &Aggregate{ID: id}
	for _, evt := range events {
		if evt.Version > version {
			break
		}
		agg.applyEvent(evt)
	}
	
	response := map[string]interface{}{
		"id":      agg.ID,
		"version": version,
		"state":   agg.State,
	}
	
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(response)
}

{{if .HasSnapshots}}
// handleCreateSnapshot creates a snapshot of the current aggregate state.
// POST /api/{{.ModelName}}/{id}/snapshot
func (s *Server) handleCreateSnapshot(w http.ResponseWriter, r *http.Request) {
	id := chi.URLParam(r, "id")
	
	// Load current aggregate
	events, err := s.store.Read(r.Context(), id, 0)
	if err != nil {
		http.Error(w, err.Error(), http.StatusNotFound)
		return
	}
	
	if len(events) == 0 {
		http.Error(w, "Aggregate not found", http.StatusNotFound)
		return
	}
	
	// Rebuild aggregate state
	agg := &Aggregate{ID: id}
	for _, evt := range events {
		agg.applyEvent(evt)
	}
	
	// Save snapshot
	snapshotStore, ok := s.store.(eventstore.SnapshotStore)
	if !ok {
		http.Error(w, "Snapshots not supported by event store", http.StatusInternalServerError)
		return
	}
	
	stateBytes, err := json.Marshal(agg.State)
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}
	
	snapshot := &eventstore.Snapshot{
		StreamID: id,
		Version:  agg.Version,
		State:    stateBytes,
	}
	
	if err := snapshotStore.Save(r.Context(), snapshot); err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}
	
	w.WriteHeader(http.StatusCreated)
	json.NewEncoder(w).Encode(map[string]interface{}{
		"message": "Snapshot created",
		"version": agg.Version,
	})
}

// handleReplay replays events from the latest snapshot.
// POST /api/{{.ModelName}}/{id}/replay
func (s *Server) handleReplay(w http.ResponseWriter, r *http.Request) {
	id := chi.URLParam(r, "id")
	
	snapshotStore, ok := s.store.(eventstore.SnapshotStore)
	if !ok {
		http.Error(w, "Snapshots not supported by event store", http.StatusInternalServerError)
		return
	}
	
	// Load latest snapshot
	snap, err := snapshotStore.Load(r.Context(), id)
	fromVersion := 0
	
	agg := &Aggregate{ID: id}
	
	if err == nil && snap != nil {
		// Restore from snapshot
		if err := json.Unmarshal(snap.State, &agg.State); err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}
		agg.Version = snap.Version
		fromVersion = snap.Version
	}
	
	// Load events after snapshot
	events, err := s.store.Read(r.Context(), id, fromVersion)
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}
	
	// Replay events
	for _, evt := range events {
		if evt.Version <= fromVersion {
			continue
		}
		agg.applyEvent(evt)
	}
	
	response := map[string]interface{}{
		"id":                      agg.ID,
		"version":                 agg.Version,
		"state":                   agg.State,
		"replayed_from_snapshot":  fromVersion,
		"events_applied":          len(events),
	}
	
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(response)
}
{{end}}
