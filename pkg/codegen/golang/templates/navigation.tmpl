// Code generated by petri-pilot. DO NOT EDIT.
package main

import (
	"encoding/json"
	"net/http"
)

{{if .Navigation}}
// NavigationItem represents a menu item in the navigation.
type NavigationItem struct {
	Label string   `json:"label"`
	Path  string   `json:"path"`
	Icon  string   `json:"icon,omitempty"`
	Roles []string `json:"roles,omitempty"`
}

// Navigation represents the navigation menu structure.
type Navigation struct {
	Brand string           `json:"brand"`
	Items []NavigationItem `json:"items"`
}

// handleNavigation returns the navigation menu filtered by user roles.
// GET /api/navigation
func (s *Server) handleNavigation(w http.ResponseWriter, r *http.Request) {
	userRoles := getUserRoles(r) // from JWT claims
	
	items := []NavigationItem{}
	for _, item := range s.navigation.Items {
		// If no roles specified, item is visible to all
		if len(item.Roles) == 0 {
			items = append(items, item)
			continue
		}
		
		// Check if user has any of the required roles
		if hasAnyRole(userRoles, item.Roles) {
			items = append(items, item)
		}
	}
	
	response := map[string]interface{}{
		"brand": s.navigation.Brand,
		"items": items,
	}
	
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(response)
}

// hasAnyRole checks if userRoles contains any of the required roles.
func hasAnyRole(userRoles, requiredRoles []string) bool {
	roleSet := make(map[string]bool)
	for _, r := range userRoles {
		roleSet[r] = true
	}
	
	for _, required := range requiredRoles {
		if roleSet[required] {
			return true
		}
	}
	return false
}

// getUserRoles extracts roles from the request context (set by auth middleware).
func getUserRoles(r *http.Request) []string {
	user, ok := r.Context().Value("user").(*User)
	if !ok || user == nil {
		return []string{}
	}
	return user.Roles
}
{{end}}
