// Code generated by petri-pilot. DO NOT EDIT.

package {{.PackageName}}

import (
	"context"
	"encoding/json"
	"fmt"
{{- if or .UsesMetamodelRuntime .HasSLAs}}
	"time"
{{- end}}

	"github.com/google/uuid"
{{- if .UsesMetamodelRuntime}}
	"github.com/pflow-xyz/petri-pilot/pkg/dsl"
	"github.com/pflow-xyz/petri-pilot/pkg/metamodel"
{{- end}}
	"github.com/pflow-xyz/petri-pilot/pkg/runtime"
	"github.com/pflow-xyz/petri-pilot/pkg/runtime/aggregate"
	"github.com/pflow-xyz/petri-pilot/pkg/runtime/eventstore"
)

// State holds the aggregate state for {{.ModelName}}.
type State struct {
{{- if .HasSLAs}}
	StartedAt time.Time `json:"started_at"`
	Priority  string    `json:"priority,omitempty"`
{{- end}}
{{- range .StateFields}}
{{- if .IsToken}}
	{{.FieldName}} {{.Type}} `json:"{{.JSONName}}"`
{{- else}}
	{{.FieldName}} {{.Type}} `json:"{{.JSONName}},omitempty"`
{{- end}}
{{- end}}
}

// NewState creates a new State with initialized collections.
func NewState() State {
	return State{
{{- if .HasSLAs}}
		StartedAt: time.Now(),
{{- end}}
{{- range .Collections}}
		{{.FieldName}}: {{.Initializer}},
{{- end}}
	}
}

{{- if .UsesMetamodelRuntime}}

// Bindings holds parameters for action execution.
// Contains all unique fields across all event types.
type Bindings struct {
	AggregateID string    `json:"aggregate_id"`
	Timestamp   time.Time `json:"timestamp"`
	From        string    `json:"from,omitempty"`
	To          string    `json:"to,omitempty"`
	Owner       string    `json:"owner,omitempty"`
	Spender     string    `json:"spender,omitempty"`
	Caller      string    `json:"caller,omitempty"`
	Amount      U256JSON  `json:"amount,omitempty"`
}

// ToMetamodel converts Bindings to metamodel.Bindings.
func (b *Bindings) ToMetamodel() metamodel.Bindings {
	var amount int64
	if b.Amount.U256 != nil {
		// Convert to int64 for guard evaluation (may overflow for large values)
		amount = int64(b.Amount.U256.Uint64())
	}
	return metamodel.Bindings{
		"aggregate_id": b.AggregateID,
		"from":         b.From,
		"to":           b.To,
		"owner":        b.Owner,
		"spender":      b.Spender,
		"caller":       b.Caller,
		"amount":       amount,
	}
}
{{- end}}

// Aggregate wraps a StateMachine with the {{.ModelName}} state.
type Aggregate struct {
	sm *aggregate.StateMachine[State]
{{- if .UsesMetamodelRuntime}}
	rt *metamodel.Runtime // Runtime for guard evaluation
{{- end}}
}

// NewAggregate creates a new aggregate with initial state.
func NewAggregate(id string) *Aggregate {
	if id == "" {
		id = uuid.New().String()
	}
	sm := aggregate.NewStateMachine(id, NewState(), InitialPlaces())

	// Register transitions with their input/output places
{{- range .Transitions}}
	sm.AddTransition(aggregate.Transition{
		ID:        {{.ConstName}},
		EventType: EventType{{.FuncName}},
		Inputs: map[string]int{
{{- range .Inputs}}
			{{.ConstName}}: {{.Weight}},
{{- end}}
		},
		Outputs: map[string]int{
{{- range .Outputs}}
			{{.ConstName}}: {{.Weight}},
{{- end}}
		},
	})
{{- end}}

	// Register event handlers for state updates
{{- range .Transitions}}
	sm.RegisterHandler(EventType{{.FuncName}}, func(state *State, event *runtime.Event) error {
		return apply{{.FuncName}}(state, event)
	})
{{- end}}

{{- if .UsesMetamodelRuntime}}
	// Create metamodel runtime for guard evaluation
	schema := buildSchema()
	rt := metamodel.NewRuntime(schema)
	rt.GuardEvaluator = &guardEval{}

	return &Aggregate{sm: sm, rt: rt}
{{- else}}
	return &Aggregate{sm: sm}
{{- end}}
}

// ID returns the aggregate identifier.
func (a *Aggregate) ID() string {
	return a.sm.ID()
}

// Version returns the current event version.
func (a *Aggregate) Version() int {
	return a.sm.Version()
}

// State returns the current state.
func (a *Aggregate) State() any {
	return a.sm.State()
}

// Places returns current token distribution.
func (a *Aggregate) Places() map[string]int {
	places := make(map[string]int)
	for _, p := range AllPlaces() {
		places[p] = a.sm.Tokens(p)
	}
	return places
}

// EnabledTransitions returns transitions that can fire.
func (a *Aggregate) EnabledTransitions() []string {
	return a.sm.EnabledTransitions()
}

// CanFire checks if a transition can fire.
func (a *Aggregate) CanFire(transitionID string) bool {
	return a.sm.CanFire(transitionID)
}

{{- if .HasGuards}}

// CheckGuard evaluates a guard condition with the given bindings.
func (a *Aggregate) CheckGuard(transitionID string, bindings *Bindings) (bool, error) {
{{- range .Guards}}
	if transitionID == "{{.TransitionID}}" {
		return a.evaluateGuard{{pascal .TransitionID}}(bindings)
	}
{{- end}}
	return true, nil // No guard for this transition
}
{{- range .Guards}}

func (a *Aggregate) evaluateGuard{{pascal .TransitionID}}(bindings *Bindings) (bool, error) {
	// Guard: {{.Expression}}
	state := a.sm.TypedState()
	mb := bindings.ToMetamodel()

	// Add state data to bindings for evaluation
{{- range .Collections}}
	mb["{{.}}"] = state.{{pascal .}}
{{- end}}

	return dsl.Evaluate("{{.Expression}}", mb, nil)
}
{{- end}}
{{- end}}

// Fire executes a transition and returns the resulting event.
func (a *Aggregate) Fire(transitionID string, data any) (*runtime.Event, error) {
{{- if .HasGuards}}
	// Check guard if bindings are provided
	if bindings, ok := data.(*Bindings); ok {
		passed, err := a.CheckGuard(transitionID, bindings)
		if err != nil {
			return nil, fmt.Errorf("guard evaluation failed: %w", err)
		}
		if !passed {
			return nil, fmt.Errorf("guard condition not satisfied for %s", transitionID)
		}
	}
{{- end}}
	return a.sm.Fire(transitionID, data)
}

// Apply applies an event to update the aggregate state.
func (a *Aggregate) Apply(event *runtime.Event) error {
	// Update state machine (this calls the registered handlers)
	return a.sm.Apply(event)
}

// Event application functions
{{- range .Transitions}}

func apply{{.FuncName}}(state *State, event *runtime.Event) error {
{{- if or (len .InputDataArcs) (len .OutputDataArcs)}}
	// Unmarshal event data to get bindings
	var bindings Bindings
	if err := json.Unmarshal(event.Data, &bindings); err != nil {
		return fmt.Errorf("unmarshaling event data: %w", err)
	}

{{- range .InputDataArcs}}
{{- if .IsSimple}}
	// Read {{.FieldName}} (simple type) - no state change for input arcs on simple types
{{- else if .IsNumeric}}
	// Subtract from {{.FieldName}}
{{- if eq (len .Keys) 1}}
	state.{{.FieldName}}[bindings.{{index .KeyFields 0}}] -= {{if $.UsesMetamodelRuntime}}bindings.{{.ValueField}}.Int64(){{else}}bindings.{{.ValueField}}{{end}}
{{- else if .UsesCompositeKey}}
	{{camel .FieldName}}Key := bindings.{{index .KeyFields 0}} + ":" + bindings.{{index .KeyFields 1}}
	state.{{.FieldName}}[{{camel .FieldName}}Key] -= {{if $.UsesMetamodelRuntime}}bindings.{{.ValueField}}.Int64(){{else}}bindings.{{.ValueField}}{{end}}
{{- else if eq (len .Keys) 2}}
	if state.{{.FieldName}}[bindings.{{index .KeyFields 0}}] == nil {
		state.{{.FieldName}}[bindings.{{index .KeyFields 0}}] = make(map[string]int64)
	}
	state.{{.FieldName}}[bindings.{{index .KeyFields 0}}][bindings.{{index .KeyFields 1}}] -= {{if $.UsesMetamodelRuntime}}bindings.{{.ValueField}}.Int64(){{else}}bindings.{{.ValueField}}{{end}}
{{- end}}
{{- end}}
{{- end}}

{{- range .OutputDataArcs}}
{{- if .IsSimple}}
	// Set {{.FieldName}} (simple type) from binding
	state.{{.FieldName}} = {{if $.UsesMetamodelRuntime}}bindings.{{.ValueField}}.Int64(){{else}}bindings.{{.ValueField}}{{end}}
{{- else if .IsNumeric}}
	// Add to {{.FieldName}}
{{- if eq (len .Keys) 1}}
	state.{{.FieldName}}[bindings.{{index .KeyFields 0}}] += {{if $.UsesMetamodelRuntime}}bindings.{{.ValueField}}.Int64(){{else}}bindings.{{.ValueField}}{{end}}
{{- else if .UsesCompositeKey}}
	{{camel .FieldName}}Key := bindings.{{index .KeyFields 0}} + ":" + bindings.{{index .KeyFields 1}}
	state.{{.FieldName}}[{{camel .FieldName}}Key] += {{if $.UsesMetamodelRuntime}}bindings.{{.ValueField}}.Int64(){{else}}bindings.{{.ValueField}}{{end}}
{{- else if eq (len .Keys) 2}}
	if state.{{.FieldName}}[bindings.{{index .KeyFields 0}}] == nil {
		state.{{.FieldName}}[bindings.{{index .KeyFields 0}}] = make(map[string]int64)
	}
	state.{{.FieldName}}[bindings.{{index .KeyFields 0}}][bindings.{{index .KeyFields 1}}] += {{if $.UsesMetamodelRuntime}}bindings.{{.ValueField}}.Int64(){{else}}bindings.{{.ValueField}}{{end}}
{{- end}}
{{- else}}
	// Set {{.FieldName}} at key from binding (non-numeric map)
{{- if eq (len .Keys) 1}}
	state.{{.FieldName}}[bindings.{{index .KeyFields 0}}] = {{if $.UsesMetamodelRuntime}}bindings.{{.ValueField}}.Int64(){{else}}bindings.{{.ValueField}}{{end}}
{{- else if .UsesCompositeKey}}
	{{camel .FieldName}}Key := bindings.{{index .KeyFields 0}} + ":" + bindings.{{index .KeyFields 1}}
	state.{{.FieldName}}[{{camel .FieldName}}Key] = {{if $.UsesMetamodelRuntime}}bindings.{{.ValueField}}.Int64(){{else}}bindings.{{.ValueField}}{{end}}
{{- else if eq (len .Keys) 2}}
	if state.{{.FieldName}}[bindings.{{index .KeyFields 0}}] == nil {
		state.{{.FieldName}}[bindings.{{index .KeyFields 0}}] = make({{.ValueType}})
	}
	state.{{.FieldName}}[bindings.{{index .KeyFields 0}}][bindings.{{index .KeyFields 1}}] = {{if $.UsesMetamodelRuntime}}bindings.{{.ValueField}}.Int64(){{else}}bindings.{{.ValueField}}{{end}}
{{- end}}
{{- end}}
{{- end}}
{{- else}}
	// No data transformations for this transition
	_ = state
	_ = event
{{- end}}
	return nil
}
{{- end}}

{{- if .UsesMetamodelRuntime}}

// buildSchema creates the metamodel schema for this model.
func buildSchema() *metamodel.Schema {
	s := metamodel.NewSchema("{{.ModelName}}")

	// Add states (places)
{{- range .Places}}
{{- if .IsToken}}
	s.AddTokenState("{{.ID}}", {{.Initial}})
{{- else}}
	s.AddDataState("{{.ID}}", "{{.Type}}", nil, {{.Exported}})
{{- end}}
{{- end}}

	// Add actions (transitions)
{{- range .Transitions}}
	s.AddAction(metamodel.Action{
		ID:    "{{.ID}}",
		Guard: "{{.Guard}}",
	})
{{- end}}

	// Add arcs
{{- range .Model.Arcs}}
	s.AddArc(metamodel.Arc{
		Source: "{{.From}}",
		Target: "{{.To}}",
{{- if .Keys}}
		Keys:   []string{ {{- range $i, $k := .Keys}}{{if $i}}, {{end}}"{{$k}}"{{end}} },
{{- end}}
{{- if .Value}}
		Value:  "{{.Value}}",
{{- end}}
	})
{{- end}}

	return s
}

// guardEval implements metamodel.GuardEvaluator.
type guardEval struct{}

func (g *guardEval) Evaluate(expr string, bindings metamodel.Bindings, funcs map[string]metamodel.GuardFunc) (bool, error) {
	// Convert metamodel.GuardFunc to dsl.GuardFunc
	dslFuncs := make(map[string]dsl.GuardFunc)
	for k, f := range funcs {
		f := f
		dslFuncs[k] = func(args ...any) (any, error) {
			return f(args...)
		}
	}
	bindingsMap := make(map[string]any, len(bindings))
	for k, v := range bindings {
		bindingsMap[k] = v
	}
	return dsl.Evaluate(expr, bindingsMap, dslFuncs)
}

func (g *guardEval) EvaluateConstraint(expr string, tokens map[string]int) (bool, error) {
	marking := make(dsl.Marking, len(tokens))
	for k, v := range tokens {
		marking[k] = v
	}
	return dsl.EvaluateInvariant(expr, marking)
}
{{- end}}

// Application wires together the aggregate and event store.
type Application struct {
	store eventstore.Store
}

// NewApplication creates a new application instance.
func NewApplication(store eventstore.Store) *Application {
	return &Application{store: store}
}

// Create creates a new aggregate and returns its ID.
func (app *Application) Create(ctx context.Context) (string, error) {
	agg := NewAggregate("")
	return agg.ID(), nil
}

// Load loads an aggregate from the event store.
func (app *Application) Load(ctx context.Context, id string) (*Aggregate, error) {
	events, err := app.store.Read(ctx, id, 0)
	if err != nil {
		return nil, fmt.Errorf("reading events: %w", err)
	}

	agg := NewAggregate(id)
	for _, event := range events {
		if err := agg.Apply(event); err != nil {
			return nil, fmt.Errorf("applying event %s: %w", event.ID, err)
		}
	}

	return agg, nil
}

// Execute fires a transition on an aggregate and persists the event.
func (app *Application) Execute(ctx context.Context, id, transitionID string, data any) (*Aggregate, error) {
	// Load current state
	agg, err := app.Load(ctx, id)
	if err != nil {
		return nil, err
	}

	// Check if transition can fire
	if !agg.CanFire(transitionID) {
		return nil, fmt.Errorf("transition %s cannot fire from current state", transitionID)
	}

	// Fire transition (this updates token counts but not version)
	event, err := agg.Fire(transitionID, data)
	if err != nil {
		return nil, fmt.Errorf("firing transition: %w", err)
	}

	// Persist event (this assigns the event version)
	// The expected version should match the current stream version (-1 for new streams)
	_, err = app.store.Append(ctx, id, agg.Version(), []*runtime.Event{event})
	if err != nil {
		return nil, fmt.Errorf("persisting event: %w", err)
	}

	// Apply the event to update the aggregate's version
	if err := agg.Apply(event); err != nil {
		return nil, fmt.Errorf("applying event: %w", err)
	}

	return agg, nil
}

// GetState returns the current state of an aggregate.
func (app *Application) GetState(ctx context.Context, id string) (*Aggregate, error) {
	return app.Load(ctx, id)
}

// HealthCheck verifies the event store is accessible.
func (app *Application) HealthCheck(ctx context.Context) error {
	// Try to read from a non-existent stream - this exercises the store connection
	_, err := app.store.Read(ctx, "__health_check__", 0)
	// Ignore "not found" errors - we just want to verify connectivity
	if err != nil && err.Error() != "stream not found" {
		return err
	}
	return nil
}

// Helper to unmarshal event data
func unmarshalEventData[T any](event *runtime.Event) (*T, error) {
	var data T
	if err := json.Unmarshal(event.Data, &data); err != nil {
		return nil, err
	}
	return &data, nil
}
