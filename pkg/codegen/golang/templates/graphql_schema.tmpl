# Code generated by petri-pilot. DO NOT EDIT.
# GraphQL schema for {{.ModelName}}

scalar Time

type Query {
  # Get aggregate state by ID
  {{.PackageName}}(id: ID!): AggregateState

  # List aggregates with optional filtering
  {{.PackageName}}List(place: String, page: Int, perPage: Int): AggregateList!
{{- if .HasAdmin}}

  # Admin statistics
  adminStats: AdminStats!
{{- end}}
{{- if .HasEventSourcing}}

  # Event history for an aggregate
  events(aggregateId: ID!, from: Int): [Event!]!

  # Get state at specific version
  stateAtVersion(aggregateId: ID!, version: Int!): AggregateState
{{- end}}
}

type Mutation {
  # Create a new {{.ModelName}} instance
  create{{pascal .ModelName}}: AggregateState!
{{range .Transitions}}
  # {{.Description}}
  {{camel .ID}}(input: {{pascal .ID}}Input!): TransitionResult!
{{end -}}
}

# Aggregate state representation
type AggregateState {
  id: ID!
  version: Int!
  state: State!
  places: Places!
  enabledTransitions: [String!]!
}

# Workflow state with all places
type State {
{{- range .Places}}
  {{camel .ID}}: {{if .IsToken}}Int{{else}}String{{end}}!
{{- end}}
}

# Token counts for each place
type Places {
{{- range .Places}}
  {{camel .ID}}: Int!
{{- end}}
}

# Result of a transition execution
type TransitionResult {
  success: Boolean!
  aggregateId: ID
  version: Int
  state: Places
  enabledTransitions: [String!]
  error: String
}

# Paginated list of aggregates
type AggregateList {
  items: [AggregateState!]!
  total: Int!
  page: Int!
  perPage: Int!
}
{{if .HasAdmin}}
# Admin statistics
type AdminStats {
  totalInstances: Int!
  byPlace: [PlaceCount!]!
}

type PlaceCount {
  place: String!
  count: Int!
}
{{end}}
{{if .HasEventSourcing}}
# Event record
type Event {
  id: ID!
  streamId: String!
  type: String!
  version: Int!
  timestamp: Time!
  data: String!
}
{{end}}

# Input types for mutations
{{range .Transitions}}
input {{pascal .ID}}Input {
  aggregateId: ID!
{{- range .Bindings}}
  {{.JSONName}}: {{graphqlType .Type}}
{{- end}}
}

{{end -}}
