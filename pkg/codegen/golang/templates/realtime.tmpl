// Code generated by petri-pilot. DO NOT EDIT.

package main

import (
	"context"
	"encoding/json"
	"fmt"
	"log/slog"
	"net/http"
	"sync"
	"time"

	"github.com/gorilla/websocket"
)

// StateChange represents a state change event for real-time updates.
type StateChange struct {
	AggregateID string         `json:"aggregate_id"`
	Version     int            `json:"version"`
	Event       string         `json:"event"`
	State       map[string]int `json:"state"`
	Enabled     []string       `json:"enabled"`
	Timestamp   time.Time      `json:"timestamp"`
}

// Broker manages real-time subscriptions.
type Broker struct {
	mu          sync.RWMutex
	subscribers map[string]map[chan StateChange]struct{}
	logger      *slog.Logger
}

// NewBroker creates a new real-time broker.
func NewBroker(logger *slog.Logger) *Broker {
	return &Broker{
		subscribers: make(map[string]map[chan StateChange]struct{}),
		logger:      logger,
	}
}

// Subscribe creates a subscription for an aggregate.
func (b *Broker) Subscribe(aggregateID string) chan StateChange {
	b.mu.Lock()
	defer b.mu.Unlock()

	ch := make(chan StateChange, 10)
	if b.subscribers[aggregateID] == nil {
		b.subscribers[aggregateID] = make(map[chan StateChange]struct{})
	}
	b.subscribers[aggregateID][ch] = struct{}{}

	b.logger.Debug("subscriber added", "aggregate_id", aggregateID)
	return ch
}

// Unsubscribe removes a subscription.
func (b *Broker) Unsubscribe(aggregateID string, ch chan StateChange) {
	b.mu.Lock()
	defer b.mu.Unlock()

	if subs, ok := b.subscribers[aggregateID]; ok {
		delete(subs, ch)
		close(ch)
		if len(subs) == 0 {
			delete(b.subscribers, aggregateID)
		}
	}
	b.logger.Debug("subscriber removed", "aggregate_id", aggregateID)
}

// Publish sends a state change to all subscribers.
func (b *Broker) Publish(change StateChange) {
	b.mu.RLock()
	defer b.mu.RUnlock()

	subs := b.subscribers[change.AggregateID]
	for ch := range subs {
		select {
		case ch <- change:
		default:
			// Skip slow subscribers
			b.logger.Warn("dropping message for slow subscriber", "aggregate_id", change.AggregateID)
		}
	}

	b.logger.Debug("published state change",
		"aggregate_id", change.AggregateID,
		"version", change.Version,
		"subscribers", len(subs),
	)
}

// SSE Handler

// HandleSSE handles Server-Sent Events for real-time updates.
func HandleSSE(broker *Broker) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		aggregateID := r.URL.Query().Get("id")
		if aggregateID == "" {
			http.Error(w, "missing id parameter", http.StatusBadRequest)
			return
		}

		// Set SSE headers
		w.Header().Set("Content-Type", "text/event-stream")
		w.Header().Set("Cache-Control", "no-cache")
		w.Header().Set("Connection", "keep-alive")
		w.Header().Set("Access-Control-Allow-Origin", "*")

		// Get flusher
		flusher, ok := w.(http.Flusher)
		if !ok {
			http.Error(w, "streaming not supported", http.StatusInternalServerError)
			return
		}

		// Subscribe to updates
		ch := broker.Subscribe(aggregateID)
		defer broker.Unsubscribe(aggregateID, ch)

		// Send initial connection event
		fmt.Fprintf(w, "event: connected\ndata: {\"aggregate_id\":%q}\n\n", aggregateID)
		flusher.Flush()

		// Stream events
		for {
			select {
			case <-r.Context().Done():
				return
			case change, ok := <-ch:
				if !ok {
					return
				}
				data, _ := json.Marshal(change)
				fmt.Fprintf(w, "event: state\ndata: %s\n\n", data)
				flusher.Flush()
			}
		}
	}
}

// WebSocket Handler

var upgrader = websocket.Upgrader{
	CheckOrigin: func(r *http.Request) bool {
		return true // Allow all origins in development
	},
	ReadBufferSize:  1024,
	WriteBufferSize: 1024,
}

// WebSocketMessage represents a message over WebSocket.
type WebSocketMessage struct {
	Type        string      `json:"type"`
	AggregateID string      `json:"aggregate_id,omitempty"`
	Data        interface{} `json:"data,omitempty"`
}

// HandleWebSocket handles WebSocket connections for real-time updates.
func HandleWebSocket(broker *Broker) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		conn, err := upgrader.Upgrade(w, r, nil)
		if err != nil {
			return
		}
		defer conn.Close()

		var subscriptions = make(map[string]chan StateChange)
		var subMu sync.Mutex

		// Cleanup on disconnect
		defer func() {
			subMu.Lock()
			for aggID, ch := range subscriptions {
				broker.Unsubscribe(aggID, ch)
			}
			subMu.Unlock()
		}()

		// Context for goroutines
		ctx, cancel := context.WithCancel(r.Context())
		defer cancel()

		// Read messages from client
		go func() {
			for {
				var msg WebSocketMessage
				if err := conn.ReadJSON(&msg); err != nil {
					cancel()
					return
				}

				switch msg.Type {
				case "subscribe":
					if msg.AggregateID != "" {
						subMu.Lock()
						if _, exists := subscriptions[msg.AggregateID]; !exists {
							ch := broker.Subscribe(msg.AggregateID)
							subscriptions[msg.AggregateID] = ch

							// Forward messages from this subscription
							go func(aggID string, ch chan StateChange) {
								for {
									select {
									case <-ctx.Done():
										return
									case change, ok := <-ch:
										if !ok {
											return
										}
										conn.WriteJSON(WebSocketMessage{
											Type: "state",
											Data: change,
										})
									}
								}
							}(msg.AggregateID, ch)
						}
						subMu.Unlock()

						conn.WriteJSON(WebSocketMessage{
							Type:        "subscribed",
							AggregateID: msg.AggregateID,
						})
					}

				case "unsubscribe":
					if msg.AggregateID != "" {
						subMu.Lock()
						if ch, exists := subscriptions[msg.AggregateID]; exists {
							broker.Unsubscribe(msg.AggregateID, ch)
							delete(subscriptions, msg.AggregateID)
						}
						subMu.Unlock()

						conn.WriteJSON(WebSocketMessage{
							Type:        "unsubscribed",
							AggregateID: msg.AggregateID,
						})
					}

				case "ping":
					conn.WriteJSON(WebSocketMessage{Type: "pong"})
				}
			}
		}()

		// Wait for context cancellation
		<-ctx.Done()
	}
}

// RegisterRealtimeRoutes registers real-time endpoints.
func RegisterRealtimeRoutes(mux *http.ServeMux, broker *Broker) {
	mux.HandleFunc("GET /events", HandleSSE(broker))
	mux.HandleFunc("GET /ws", HandleWebSocket(broker))
}
