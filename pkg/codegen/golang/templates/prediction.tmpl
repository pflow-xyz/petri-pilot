// Code generated by petri-pilot. DO NOT EDIT.

package {{.PackageName}}

import (
	"github.com/pflow-xyz/go-pflow/petri"
	"github.com/pflow-xyz/go-pflow/solver"
)

// PredictionConfig holds simulation parameters.
var PredictionConfig = struct {
	TimeHours float64
	RateScale float64
}{
	TimeHours: {{printf "%.1f" .Prediction.TimeHours}},
	RateScale: {{printf "%.6f" .Prediction.RateScale}},
}

// SimulationResult represents predicted resource levels over time.
type SimulationResult struct {
	TimePoints []float64            `json:"timePoints"`
	Resources  map[string][]float64 `json:"resources"`
	RunoutTime map[string]*float64  `json:"runoutTime,omitempty"`
}

// ResourcePlaceIDs returns the IDs of places marked as resources.
func ResourcePlaceIDs() []string {
	return []string{
{{- range .Places}}
{{- if .Resource}}
		"{{.ID}}",
{{- end}}
{{- end}}
	}
}

// RunSimulation executes ODE prediction from current state.
func RunSimulation(currentTokens map[string]int, hours float64) (*SimulationResult, error) {
	// Build Petri net
	net := buildPredictionPetriNet()

	// Build initial state (map[string]float64)
	initialState := make(map[string]float64)
	for placeID, tokens := range currentTokens {
		initialState[placeID] = float64(tokens)
	}
	// Ensure all places have a value
	for label := range net.Places {
		if _, ok := initialState[label]; !ok {
			initialState[label] = 0
		}
	}

	// Build transition rates
	rates := make(map[string]float64)
{{- range .Transitions}}
{{- if .Rate}}
	rates["{{.ID}}"] = {{printf "%.2f" .Rate}} * PredictionConfig.RateScale
{{- else}}
	rates["{{.ID}}"] = 1.0 * PredictionConfig.RateScale
{{- end}}
{{- end}}

	// Create and solve ODE problem
	tspan := [2]float64{0, hours * 60} // Convert hours to minutes
	prob := solver.NewProblem(net, initialState, tspan, rates)
	solution := solver.Solve(prob, solver.Tsit5(), solver.WorkflowOptions())

	// Extract results
	result := &SimulationResult{
		TimePoints: solution.T,
		Resources:  make(map[string][]float64),
		RunoutTime: make(map[string]*float64),
	}

	// Extract resource place trajectories
	resourcePlaces := ResourcePlaceIDs()
	for _, resourceID := range resourcePlaces {
		trajectory := solution.GetVariable(resourceID)
		if trajectory != nil {
			result.Resources[resourceID] = trajectory

			// Find runout time (when resource <= 0)
			if rt := findRunoutTime(solution.T, trajectory); rt != nil {
				result.RunoutTime[resourceID] = rt
			}
		}
	}

	return result, nil
}

// buildPredictionPetriNet constructs the Petri net from the workflow definition.
func buildPredictionPetriNet() *petri.PetriNet {
	net := petri.NewPetriNet()

	// Add places
{{- range .Places}}
	net.AddPlace("{{.ID}}", float64({{.Initial}}), nil, 0, 0, nil)
{{- end}}

	// Add transitions
{{- range .Transitions}}
	net.AddTransition("{{.ID}}", "default", 0, 0, nil)
{{- end}}

	// Add arcs (from model definition)
{{- range .Model.Arcs}}
	net.AddArc("{{.From}}", "{{.To}}", float64({{if .Weight}}{{.Weight}}{{else}}1{{end}}), false)
{{- end}}

	return net
}

// findRunoutTime finds the first time point where the value drops to or below zero.
func findRunoutTime(t, values []float64) *float64 {
	for i, v := range values {
		if v <= 0 {
			runoutTime := t[i]
			return &runoutTime
		}
	}
	return nil
}

// GetCurrentInventory returns the current token counts for resource places.
// This function should be implemented to read from your aggregate state.
func GetCurrentInventory() map[string]int {
	// Default implementation returns initial values
	// Override this to read actual state from your application
	inventory := make(map[string]int)
{{- range .Places}}
{{- if .Resource}}
	inventory["{{.ID}}"] = {{.Initial}}
{{- end}}
{{- end}}
	return inventory
}
