// Code generated by petri-pilot. DO NOT EDIT.

package {{.PackageName}}

import (
	"context"
	"fmt"
	"log"
	"time"

	"github.com/pflow-xyz/petri-pilot/pkg/dsl"
)

{{if .HasWorkflows}}
// WorkflowExecutor executes multi-step workflows.
type WorkflowExecutor struct {
	// Handlers for entity actions
	// Application code should register handlers using RegisterHandler
	// before executing workflows that call actions.
	handlers map[string]func(context.Context, map[string]any) error
}

// NewWorkflowExecutor creates a new workflow executor.
func NewWorkflowExecutor() *WorkflowExecutor {
	return &WorkflowExecutor{
		handlers: make(map[string]func(context.Context, map[string]any) error),
	}
}

// RegisterHandler registers an action handler for workflows.
func (w *WorkflowExecutor) RegisterHandler(key string, handler func(context.Context, map[string]any) error) {
	w.handlers[key] = handler
}

// WorkflowContext holds data passed between workflow steps.
type WorkflowContext struct {
	Data      map[string]any
	TriggerID string
	StartedAt time.Time
}

// WorkflowStep represents a single step in a workflow.
type WorkflowStep struct {
	ID        string
	Type      string // action, condition, parallel, wait
	Entity    string
	Action    string
	Condition string
	Input     map[string]string // Mapping from workflow context to action inputs
	OnSuccess string            // Next step ID on success
	OnFailure string            // Next step ID on failure
}

// Workflow represents a multi-step orchestration.
type Workflow struct {
	ID          string
	Name        string
	Description string
	TriggerType string // event, schedule, manual
	TriggerData map[string]string
	Steps       []WorkflowStep
}

{{range .Workflows}}
{{- $workflow := . -}}
// {{.PascalName}}Workflow executes the {{.Name}} workflow.
type {{.PascalName}}Workflow struct {
	executor *WorkflowExecutor
}

// New{{.PascalName}}Workflow creates a new {{.Name}} workflow instance.
func New{{.PascalName}}Workflow(executor *WorkflowExecutor) *{{.PascalName}}Workflow {
	return &{{.PascalName}}Workflow{
		executor: executor,
	}
}

// Execute runs the {{.Name}} workflow.
func (w *{{.PascalName}}Workflow) Execute(ctx context.Context, triggerData map[string]any) error {
	wfCtx := &WorkflowContext{
		Data:      triggerData,
		TriggerID: "{{.ID}}",
		StartedAt: time.Now(),
	}

	log.Printf("Starting workflow: {{.Name}}")
	
	{{range .Steps}}
	// Step: {{.ID}} ({{.Type}})
	if err := w.execute{{.PascalName}}(ctx, wfCtx); err != nil {
		log.Printf("Workflow {{$workflow.Name}} failed at step {{.ID}}: %v", err)
		{{if .OnFailure}}
		// Note: Failure step execution ({{.OnFailure}}) not yet implemented
		// For now, the workflow returns an error on any step failure
		{{end}}
		return fmt.Errorf("step {{.ID}} failed: %w", err)
	}
	{{end}}

	log.Printf("Workflow {{.Name}} completed successfully")
	return nil
}

{{range .Steps}}
func (w *{{$workflow.PascalName}}Workflow) execute{{.PascalName}}(ctx context.Context, wfCtx *WorkflowContext) error {
	{{if eq .Type "action"}}
	// Execute action: {{.Entity}}.{{.Action}}
	handlerKey := "{{.Entity}}.{{.Action}}"
	handler, exists := w.executor.handlers[handlerKey]
	if !exists {
		return fmt.Errorf("handler not found: %s", handlerKey)
	}

	// Map workflow context to action inputs
	input := make(map[string]any)
	{{range $k, $v := .Input}}
	if val, ok := wfCtx.Data["{{$v}}"]; ok {
		input["{{$k}}"] = val
	}
	{{end}}

	return handler(ctx, input)
	{{else if eq .Type "condition"}}
	// Evaluate condition: {{.Condition}}
	result, err := dsl.Evaluate("{{.Condition}}", wfCtx.Data, nil)
	if err != nil {
		return fmt.Errorf("condition evaluation failed: %w", err)
	}
	if !result {
		return fmt.Errorf("condition not met: {{.Condition}}")
	}
	return nil
	{{else if eq .Type "wait"}}
	// Wait step{{if .Duration}} - duration: {{.Duration}}{{end}}
	{{if .Duration}}
	duration, err := time.ParseDuration("{{.Duration}}")
	if err != nil {
		return fmt.Errorf("invalid duration '{{.Duration}}': %w", err)
	}
	log.Printf("Waiting for %v", duration)
	time.Sleep(duration)
	{{else}}
	// No duration specified, default to 1 second
	time.Sleep(1 * time.Second)
	{{end}}
	return nil
	{{else}}
	return fmt.Errorf("unknown step type: {{.Type}}")
	{{end}}
}
{{end}}

{{end}}

// WorkflowRegistry manages all workflows.
type WorkflowRegistry struct {
	executor  *WorkflowExecutor
	workflows map[string]*Workflow
	{{range .Workflows}}
	{{.CamelName}} *{{.PascalName}}Workflow
	{{end}}
}

// NewWorkflowRegistry creates a new workflow registry.
func NewWorkflowRegistry(executor *WorkflowExecutor) *WorkflowRegistry {
	registry := &WorkflowRegistry{
		executor:  executor,
		workflows: make(map[string]*Workflow),
		{{range .Workflows}}
		{{.CamelName}}: New{{.PascalName}}Workflow(executor),
		{{end}}
	}

	// Register workflows
	{{range .Workflows}}
	registry.workflows["{{.ID}}"] = &Workflow{
		ID:          "{{.ID}}",
		Name:        "{{.Name}}",
		Description: "{{.Description}}",
		TriggerType: "{{.TriggerType}}",
	}
	{{end}}

	return registry
}

// Execute runs a workflow by ID.
func (r *WorkflowRegistry) Execute(ctx context.Context, workflowID string, triggerData map[string]any) error {
	switch workflowID {
	{{range .Workflows}}
	case "{{.ID}}":
		return r.{{.CamelName}}.Execute(ctx, triggerData)
	{{end}}
	default:
		return fmt.Errorf("unknown workflow: %s", workflowID)
	}
}

// OnEvent handles workflow triggers from events.
func (r *WorkflowRegistry) OnEvent(ctx context.Context, entity string, action string, data map[string]any) error {
	// Check for event-triggered workflows
	{{range .Workflows}}
	{{if eq .TriggerType "event"}}
	if "{{.Trigger.Entity}}" == entity && "{{.Trigger.Action}}" == action {
		log.Printf("Triggering workflow {{.ID}} on event %s.%s", entity, action)
		if err := r.{{.CamelName}}.Execute(ctx, data); err != nil {
			log.Printf("Workflow {{.ID}} failed: %v", err)
			return err
		}
	}
	{{end}}
	{{end}}

	return nil
}
{{end}}
