// Generated by petri-pilot. DO NOT EDIT.

// API client
const API_BASE = ''  // Uses Vite proxy in development

// Auth state
let currentUser = null
let authToken = null

// Load auth from localStorage
function loadAuth() {
  const stored = localStorage.getItem('auth')
  if (stored) {
    try {
      const auth = JSON.parse(stored)
      if (auth.expires_at && new Date(auth.expires_at) > new Date()) {
        authToken = auth.token
        currentUser = auth.user
        return true
      }
      localStorage.removeItem('auth')
    } catch (e) {
      localStorage.removeItem('auth')
    }
  }
  return false
}

// Save auth to localStorage
function saveAuth(data) {
  localStorage.setItem('auth', JSON.stringify(data))
  authToken = data.token
  currentUser = data.user
}

// Clear auth
function clearAuth() {
  localStorage.removeItem('auth')
  authToken = null
  currentUser = null
}

// API helpers
function getHeaders() {
  const headers = { 'Content-Type': 'application/json' }
  if (authToken) {
    headers['Authorization'] = `Bearer ${authToken}`
  }
  return headers
}

async function handleResponse(response) {
  if (response.status === 401) {
    clearAuth()
    renderAuth()
    throw new Error('Session expired. Please log in again.')
  }
  if (!response.ok) {
    const error = await response.json().catch(() => ({}))
    throw new Error(error.message || response.statusText)
  }
  return response.json()
}

const api = {
  // Auth endpoints
  async getMe() {
    const response = await fetch(`${API_BASE}/auth/me`, {
      headers: getHeaders(),
    })
    return handleResponse(response)
  },

  async logout() {
    await fetch(`${API_BASE}/auth/logout`, {
      method: 'POST',
      headers: getHeaders(),
    })
    clearAuth()
  },

  // Workflow endpoints
  async create() {
    const response = await fetch(`${API_BASE}/api/{{.ProjectName}}`, {
      method: 'POST',
      headers: getHeaders(),
    })
    return handleResponse(response)
  },

  async getState(id) {
    const response = await fetch(`${API_BASE}/api/{{.ProjectName}}/${id}`, {
      headers: getHeaders(),
    })
    return handleResponse(response)
  },

  async executeTransition(transitionId, aggregateId) {
    const response = await fetch(`${API_BASE}/api/{{.ProjectName}}/transitions/${transitionId}`, {
      method: 'POST',
      headers: getHeaders(),
      body: JSON.stringify({ aggregate_id: aggregateId }),
    })
    return handleResponse(response)
  },
}

// UI state
let currentState = null
let aggregateId = null

// DOM elements
const errorEl = document.getElementById('error')
const authSection = document.getElementById('auth-section')
const loginBtn = document.getElementById('login-btn')
const logoutBtn = document.getElementById('logout-btn')
const userInfo = document.getElementById('user-info')
const aggregateInput = document.getElementById('aggregate-id')
const loadBtn = document.getElementById('load-btn')
const createBtn = document.getElementById('create-btn')
const stateSection = document.getElementById('state-section')
const actionsSection = document.getElementById('actions-section')
const displayId = document.getElementById('display-id')
const displayVersion = document.getElementById('display-version')
const placesGrid = document.getElementById('places-grid')
const enabledList = document.getElementById('enabled-list')
const transitionsGrid = document.getElementById('transitions-grid')

// Transitions metadata
const transitions = [
{{- range .Transitions}}
  { id: '{{.ID}}', name: '{{.DisplayName}}', description: '{{.Description}}' },
{{- end}}
]

// Show/hide error
function showError(message) {
  errorEl.textContent = message
  errorEl.style.display = 'block'
}

function hideError() {
  errorEl.style.display = 'none'
}

// Render auth state
function renderAuth() {
  if (currentUser) {
    loginBtn.style.display = 'none'
    logoutBtn.style.display = 'inline-block'
    userInfo.textContent = currentUser.login || currentUser.name || 'User'
    userInfo.style.display = 'inline'
  } else {
    loginBtn.style.display = 'inline-block'
    logoutBtn.style.display = 'none'
    userInfo.style.display = 'none'
  }
}

// Render current state
function renderState() {
  if (!currentState) {
    stateSection.style.display = 'none'
    actionsSection.style.display = 'none'
    return
  }

  stateSection.style.display = 'block'
  actionsSection.style.display = 'block'

  displayId.textContent = aggregateId
  displayVersion.textContent = currentState.version || 0

  // Render places
  placesGrid.innerHTML = ''
  const places = currentState.places || currentState.marking || {}
  for (const [placeId, tokens] of Object.entries(places)) {
    const placeEl = document.createElement('div')
    placeEl.className = `place ${tokens > 0 ? 'active' : 'inactive'}`
    placeEl.innerHTML = `
      <span class="token-count">${tokens}</span>
      <span>${placeId}</span>
    `
    placesGrid.appendChild(placeEl)
  }

  // Render enabled transitions
  enabledList.innerHTML = ''
  const enabled = currentState.enabled || []
  for (const transitionId of enabled) {
    const tag = document.createElement('span')
    tag.className = 'enabled-tag'
    tag.textContent = transitionId
    enabledList.appendChild(tag)
  }
  if (enabled.length === 0) {
    enabledList.innerHTML = '<span style="color: #666;">No transitions enabled</span>'
  }

  // Render transition cards
  transitionsGrid.innerHTML = ''
  for (const t of transitions) {
    const isEnabled = enabled.includes(t.id)
    const card = document.createElement('div')
    card.className = `transition-card ${isEnabled ? '' : 'disabled'}`
    card.innerHTML = `
      <div class="transition-title">${t.name}</div>
      ${t.description ? `<div class="transition-desc">${t.description}</div>` : ''}
      <button ${isEnabled ? '' : 'disabled'} data-transition="${t.id}">
        Execute
      </button>
    `
    transitionsGrid.appendChild(card)
  }
}

// Load state
async function loadState() {
  hideError()
  const id = aggregateInput.value.trim()
  if (!id) {
    showError('Please enter an aggregate ID')
    return
  }

  try {
    aggregateId = id
    currentState = await api.getState(id)
    renderState()
  } catch (err) {
    showError(`Failed to load: ${err.message}`)
    currentState = null
    renderState()
  }
}

// Create new instance
async function createNew() {
  hideError()
  try {
    const result = await api.create()
    aggregateId = result.aggregate_id || result.id
    aggregateInput.value = aggregateId
    currentState = result.state || result
    renderState()
  } catch (err) {
    showError(`Failed to create: ${err.message}`)
  }
}

// Execute transition
async function executeTransition(transitionId) {
  hideError()
  if (!aggregateId) {
    showError('No aggregate loaded')
    return
  }

  try {
    const result = await api.executeTransition(transitionId, aggregateId)
    currentState = result.state || result
    renderState()
  } catch (err) {
    showError(`Failed to execute ${transitionId}: ${err.message}`)
  }
}

// Login with GitHub
function login() {
  window.location.href = `${API_BASE}/auth/login`
}

// Logout
async function logout() {
  try {
    await api.logout()
  } catch (err) {
    console.error('Logout error:', err)
  }
  clearAuth()
  renderAuth()
}

// Handle OAuth callback
async function handleCallback() {
  const params = new URLSearchParams(window.location.search)
  const token = params.get('token')
  const expiresAt = params.get('expires_at')

  if (token) {
    // Token returned directly in URL (simplified flow)
    authToken = token
    try {
      const user = await api.getMe()
      saveAuth({ token, expires_at: expiresAt, user })
      window.history.replaceState({}, '', window.location.pathname)
      renderAuth()
    } catch (err) {
      clearAuth()
      showError('Failed to complete login')
    }
  }
}

// Event handlers
loginBtn.addEventListener('click', login)
logoutBtn.addEventListener('click', logout)
loadBtn.addEventListener('click', loadState)
createBtn.addEventListener('click', createNew)

aggregateInput.addEventListener('keypress', (e) => {
  if (e.key === 'Enter') loadState()
})

transitionsGrid.addEventListener('click', (e) => {
  const btn = e.target.closest('button[data-transition]')
  if (btn && !btn.disabled) {
    executeTransition(btn.dataset.transition)
  }
})

// Initialize
loadAuth()
handleCallback()
renderAuth()
renderState()
