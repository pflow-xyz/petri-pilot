// Code generated by petri-pilot. DO NOT EDIT.
// Blob storage helpers for {{.ModelName}}

/**
 * Upload a blob to the server.
 * @param {string|Blob|ArrayBuffer|object} data - The data to upload
 * @param {string} [contentType='application/json'] - The content type
 * @param {Object} [metadata] - Optional metadata (sent as X-Blob-* headers)
 * @returns {Promise<{id: string, ownerId: string, size: number, contentType: string}>}
 */
export async function uploadBlob(data, contentType = 'application/json', metadata = null) {
    let body;
    if (typeof data === 'object' && !(data instanceof Blob) && !(data instanceof ArrayBuffer)) {
        body = JSON.stringify(data);
    } else {
        body = data;
    }

    const headers = {
        'Content-Type': contentType
    };

    // Add metadata as X-Blob-* headers
    if (metadata) {
        for (const [key, value] of Object.entries(metadata)) {
            headers[`X-Blob-${key}`] = value;
        }
    }

    const response = await fetch('/api/blobs', {
        method: 'POST',
        headers,
        body,
        credentials: 'include'
    });

    if (!response.ok) {
        const error = await response.json();
        throw new Error(error.message || 'Upload failed');
    }

    return response.json();
}

/**
 * Get blob data by ID.
 * @param {string} id - The blob ID
 * @returns {Promise<Response>} The fetch response (use .blob(), .json(), etc. to read)
 */
export async function getBlob(id) {
    const response = await fetch(`/api/blobs/${id}`, {
        credentials: 'include'
    });

    if (!response.ok) {
        const error = await response.json();
        throw new Error(error.message || 'Blob not found');
    }

    return response;
}

/**
 * Get blob metadata by ID.
 * @param {string} id - The blob ID
 * @returns {Promise<{id: string, ownerId: string, size: number, contentType: string, createdAt: string, updatedAt: string}>}
 */
export async function getBlobMeta(id) {
    const response = await fetch(`/api/blobs/${id}/meta`, {
        credentials: 'include'
    });

    if (!response.ok) {
        const error = await response.json();
        throw new Error(error.message || 'Blob not found');
    }

    return response.json();
}

/**
 * List blobs owned by the current user.
 * @param {string} [owner] - Optional owner ID (admin only)
 * @returns {Promise<{blobs: Array<{id: string, ownerId: string, size: number, contentType: string, createdAt: string, updatedAt: string}>}>}
 */
export async function listBlobs(owner = null) {
    const url = owner ? `/api/blobs?owner=${encodeURIComponent(owner)}` : '/api/blobs';
    const response = await fetch(url, {
        credentials: 'include'
    });

    if (!response.ok) {
        const error = await response.json();
        throw new Error(error.message || 'Failed to list blobs');
    }

    return response.json();
}

/**
 * Transfer blob ownership to another user.
 * @param {string} id - The blob ID
 * @param {string} newOwnerId - The new owner's user ID
 * @returns {Promise<{success: boolean, ownerId: string}>}
 */
export async function transferBlob(id, newOwnerId) {
    const response = await fetch(`/api/blobs/${id}`, {
        method: 'PATCH',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({ ownerId: newOwnerId }),
        credentials: 'include'
    });

    if (!response.ok) {
        const error = await response.json();
        throw new Error(error.message || 'Transfer failed');
    }

    return response.json();
}

/**
 * Delete a blob.
 * @param {string} id - The blob ID
 * @returns {Promise<{success: boolean}>}
 */
export async function deleteBlob(id) {
    const response = await fetch(`/api/blobs/${id}`, {
        method: 'DELETE',
        credentials: 'include'
    });

    if (!response.ok) {
        const error = await response.json();
        throw new Error(error.message || 'Delete failed');
    }

    return response.json();
}

/**
 * Upload a JSON document as a blob.
 * Convenience wrapper for uploadBlob with application/json content type.
 * @param {object} data - The JSON data to upload
 * @param {Object} [metadata] - Optional metadata
 * @returns {Promise<{id: string, ownerId: string, size: number, contentType: string}>}
 */
export async function uploadJSON(data, metadata = null) {
    return uploadBlob(data, 'application/json', metadata);
}

/**
 * Upload a file as a blob.
 * @param {File} file - The file to upload
 * @param {Object} [metadata] - Optional metadata
 * @returns {Promise<{id: string, ownerId: string, size: number, contentType: string}>}
 */
export async function uploadFile(file, metadata = null) {
    const fileMetadata = {
        ...metadata,
        filename: file.name,
        'last-modified': file.lastModified.toString()
    };
    return uploadBlob(file, file.type || 'application/octet-stream', fileMetadata);
}

/**
 * Download a blob as a file.
 * @param {string} id - The blob ID
 * @param {string} [filename] - Optional filename for the download
 */
export async function downloadBlob(id, filename = null) {
    const response = await getBlob(id);
    const blob = await response.blob();

    // Create download link
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename || id;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}

/**
 * Get blob data as JSON.
 * @param {string} id - The blob ID
 * @returns {Promise<any>} The parsed JSON data
 */
export async function getBlobJSON(id) {
    const response = await getBlob(id);
    return response.json();
}

// Export all blob functions as a namespace
export const blobs = {
    upload: uploadBlob,
    get: getBlob,
    getMeta: getBlobMeta,
    list: listBlobs,
    transfer: transferBlob,
    delete: deleteBlob,
    uploadJSON,
    uploadFile,
    download: downloadBlob,
    getJSON: getBlobJSON
};
