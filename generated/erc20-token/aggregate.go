// Code generated by petri-pilot. DO NOT EDIT.

package main

import (
	"context"
	"encoding/json"
	"fmt"
	"time"

	"github.com/google/uuid"
	"github.com/pflow-xyz/petri-pilot/pkg/dsl"
	"github.com/pflow-xyz/petri-pilot/pkg/metamodel"
	"github.com/pflow-xyz/petri-pilot/pkg/runtime"
	"github.com/pflow-xyz/petri-pilot/pkg/runtime/aggregate"
	"github.com/pflow-xyz/petri-pilot/pkg/runtime/eventstore"
)

// State holds the aggregate state for erc20-token.
type State struct {
	TotalSupply *U256 `json:"total_supply,omitempty"`
	Balances map[string]*U256 `json:"balances,omitempty"`
	Allowances map[string]map[string]*U256 `json:"allowances,omitempty"`
}

// NewState creates a new State with initialized collections.
func NewState() State {
	return State{
		TotalSupply: U256Zero(),
		Balances: make(map[string]*U256),
		Allowances: make(map[string]map[string]*U256),
	}
}

// Bindings holds parameters for action execution.
// Contains all unique fields across all event types.
type Bindings struct {
	AggregateID string    `json:"aggregate_id"`
	Timestamp   time.Time `json:"timestamp"`
	From        string    `json:"from,omitempty"`
	To          string    `json:"to,omitempty"`
	Owner       string    `json:"owner,omitempty"`
	Spender     string    `json:"spender,omitempty"`
	Caller      string    `json:"caller,omitempty"`
	Amount      U256JSON  `json:"amount,omitempty"`
}

// ToMetamodel converts Bindings to metamodel.Bindings.
func (b *Bindings) ToMetamodel() metamodel.Bindings {
	var amount int64
	if b.Amount.U256 != nil {
		// Convert to int64 for guard evaluation (may overflow for large values)
		amount = int64(b.Amount.U256.Uint64())
	}
	return metamodel.Bindings{
		"aggregate_id": b.AggregateID,
		"from":         b.From,
		"to":           b.To,
		"owner":        b.Owner,
		"spender":      b.Spender,
		"caller":       b.Caller,
		"amount":       amount,
	}
}

// Aggregate wraps a StateMachine with the erc20-token state.
type Aggregate struct {
	sm *aggregate.StateMachine[State]
	rt *metamodel.Runtime // Runtime for guard evaluation
}

// NewAggregate creates a new aggregate with initial state.
func NewAggregate(id string) *Aggregate {
	if id == "" {
		id = uuid.New().String()
	}
	sm := aggregate.NewStateMachine(id, NewState(), InitialPlaces())

	// Register transitions with their input/output places
	sm.AddTransition(aggregate.Transition{
		ID:        TransitionTransfer,
		EventType: EventTypeTransfer,
		Inputs: map[string]int{
			PlaceBalances: 1,
		},
		Outputs: map[string]int{
			PlaceBalances: 1,
		},
	})
	sm.AddTransition(aggregate.Transition{
		ID:        TransitionApprove,
		EventType: EventTypeApprove,
		Inputs: map[string]int{
		},
		Outputs: map[string]int{
			PlaceAllowances: 1,
		},
	})
	sm.AddTransition(aggregate.Transition{
		ID:        TransitionTransferFrom,
		EventType: EventTypeTransferFrom,
		Inputs: map[string]int{
			PlaceBalances: 1,
			PlaceAllowances: 1,
		},
		Outputs: map[string]int{
			PlaceBalances: 1,
		},
	})
	sm.AddTransition(aggregate.Transition{
		ID:        TransitionMint,
		EventType: EventTypeMint,
		Inputs: map[string]int{
		},
		Outputs: map[string]int{
			PlaceBalances: 1,
			PlaceTotalSupply: 1,
		},
	})
	sm.AddTransition(aggregate.Transition{
		ID:        TransitionBurn,
		EventType: EventTypeBurn,
		Inputs: map[string]int{
			PlaceBalances: 1,
			PlaceTotalSupply: 1,
		},
		Outputs: map[string]int{
		},
	})

	// Register event handlers for state updates
	sm.RegisterHandler(EventTypeTransfer, func(state *State, event *runtime.Event) error {
		return applyTransfer(state, event)
	})
	sm.RegisterHandler(EventTypeApprove, func(state *State, event *runtime.Event) error {
		return applyApprove(state, event)
	})
	sm.RegisterHandler(EventTypeTransferFrom, func(state *State, event *runtime.Event) error {
		return applyTransferFrom(state, event)
	})
	sm.RegisterHandler(EventTypeMint, func(state *State, event *runtime.Event) error {
		return applyMint(state, event)
	})
	sm.RegisterHandler(EventTypeBurn, func(state *State, event *runtime.Event) error {
		return applyBurn(state, event)
	})
	// Create metamodel runtime for guard evaluation
	schema := buildSchema()
	rt := metamodel.NewRuntime(schema)
	rt.GuardEvaluator = &guardEval{}

	return &Aggregate{sm: sm, rt: rt}
}

// ID returns the aggregate identifier.
func (a *Aggregate) ID() string {
	return a.sm.ID()
}

// Version returns the current event version.
func (a *Aggregate) Version() int {
	return a.sm.Version()
}

// State returns the current state.
func (a *Aggregate) State() any {
	return a.sm.State()
}

// Places returns current token distribution.
func (a *Aggregate) Places() map[string]int {
	places := make(map[string]int)
	for _, p := range AllPlaces() {
		places[p] = a.sm.Tokens(p)
	}
	return places
}

// EnabledTransitions returns transitions that can fire.
func (a *Aggregate) EnabledTransitions() []string {
	return a.sm.EnabledTransitions()
}

// CanFire checks if a transition can fire.
func (a *Aggregate) CanFire(transitionID string) bool {
	return a.sm.CanFire(transitionID)
}

// CheckGuard evaluates a guard condition with the given bindings.
func (a *Aggregate) CheckGuard(transitionID string, bindings *Bindings) (bool, error) {
	if transitionID == "transfer" {
		return a.evaluateGuardTransfer(bindings)
	}
	if transitionID == "transfer_from" {
		return a.evaluateGuardTransferFrom(bindings)
	}
	if transitionID == "burn" {
		return a.evaluateGuardBurn(bindings)
	}
	return true, nil // No guard for this transition
}

func (a *Aggregate) evaluateGuardTransfer(bindings *Bindings) (bool, error) {
	// Guard: balances[from] >= amount
	state := a.sm.TypedState()
	mb := bindings.ToMetamodel()

	// Add state data to bindings for evaluation
	mb["balances"] = state.Balances

	return dsl.Evaluate("balances[from] >= amount", mb, nil)
}

func (a *Aggregate) evaluateGuardTransferFrom(bindings *Bindings) (bool, error) {
	// Guard: balances[from] >= amount && allowances[from][caller] >= amount
	state := a.sm.TypedState()
	mb := bindings.ToMetamodel()

	// Add state data to bindings for evaluation
	mb["balances"] = state.Balances
	mb["allowances"] = state.Allowances

	return dsl.Evaluate("balances[from] >= amount && allowances[from][caller] >= amount", mb, nil)
}

func (a *Aggregate) evaluateGuardBurn(bindings *Bindings) (bool, error) {
	// Guard: balances[from] >= amount
	state := a.sm.TypedState()
	mb := bindings.ToMetamodel()

	// Add state data to bindings for evaluation
	mb["balances"] = state.Balances

	return dsl.Evaluate("balances[from] >= amount", mb, nil)
}

// Fire executes a transition and returns the resulting event.
func (a *Aggregate) Fire(transitionID string, data any) (*runtime.Event, error) {
	// Check guard if bindings are provided
	if bindings, ok := data.(*Bindings); ok {
		passed, err := a.CheckGuard(transitionID, bindings)
		if err != nil {
			return nil, fmt.Errorf("guard evaluation failed: %w", err)
		}
		if !passed {
			return nil, fmt.Errorf("guard condition not satisfied for %s", transitionID)
		}
	}
	return a.sm.Fire(transitionID, data)
}

// Apply applies an event to update the aggregate state.
func (a *Aggregate) Apply(event *runtime.Event) error {
	// Update state machine (this calls the registered handlers)
	return a.sm.Apply(event)
}

// Event application functions

func applyTransfer(state *State, event *runtime.Event) error {
	// Unmarshal event data to get bindings
	var bindings Bindings
	if err := json.Unmarshal(event.Data, &bindings); err != nil {
		return fmt.Errorf("unmarshaling event data: %w", err)
	}
	amount := bindings.Amount.U256
	if amount == nil {
		amount = U256Zero()
	}
	// Subtract from Balances
	if state.Balances[bindings.From] == nil {
		state.Balances[bindings.From] = U256Zero()
	}
	newFromBalance, err := SafeSub(state.Balances[bindings.From], amount)
	if err != nil {
		return fmt.Errorf("subtracting from balance: %w", err)
	}
	state.Balances[bindings.From] = newFromBalance
	// Add to Balances
	if state.Balances[bindings.To] == nil {
		state.Balances[bindings.To] = U256Zero()
	}
	newToBalance, err := SafeAdd(state.Balances[bindings.To], amount)
	if err != nil {
		return fmt.Errorf("adding to balance: %w", err)
	}
	state.Balances[bindings.To] = newToBalance
	return nil
}

func applyApprove(state *State, event *runtime.Event) error {
	// Unmarshal event data to get bindings
	var bindings Bindings
	if err := json.Unmarshal(event.Data, &bindings); err != nil {
		return fmt.Errorf("unmarshaling event data: %w", err)
	}
	amount := bindings.Amount.U256
	if amount == nil {
		amount = U256Zero()
	}
	// Set Allowances at key from binding (non-numeric map)
	if state.Allowances[bindings.Owner] == nil {
		state.Allowances[bindings.Owner] = make(map[string]*U256)
	}
	state.Allowances[bindings.Owner][bindings.Spender] = amount.Clone()
	return nil
}

func applyTransferFrom(state *State, event *runtime.Event) error {
	// Unmarshal event data to get bindings
	var bindings Bindings
	if err := json.Unmarshal(event.Data, &bindings); err != nil {
		return fmt.Errorf("unmarshaling event data: %w", err)
	}
	amount := bindings.Amount.U256
	if amount == nil {
		amount = U256Zero()
	}
	// Subtract from Balances
	if state.Balances[bindings.From] == nil {
		state.Balances[bindings.From] = U256Zero()
	}
	newFromBalance, err := SafeSub(state.Balances[bindings.From], amount)
	if err != nil {
		return fmt.Errorf("subtracting from balance: %w", err)
	}
	state.Balances[bindings.From] = newFromBalance
	// Subtract from Allowances
	if state.Allowances[bindings.From] != nil && state.Allowances[bindings.From][bindings.Caller] != nil {
		newAllowance, err := SafeSub(state.Allowances[bindings.From][bindings.Caller], amount)
		if err != nil {
			return fmt.Errorf("subtracting from allowance: %w", err)
		}
		state.Allowances[bindings.From][bindings.Caller] = newAllowance
	}
	// Add to Balances
	if state.Balances[bindings.To] == nil {
		state.Balances[bindings.To] = U256Zero()
	}
	newToBalance, err := SafeAdd(state.Balances[bindings.To], amount)
	if err != nil {
		return fmt.Errorf("adding to balance: %w", err)
	}
	state.Balances[bindings.To] = newToBalance
	return nil
}

func applyMint(state *State, event *runtime.Event) error {
	// Unmarshal event data to get bindings
	var bindings Bindings
	if err := json.Unmarshal(event.Data, &bindings); err != nil {
		return fmt.Errorf("unmarshaling event data: %w", err)
	}
	amount := bindings.Amount.U256
	if amount == nil {
		amount = U256Zero()
	}
	// Add to Balances
	if state.Balances[bindings.To] == nil {
		state.Balances[bindings.To] = U256Zero()
	}
	newBalance, err := SafeAdd(state.Balances[bindings.To], amount)
	if err != nil {
		return fmt.Errorf("adding to balance: %w", err)
	}
	state.Balances[bindings.To] = newBalance
	// Add to TotalSupply
	if state.TotalSupply == nil {
		state.TotalSupply = U256Zero()
	}
	newSupply, err := SafeAdd(state.TotalSupply, amount)
	if err != nil {
		return fmt.Errorf("adding to total supply: %w", err)
	}
	state.TotalSupply = newSupply
	return nil
}

func applyBurn(state *State, event *runtime.Event) error {
	// Unmarshal event data to get bindings
	var bindings Bindings
	if err := json.Unmarshal(event.Data, &bindings); err != nil {
		return fmt.Errorf("unmarshaling event data: %w", err)
	}
	amount := bindings.Amount.U256
	if amount == nil {
		amount = U256Zero()
	}
	// Subtract from Balances
	if state.Balances[bindings.From] == nil {
		state.Balances[bindings.From] = U256Zero()
	}
	newBalance, err := SafeSub(state.Balances[bindings.From], amount)
	if err != nil {
		return fmt.Errorf("subtracting from balance: %w", err)
	}
	state.Balances[bindings.From] = newBalance
	// Subtract from TotalSupply
	if state.TotalSupply == nil {
		state.TotalSupply = U256Zero()
	}
	newSupply, err := SafeSub(state.TotalSupply, amount)
	if err != nil {
		return fmt.Errorf("subtracting from total supply: %w", err)
	}
	state.TotalSupply = newSupply
	return nil
}

// buildSchema creates the metamodel schema for this model.
func buildSchema() *metamodel.Schema {
	s := metamodel.NewSchema("erc20-token")

	// Add states (places)
	s.AddDataState("total_supply", "int64", nil, false)
	s.AddDataState("balances", "map[string]int64", nil, true)
	s.AddDataState("allowances", "map[string]map[string]int64", nil, true)

	// Add actions (transitions)
	s.AddAction(metamodel.Action{
		ID:    "transfer",
		Guard: "balances[from] >= amount",
	})
	s.AddAction(metamodel.Action{
		ID:    "approve",
		Guard: "",
	})
	s.AddAction(metamodel.Action{
		ID:    "transfer_from",
		Guard: "balances[from] >= amount && allowances[from][caller] >= amount",
	})
	s.AddAction(metamodel.Action{
		ID:    "mint",
		Guard: "",
	})
	s.AddAction(metamodel.Action{
		ID:    "burn",
		Guard: "balances[from] >= amount",
	})

	// Add arcs
	s.AddArc(metamodel.Arc{
		Source: "balances",
		Target: "transfer",
		Keys:   []string{"from" },
		Value:  "amount",
	})
	s.AddArc(metamodel.Arc{
		Source: "transfer",
		Target: "balances",
		Keys:   []string{"to" },
		Value:  "amount",
	})
	s.AddArc(metamodel.Arc{
		Source: "approve",
		Target: "allowances",
		Keys:   []string{"owner", "spender" },
		Value:  "amount",
	})
	s.AddArc(metamodel.Arc{
		Source: "balances",
		Target: "transfer_from",
		Keys:   []string{"from" },
		Value:  "amount",
	})
	s.AddArc(metamodel.Arc{
		Source: "allowances",
		Target: "transfer_from",
		Keys:   []string{"from", "caller" },
		Value:  "amount",
	})
	s.AddArc(metamodel.Arc{
		Source: "transfer_from",
		Target: "balances",
		Keys:   []string{"to" },
		Value:  "amount",
	})
	s.AddArc(metamodel.Arc{
		Source: "mint",
		Target: "balances",
		Keys:   []string{"to" },
		Value:  "amount",
	})
	s.AddArc(metamodel.Arc{
		Source: "mint",
		Target: "total_supply",
		Value:  "amount",
	})
	s.AddArc(metamodel.Arc{
		Source: "balances",
		Target: "burn",
		Keys:   []string{"from" },
		Value:  "amount",
	})
	s.AddArc(metamodel.Arc{
		Source: "total_supply",
		Target: "burn",
		Value:  "amount",
	})

	return s
}

// guardEval implements metamodel.GuardEvaluator.
type guardEval struct{}

func (g *guardEval) Evaluate(expr string, bindings metamodel.Bindings, funcs map[string]metamodel.GuardFunc) (bool, error) {
	// Convert metamodel.GuardFunc to dsl.GuardFunc
	dslFuncs := make(map[string]dsl.GuardFunc)
	for k, f := range funcs {
		f := f
		dslFuncs[k] = func(args ...any) (any, error) {
			return f(args...)
		}
	}
	bindingsMap := make(map[string]any, len(bindings))
	for k, v := range bindings {
		bindingsMap[k] = v
	}
	return dsl.Evaluate(expr, bindingsMap, dslFuncs)
}

func (g *guardEval) EvaluateConstraint(expr string, tokens map[string]int) (bool, error) {
	marking := make(dsl.Marking, len(tokens))
	for k, v := range tokens {
		marking[k] = v
	}
	return dsl.EvaluateInvariant(expr, marking)
}

// Application wires together the aggregate and event store.
type Application struct {
	store eventstore.Store
}

// NewApplication creates a new application instance.
func NewApplication(store eventstore.Store) *Application {
	return &Application{store: store}
}

// Create creates a new aggregate and returns its ID.
func (app *Application) Create(ctx context.Context) (string, error) {
	agg := NewAggregate("")
	return agg.ID(), nil
}

// Load loads an aggregate from the event store.
func (app *Application) Load(ctx context.Context, id string) (*Aggregate, error) {
	events, err := app.store.Read(ctx, id, 0)
	if err != nil {
		return nil, fmt.Errorf("reading events: %w", err)
	}

	agg := NewAggregate(id)
	for _, event := range events {
		if err := agg.Apply(event); err != nil {
			return nil, fmt.Errorf("applying event %s: %w", event.ID, err)
		}
	}

	return agg, nil
}

// Execute fires a transition on an aggregate and persists the event.
func (app *Application) Execute(ctx context.Context, id, transitionID string, data any) (*Aggregate, error) {
	// Load current state
	agg, err := app.Load(ctx, id)
	if err != nil {
		return nil, err
	}

	// Check if transition can fire
	if !agg.CanFire(transitionID) {
		return nil, fmt.Errorf("transition %s cannot fire from current state", transitionID)
	}

	// Fire transition (this updates token counts but not version)
	event, err := agg.Fire(transitionID, data)
	if err != nil {
		return nil, fmt.Errorf("firing transition: %w", err)
	}

	// Persist event (this assigns the event version)
	// The expected version should match the current stream version (-1 for new streams)
	_, err = app.store.Append(ctx, id, agg.Version(), []*runtime.Event{event})
	if err != nil {
		return nil, fmt.Errorf("persisting event: %w", err)
	}

	// Apply the event to update the aggregate's version
	if err := agg.Apply(event); err != nil {
		return nil, fmt.Errorf("applying event: %w", err)
	}

	return agg, nil
}

// GetState returns the current state of an aggregate.
func (app *Application) GetState(ctx context.Context, id string) (*Aggregate, error) {
	return app.Load(ctx, id)
}

// HealthCheck verifies the event store is accessible.
func (app *Application) HealthCheck(ctx context.Context) error {
	// Try to read from a non-existent stream - this exercises the store connection
	_, err := app.store.Read(ctx, "__health_check__", 0)
	// Ignore "not found" errors - we just want to verify connectivity
	if err != nil && err.Error() != "stream not found" {
		return err
	}
	return nil
}

// Helper to unmarshal event data
func unmarshalEventData[T any](event *runtime.Event) (*T, error) {
	var data T
	if err := json.Unmarshal(event.Data, &data); err != nil {
		return nil, err
	}
	return &data, nil
}
