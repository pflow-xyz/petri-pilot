// Code generated by petri-pilot. DO NOT EDIT.

package main

import (
	"net/http"

	"github.com/pflow-xyz/petri-pilot/pkg/runtime/api"
)

// BuildRouter creates an HTTP router for the order-processing workflow.
func BuildRouter(app *Application, middleware *Middleware) http.Handler {
	r := api.NewRouter()

	// Health check - always returns ok if server is running
	r.GET("/health", "Health check", func(w http.ResponseWriter, r *http.Request) {
		api.JSON(w, http.StatusOK, map[string]string{"status": "ok"})
	})

	// Readiness check - verifies dependencies (database, etc.)
	r.GET("/ready", "Readiness check", HandleReady(app))

	// Create new aggregate
	r.POST("/api/orderprocessing", "Create new order-processing", HandleCreate(app))

	// Get aggregate state
	r.GET("/api/orderprocessing/{id}", "Get order-processing state", HandleGetState(app))

	// View definitions
	r.GET("/api/views", "Get view definitions", HandleGetViews())





	// Transition endpoints
	r.Transition("validate", "/api/validate", "Check order validity", middleware.RequirePermission("validate")(HandleValidate(app)))
	r.Transition("reject", "/api/reject", "Mark order as invalid", middleware.RequirePermission("reject")(HandleReject(app)))
	r.Transition("process_payment", "/api/process_payment", "Charge customer payment", middleware.RequirePermission("process_payment")(HandleProcessPayment(app)))
	r.Transition("ship", "/api/ship", "Send order to shipping", middleware.RequirePermission("ship")(HandleShip(app)))
	r.Transition("confirm", "/api/confirm", "Mark order as complete", middleware.RequirePermission("confirm")(HandleConfirm(app)))

	return r.Build()
}

// HandleCreate creates a new aggregate instance.
func HandleCreate(app *Application) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()

		id, err := app.Create(ctx)
		if err != nil {
			api.Error(w, http.StatusInternalServerError, "CREATE_FAILED", err.Error())
			return
		}

		// Load the new aggregate to get initial state
		agg, err := app.Load(ctx, id)
		if err != nil {
			api.Error(w, http.StatusInternalServerError, "LOAD_FAILED", err.Error())
			return
		}

		api.JSON(w, http.StatusCreated, api.StateResponse{
			AggregateID:        agg.ID(),
			Version:            agg.Version(),
			State:              agg.State(),
			Places:             agg.Places(),
			EnabledTransitions: agg.EnabledTransitions(),
		})
	}
}

// HandleGetState returns the current state of an aggregate.
func HandleGetState(app *Application) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()
		id := r.PathValue("id")
		if id == "" {
			api.Error(w, http.StatusBadRequest, "MISSING_ID", "aggregate ID is required")
			return
		}

		agg, err := app.GetState(ctx, id)
		if err != nil {
			api.Error(w, http.StatusNotFound, "NOT_FOUND", err.Error())
			return
		}

		api.JSON(w, http.StatusOK, api.StateResponse{
			AggregateID:        agg.ID(),
			Version:            agg.Version(),
			State:              agg.State(),
			Places:             agg.Places(),
			EnabledTransitions: agg.EnabledTransitions(),
		})
	}
}

// HandleReady checks if the application is ready to serve requests.
// Returns 200 if all dependencies are available, 503 otherwise.
func HandleReady(app *Application) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		checks := make(map[string]string)
		ready := true

		// Check event store connectivity
		if err := app.HealthCheck(r.Context()); err != nil {
			checks["eventstore"] = err.Error()
			ready = false
		} else {
			checks["eventstore"] = "ok"
		}

		status := http.StatusOK
		statusText := "ready"
		if !ready {
			status = http.StatusServiceUnavailable
			statusText = "not ready"
		}

		api.JSON(w, status, map[string]any{
			"status": statusText,
			"checks": checks,
		})
	}
}


// HandleValidate handles the validate transition.
func HandleValidate(app *Application) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()

		var req api.TransitionRequest
		if err := api.DecodeJSON(r, &req); err != nil {
			api.Error(w, http.StatusBadRequest, "INVALID_REQUEST", err.Error())
			return
		}

		if req.AggregateID == "" {
			api.Error(w, http.StatusBadRequest, "MISSING_ID", "aggregate_id is required")
			return
		}

		agg, err := app.Execute(ctx, req.AggregateID, TransitionValidate, req.Data)
		if err != nil {
			api.Error(w, http.StatusConflict, "TRANSITION_FAILED", err.Error())
			return
		}

		api.JSON(w, http.StatusOK, api.TransitionResult{
			Success:     true,
			AggregateID: agg.ID(),
			Version:     agg.Version(),
			State:       agg.Places(),
		})
	}
}


// HandleReject handles the reject transition.
func HandleReject(app *Application) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()

		var req api.TransitionRequest
		if err := api.DecodeJSON(r, &req); err != nil {
			api.Error(w, http.StatusBadRequest, "INVALID_REQUEST", err.Error())
			return
		}

		if req.AggregateID == "" {
			api.Error(w, http.StatusBadRequest, "MISSING_ID", "aggregate_id is required")
			return
		}

		agg, err := app.Execute(ctx, req.AggregateID, TransitionReject, req.Data)
		if err != nil {
			api.Error(w, http.StatusConflict, "TRANSITION_FAILED", err.Error())
			return
		}

		api.JSON(w, http.StatusOK, api.TransitionResult{
			Success:     true,
			AggregateID: agg.ID(),
			Version:     agg.Version(),
			State:       agg.Places(),
		})
	}
}


// HandleProcessPayment handles the process_payment transition.
func HandleProcessPayment(app *Application) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()

		var req api.TransitionRequest
		if err := api.DecodeJSON(r, &req); err != nil {
			api.Error(w, http.StatusBadRequest, "INVALID_REQUEST", err.Error())
			return
		}

		if req.AggregateID == "" {
			api.Error(w, http.StatusBadRequest, "MISSING_ID", "aggregate_id is required")
			return
		}

		agg, err := app.Execute(ctx, req.AggregateID, TransitionProcessPayment, req.Data)
		if err != nil {
			api.Error(w, http.StatusConflict, "TRANSITION_FAILED", err.Error())
			return
		}

		api.JSON(w, http.StatusOK, api.TransitionResult{
			Success:     true,
			AggregateID: agg.ID(),
			Version:     agg.Version(),
			State:       agg.Places(),
		})
	}
}


// HandleShip handles the ship transition.
func HandleShip(app *Application) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()

		var req api.TransitionRequest
		if err := api.DecodeJSON(r, &req); err != nil {
			api.Error(w, http.StatusBadRequest, "INVALID_REQUEST", err.Error())
			return
		}

		if req.AggregateID == "" {
			api.Error(w, http.StatusBadRequest, "MISSING_ID", "aggregate_id is required")
			return
		}

		agg, err := app.Execute(ctx, req.AggregateID, TransitionShip, req.Data)
		if err != nil {
			api.Error(w, http.StatusConflict, "TRANSITION_FAILED", err.Error())
			return
		}

		api.JSON(w, http.StatusOK, api.TransitionResult{
			Success:     true,
			AggregateID: agg.ID(),
			Version:     agg.Version(),
			State:       agg.Places(),
		})
	}
}


// HandleConfirm handles the confirm transition.
func HandleConfirm(app *Application) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()

		var req api.TransitionRequest
		if err := api.DecodeJSON(r, &req); err != nil {
			api.Error(w, http.StatusBadRequest, "INVALID_REQUEST", err.Error())
			return
		}

		if req.AggregateID == "" {
			api.Error(w, http.StatusBadRequest, "MISSING_ID", "aggregate_id is required")
			return
		}

		agg, err := app.Execute(ctx, req.AggregateID, TransitionConfirm, req.Data)
		if err != nil {
			api.Error(w, http.StatusConflict, "TRANSITION_FAILED", err.Error())
			return
		}

		api.JSON(w, http.StatusOK, api.TransitionResult{
			Success:     true,
			AggregateID: agg.ID(),
			Version:     agg.Version(),
			State:       agg.Places(),
		})
	}
}


// HandleGetViews returns the view definitions for the workflow.
func HandleGetViews() http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		data, err := ViewsJSON()
		if err != nil {
			api.Error(w, http.StatusInternalServerError, "VIEWS_ERROR", err.Error())
			return
		}
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusOK)
		w.Write(data)
	}
}










