// Code generated by petri-pilot. DO NOT EDIT.

package main

import (
	"time"
)

// SLAStatus represents the current SLA status.
type SLAStatus string

const (
	SLAStatusOK       SLAStatus = "ok"
	SLAStatusWarning  SLAStatus = "warning"
	SLAStatusCritical SLAStatus = "critical"
	SLAStatusBreached SLAStatus = "breached"
)

// SLAConfig holds the SLA configuration for this workflow.
var SLAConfig = struct {
	Default    string
	ByPriority map[string]string
	WarningAt  float64
	CriticalAt float64
	OnBreach   string
}{
	Default:    "30m",
	ByPriority: map[string]string{
		"high": "15m",
		"low": "2h",
		"normal": "30m",
	},
	WarningAt:  0.80,
	CriticalAt: 0.95,
	OnBreach:   "alert",
}

// SLAResponse represents the SLA status response.
type SLAResponse struct {
	Status    SLAStatus `json:"status"`
	Elapsed   string    `json:"elapsed"`
	Remaining string    `json:"remaining,omitempty"`
	Deadline  time.Time `json:"deadline"`
	Progress  float64   `json:"progress"`
	Priority  string    `json:"priority,omitempty"`
}

// GetSLADuration returns the SLA duration for a given priority.
// Returns the priority-specific duration if defined, otherwise the default.
func GetSLADuration(priority string) time.Duration {
	// Check priority-specific duration first
	if durationStr, ok := SLAConfig.ByPriority[priority]; ok {
		if d, err := time.ParseDuration(durationStr); err == nil {
			return d
		}
	}

	// Fall back to default
	if d, err := time.ParseDuration(SLAConfig.Default); err == nil {
		return d
	}

	// Ultimate fallback: 1 hour
	return time.Hour
}

// CalculateSLAStatus computes the SLA status for an aggregate.
func CalculateSLAStatus(startedAt time.Time, priority string) SLAResponse {
	now := time.Now()
	slaDuration := GetSLADuration(priority)
	deadline := startedAt.Add(slaDuration)
	elapsed := now.Sub(startedAt)

	var remaining time.Duration
	if deadline.After(now) {
		remaining = deadline.Sub(now)
	}

	progress := float64(elapsed) / float64(slaDuration)

	var status SLAStatus
	switch {
	case progress >= 1.0:
		status = SLAStatusBreached
	case progress >= SLAConfig.CriticalAt:
		status = SLAStatusCritical
	case progress >= SLAConfig.WarningAt:
		status = SLAStatusWarning
	default:
		status = SLAStatusOK
	}

	return SLAResponse{
		Status:    status,
		Elapsed:   elapsed.Round(time.Second).String(),
		Remaining: remaining.Round(time.Second).String(),
		Deadline:  deadline,
		Progress:  progress,
		Priority:  priority,
	}
}

// TransitionSLA holds timing expectations for a transition.
type TransitionSLA struct {
	Duration    string // Expected duration
	MinDuration string // Minimum expected duration
	MaxDuration string // Maximum allowed duration (SLA breach)
}

// TransitionSLAs holds per-transition timing expectations.
var TransitionSLAs = map[string]TransitionSLA{
	"validate": {
		Duration:    "2m",
		MinDuration: "",
		MaxDuration: "5m",
	},
	"ship": {
		Duration:    "10m",
		MinDuration: "",
		MaxDuration: "30m",
	},
}

// GetTransitionSLA returns the SLA configuration for a transition.
func GetTransitionSLA(transitionID string) *TransitionSLA {
	if sla, ok := TransitionSLAs[transitionID]; ok {
		return &sla
	}
	return nil
}
