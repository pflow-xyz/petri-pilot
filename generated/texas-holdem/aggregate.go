// Code generated by petri-pilot. DO NOT EDIT.

package main

import (
	"context"
	"encoding/json"
	"fmt"

	"github.com/google/uuid"
	"github.com/pflow-xyz/go-pflow/eventsource"
)

// State holds the aggregate state for texas-holdem.
type State struct {
	Waiting int `json:"waiting"`
	Preflop int `json:"preflop"`
	Flop int `json:"flop"`
	TurnRound int `json:"turn_round"`
	River int `json:"river"`
	Showdown int `json:"showdown"`
	Complete int `json:"complete"`
	P0Turn int `json:"p0_turn"`
	P1Turn int `json:"p1_turn"`
	P2Turn int `json:"p2_turn"`
	P3Turn int `json:"p3_turn"`
	P4Turn int `json:"p4_turn"`
	P0Active int `json:"p0_active"`
	P1Active int `json:"p1_active"`
	P2Active int `json:"p2_active"`
	P3Active int `json:"p3_active"`
	P4Active int `json:"p4_active"`
	BettingDone int `json:"betting_done"`
}

// NewState creates a new State with initialized collections.
func NewState() State {
	return State{
	}
}

// Aggregate wraps a StateMachine with the texas-holdem state.
type Aggregate struct {
	sm *eventsource.StateMachine[State]
}

// NewAggregate creates a new aggregate with initial state.
func NewAggregate(id string) *Aggregate {
	if id == "" {
		id = uuid.New().String()
	}
	sm := eventsource.NewStateMachine(id, NewState(), InitialPlaces())

	// Register transitions with their input/output places
	sm.AddTransition(eventsource.Transition{
		ID:        TransitionStartHand,
		EventType: EventTypeStartHand,
		Inputs: map[string]int{
			PlaceWaiting: 1,
		},
		Outputs: map[string]int{
			PlacePreflop: 1,
			PlaceP0Turn: 1,
		},
	})
	sm.AddTransition(eventsource.Transition{
		ID:        TransitionDealFlop,
		EventType: EventTypeDealFlop,
		Inputs: map[string]int{
			PlacePreflop: 1,
			PlaceBettingDone: 1,
		},
		Outputs: map[string]int{
			PlaceFlop: 1,
			PlaceP0Turn: 1,
		},
	})
	sm.AddTransition(eventsource.Transition{
		ID:        TransitionDealTurn,
		EventType: EventTypeDealTurn,
		Inputs: map[string]int{
			PlaceFlop: 1,
			PlaceBettingDone: 1,
		},
		Outputs: map[string]int{
			PlaceTurnRound: 1,
			PlaceP0Turn: 1,
		},
	})
	sm.AddTransition(eventsource.Transition{
		ID:        TransitionDealRiver,
		EventType: EventTypeDealRiver,
		Inputs: map[string]int{
			PlaceTurnRound: 1,
			PlaceBettingDone: 1,
		},
		Outputs: map[string]int{
			PlaceRiver: 1,
			PlaceP0Turn: 1,
		},
	})
	sm.AddTransition(eventsource.Transition{
		ID:        TransitionGoShowdown,
		EventType: EventTypeGoShowdown,
		Inputs: map[string]int{
			PlaceRiver: 1,
			PlaceBettingDone: 1,
		},
		Outputs: map[string]int{
			PlaceShowdown: 1,
		},
	})
	sm.AddTransition(eventsource.Transition{
		ID:        TransitionDetermineWinner,
		EventType: EventTypeDetermineWinner,
		Inputs: map[string]int{
			PlaceShowdown: 1,
		},
		Outputs: map[string]int{
			PlaceComplete: 1,
		},
	})
	sm.AddTransition(eventsource.Transition{
		ID:        TransitionEndHand,
		EventType: EventTypeEndHand,
		Inputs: map[string]int{
			PlaceComplete: 1,
		},
		Outputs: map[string]int{
			PlaceWaiting: 1,
			PlaceP0Active: 1,
			PlaceP1Active: 1,
			PlaceP2Active: 1,
			PlaceP3Active: 1,
			PlaceP4Active: 1,
		},
	})
	sm.AddTransition(eventsource.Transition{
		ID:        TransitionP0Fold,
		EventType: EventTypeP0Fold,
		Inputs: map[string]int{
			PlaceP0Turn: 1,
			PlaceP0Active: 1,
		},
		Outputs: map[string]int{
			PlaceP1Turn: 1,
		},
	})
	sm.AddTransition(eventsource.Transition{
		ID:        TransitionP0Check,
		EventType: EventTypeP0Check,
		Inputs: map[string]int{
			PlaceP0Turn: 1,
			PlaceP0Active: 1,
		},
		Outputs: map[string]int{
			PlaceP0Active: 1,
			PlaceP1Turn: 1,
		},
	})
	sm.AddTransition(eventsource.Transition{
		ID:        TransitionP0Call,
		EventType: EventTypeP0Call,
		Inputs: map[string]int{
			PlaceP0Turn: 1,
			PlaceP0Active: 1,
		},
		Outputs: map[string]int{
			PlaceP0Active: 1,
			PlaceP1Turn: 1,
		},
	})
	sm.AddTransition(eventsource.Transition{
		ID:        TransitionP0Raise,
		EventType: EventTypeP0Raise,
		Inputs: map[string]int{
			PlaceP0Turn: 1,
			PlaceP0Active: 1,
		},
		Outputs: map[string]int{
			PlaceP0Active: 1,
			PlaceP1Turn: 1,
		},
	})
	sm.AddTransition(eventsource.Transition{
		ID:        TransitionP1Fold,
		EventType: EventTypeP1Fold,
		Inputs: map[string]int{
			PlaceP1Turn: 1,
			PlaceP1Active: 1,
		},
		Outputs: map[string]int{
			PlaceP2Turn: 1,
		},
	})
	sm.AddTransition(eventsource.Transition{
		ID:        TransitionP1Check,
		EventType: EventTypeP1Check,
		Inputs: map[string]int{
			PlaceP1Turn: 1,
			PlaceP1Active: 1,
		},
		Outputs: map[string]int{
			PlaceP1Active: 1,
			PlaceP2Turn: 1,
		},
	})
	sm.AddTransition(eventsource.Transition{
		ID:        TransitionP1Call,
		EventType: EventTypeP1Call,
		Inputs: map[string]int{
			PlaceP1Turn: 1,
			PlaceP1Active: 1,
		},
		Outputs: map[string]int{
			PlaceP1Active: 1,
			PlaceP2Turn: 1,
		},
	})
	sm.AddTransition(eventsource.Transition{
		ID:        TransitionP1Raise,
		EventType: EventTypeP1Raise,
		Inputs: map[string]int{
			PlaceP1Turn: 1,
			PlaceP1Active: 1,
		},
		Outputs: map[string]int{
			PlaceP1Active: 1,
			PlaceP2Turn: 1,
		},
	})
	sm.AddTransition(eventsource.Transition{
		ID:        TransitionP2Fold,
		EventType: EventTypeP2Fold,
		Inputs: map[string]int{
			PlaceP2Turn: 1,
			PlaceP2Active: 1,
		},
		Outputs: map[string]int{
			PlaceP3Turn: 1,
		},
	})
	sm.AddTransition(eventsource.Transition{
		ID:        TransitionP2Check,
		EventType: EventTypeP2Check,
		Inputs: map[string]int{
			PlaceP2Turn: 1,
			PlaceP2Active: 1,
		},
		Outputs: map[string]int{
			PlaceP2Active: 1,
			PlaceP3Turn: 1,
		},
	})
	sm.AddTransition(eventsource.Transition{
		ID:        TransitionP2Call,
		EventType: EventTypeP2Call,
		Inputs: map[string]int{
			PlaceP2Turn: 1,
			PlaceP2Active: 1,
		},
		Outputs: map[string]int{
			PlaceP2Active: 1,
			PlaceP3Turn: 1,
		},
	})
	sm.AddTransition(eventsource.Transition{
		ID:        TransitionP2Raise,
		EventType: EventTypeP2Raise,
		Inputs: map[string]int{
			PlaceP2Turn: 1,
			PlaceP2Active: 1,
		},
		Outputs: map[string]int{
			PlaceP2Active: 1,
			PlaceP3Turn: 1,
		},
	})
	sm.AddTransition(eventsource.Transition{
		ID:        TransitionP3Fold,
		EventType: EventTypeP3Fold,
		Inputs: map[string]int{
			PlaceP3Turn: 1,
			PlaceP3Active: 1,
		},
		Outputs: map[string]int{
			PlaceP4Turn: 1,
		},
	})
	sm.AddTransition(eventsource.Transition{
		ID:        TransitionP3Check,
		EventType: EventTypeP3Check,
		Inputs: map[string]int{
			PlaceP3Turn: 1,
			PlaceP3Active: 1,
		},
		Outputs: map[string]int{
			PlaceP3Active: 1,
			PlaceP4Turn: 1,
		},
	})
	sm.AddTransition(eventsource.Transition{
		ID:        TransitionP3Call,
		EventType: EventTypeP3Call,
		Inputs: map[string]int{
			PlaceP3Turn: 1,
			PlaceP3Active: 1,
		},
		Outputs: map[string]int{
			PlaceP3Active: 1,
			PlaceP4Turn: 1,
		},
	})
	sm.AddTransition(eventsource.Transition{
		ID:        TransitionP3Raise,
		EventType: EventTypeP3Raise,
		Inputs: map[string]int{
			PlaceP3Turn: 1,
			PlaceP3Active: 1,
		},
		Outputs: map[string]int{
			PlaceP3Active: 1,
			PlaceP4Turn: 1,
		},
	})
	sm.AddTransition(eventsource.Transition{
		ID:        TransitionP4Fold,
		EventType: EventTypeP4Fold,
		Inputs: map[string]int{
			PlaceP4Turn: 1,
			PlaceP4Active: 1,
		},
		Outputs: map[string]int{
			PlaceBettingDone: 1,
		},
	})
	sm.AddTransition(eventsource.Transition{
		ID:        TransitionP4Check,
		EventType: EventTypeP4Check,
		Inputs: map[string]int{
			PlaceP4Turn: 1,
			PlaceP4Active: 1,
		},
		Outputs: map[string]int{
			PlaceP4Active: 1,
			PlaceBettingDone: 1,
		},
	})
	sm.AddTransition(eventsource.Transition{
		ID:        TransitionP4Call,
		EventType: EventTypeP4Call,
		Inputs: map[string]int{
			PlaceP4Turn: 1,
			PlaceP4Active: 1,
		},
		Outputs: map[string]int{
			PlaceP4Active: 1,
			PlaceBettingDone: 1,
		},
	})
	sm.AddTransition(eventsource.Transition{
		ID:        TransitionP4Raise,
		EventType: EventTypeP4Raise,
		Inputs: map[string]int{
			PlaceP4Turn: 1,
			PlaceP4Active: 1,
		},
		Outputs: map[string]int{
			PlaceP4Active: 1,
			PlaceBettingDone: 1,
		},
	})
	sm.AddTransition(eventsource.Transition{
		ID:        TransitionP0Skip,
		EventType: EventTypeP0Skip,
		Inputs: map[string]int{
			PlaceP0Turn: 1,
		},
		Outputs: map[string]int{
			PlaceP1Turn: 1,
		},
	})
	sm.AddTransition(eventsource.Transition{
		ID:        TransitionP1Skip,
		EventType: EventTypeP1Skip,
		Inputs: map[string]int{
			PlaceP1Turn: 1,
		},
		Outputs: map[string]int{
			PlaceP2Turn: 1,
		},
	})
	sm.AddTransition(eventsource.Transition{
		ID:        TransitionP2Skip,
		EventType: EventTypeP2Skip,
		Inputs: map[string]int{
			PlaceP2Turn: 1,
		},
		Outputs: map[string]int{
			PlaceP3Turn: 1,
		},
	})
	sm.AddTransition(eventsource.Transition{
		ID:        TransitionP3Skip,
		EventType: EventTypeP3Skip,
		Inputs: map[string]int{
			PlaceP3Turn: 1,
		},
		Outputs: map[string]int{
			PlaceP4Turn: 1,
		},
	})
	sm.AddTransition(eventsource.Transition{
		ID:        TransitionP4Skip,
		EventType: EventTypeP4Skip,
		Inputs: map[string]int{
			PlaceP4Turn: 1,
		},
		Outputs: map[string]int{
			PlaceBettingDone: 1,
		},
	})

	// Register event handlers for state updates
	sm.RegisterHandler(EventTypeStartHand, func(state *State, event *eventsource.Event) error {
		return applyStartHand(state, event)
	})
	sm.RegisterHandler(EventTypeDealFlop, func(state *State, event *eventsource.Event) error {
		return applyDealFlop(state, event)
	})
	sm.RegisterHandler(EventTypeDealTurn, func(state *State, event *eventsource.Event) error {
		return applyDealTurn(state, event)
	})
	sm.RegisterHandler(EventTypeDealRiver, func(state *State, event *eventsource.Event) error {
		return applyDealRiver(state, event)
	})
	sm.RegisterHandler(EventTypeGoShowdown, func(state *State, event *eventsource.Event) error {
		return applyGoShowdown(state, event)
	})
	sm.RegisterHandler(EventTypeDetermineWinner, func(state *State, event *eventsource.Event) error {
		return applyDetermineWinner(state, event)
	})
	sm.RegisterHandler(EventTypeEndHand, func(state *State, event *eventsource.Event) error {
		return applyEndHand(state, event)
	})
	sm.RegisterHandler(EventTypeP0Fold, func(state *State, event *eventsource.Event) error {
		return applyP0Fold(state, event)
	})
	sm.RegisterHandler(EventTypeP0Check, func(state *State, event *eventsource.Event) error {
		return applyP0Check(state, event)
	})
	sm.RegisterHandler(EventTypeP0Call, func(state *State, event *eventsource.Event) error {
		return applyP0Call(state, event)
	})
	sm.RegisterHandler(EventTypeP0Raise, func(state *State, event *eventsource.Event) error {
		return applyP0Raise(state, event)
	})
	sm.RegisterHandler(EventTypeP1Fold, func(state *State, event *eventsource.Event) error {
		return applyP1Fold(state, event)
	})
	sm.RegisterHandler(EventTypeP1Check, func(state *State, event *eventsource.Event) error {
		return applyP1Check(state, event)
	})
	sm.RegisterHandler(EventTypeP1Call, func(state *State, event *eventsource.Event) error {
		return applyP1Call(state, event)
	})
	sm.RegisterHandler(EventTypeP1Raise, func(state *State, event *eventsource.Event) error {
		return applyP1Raise(state, event)
	})
	sm.RegisterHandler(EventTypeP2Fold, func(state *State, event *eventsource.Event) error {
		return applyP2Fold(state, event)
	})
	sm.RegisterHandler(EventTypeP2Check, func(state *State, event *eventsource.Event) error {
		return applyP2Check(state, event)
	})
	sm.RegisterHandler(EventTypeP2Call, func(state *State, event *eventsource.Event) error {
		return applyP2Call(state, event)
	})
	sm.RegisterHandler(EventTypeP2Raise, func(state *State, event *eventsource.Event) error {
		return applyP2Raise(state, event)
	})
	sm.RegisterHandler(EventTypeP3Fold, func(state *State, event *eventsource.Event) error {
		return applyP3Fold(state, event)
	})
	sm.RegisterHandler(EventTypeP3Check, func(state *State, event *eventsource.Event) error {
		return applyP3Check(state, event)
	})
	sm.RegisterHandler(EventTypeP3Call, func(state *State, event *eventsource.Event) error {
		return applyP3Call(state, event)
	})
	sm.RegisterHandler(EventTypeP3Raise, func(state *State, event *eventsource.Event) error {
		return applyP3Raise(state, event)
	})
	sm.RegisterHandler(EventTypeP4Fold, func(state *State, event *eventsource.Event) error {
		return applyP4Fold(state, event)
	})
	sm.RegisterHandler(EventTypeP4Check, func(state *State, event *eventsource.Event) error {
		return applyP4Check(state, event)
	})
	sm.RegisterHandler(EventTypeP4Call, func(state *State, event *eventsource.Event) error {
		return applyP4Call(state, event)
	})
	sm.RegisterHandler(EventTypeP4Raise, func(state *State, event *eventsource.Event) error {
		return applyP4Raise(state, event)
	})
	sm.RegisterHandler(EventTypeP0Skip, func(state *State, event *eventsource.Event) error {
		return applyP0Skip(state, event)
	})
	sm.RegisterHandler(EventTypeP1Skip, func(state *State, event *eventsource.Event) error {
		return applyP1Skip(state, event)
	})
	sm.RegisterHandler(EventTypeP2Skip, func(state *State, event *eventsource.Event) error {
		return applyP2Skip(state, event)
	})
	sm.RegisterHandler(EventTypeP3Skip, func(state *State, event *eventsource.Event) error {
		return applyP3Skip(state, event)
	})
	sm.RegisterHandler(EventTypeP4Skip, func(state *State, event *eventsource.Event) error {
		return applyP4Skip(state, event)
	})
	return &Aggregate{sm: sm}
}

// ID returns the aggregate identifier.
func (a *Aggregate) ID() string {
	return a.sm.ID()
}

// Version returns the current event version.
func (a *Aggregate) Version() int {
	return a.sm.Version()
}

// State returns the current state.
func (a *Aggregate) State() any {
	return a.sm.State()
}

// Places returns current token distribution.
func (a *Aggregate) Places() map[string]int {
	places := make(map[string]int)
	for _, p := range AllPlaces() {
		places[p] = a.sm.Tokens(p)
	}
	return places
}

// EnabledTransitions returns transitions that can fire.
func (a *Aggregate) EnabledTransitions() []string {
	return a.sm.EnabledTransitions()
}

// CanFire checks if a transition can fire.
func (a *Aggregate) CanFire(transitionID string) bool {
	return a.sm.CanFire(transitionID)
}

// Fire executes a transition and returns the resulting event.
func (a *Aggregate) Fire(transitionID string, data any) (*eventsource.Event, error) {
	return a.sm.Fire(transitionID, data)
}

// Apply applies an event to update the aggregate state.
func (a *Aggregate) Apply(event *eventsource.Event) error {
	// Update state machine (this calls the registered handlers)
	return a.sm.Apply(event)
}

// Event application functions

func applyStartHand(state *State, event *eventsource.Event) error {
	// No data transformations for this transition
	_ = state
	_ = event
	return nil
}

func applyDealFlop(state *State, event *eventsource.Event) error {
	// No data transformations for this transition
	_ = state
	_ = event
	return nil
}

func applyDealTurn(state *State, event *eventsource.Event) error {
	// No data transformations for this transition
	_ = state
	_ = event
	return nil
}

func applyDealRiver(state *State, event *eventsource.Event) error {
	// No data transformations for this transition
	_ = state
	_ = event
	return nil
}

func applyGoShowdown(state *State, event *eventsource.Event) error {
	// No data transformations for this transition
	_ = state
	_ = event
	return nil
}

func applyDetermineWinner(state *State, event *eventsource.Event) error {
	// No data transformations for this transition
	_ = state
	_ = event
	return nil
}

func applyEndHand(state *State, event *eventsource.Event) error {
	// No data transformations for this transition
	_ = state
	_ = event
	return nil
}

func applyP0Fold(state *State, event *eventsource.Event) error {
	// No data transformations for this transition
	_ = state
	_ = event
	return nil
}

func applyP0Check(state *State, event *eventsource.Event) error {
	// No data transformations for this transition
	_ = state
	_ = event
	return nil
}

func applyP0Call(state *State, event *eventsource.Event) error {
	// No data transformations for this transition
	_ = state
	_ = event
	return nil
}

func applyP0Raise(state *State, event *eventsource.Event) error {
	// No data transformations for this transition
	_ = state
	_ = event
	return nil
}

func applyP1Fold(state *State, event *eventsource.Event) error {
	// No data transformations for this transition
	_ = state
	_ = event
	return nil
}

func applyP1Check(state *State, event *eventsource.Event) error {
	// No data transformations for this transition
	_ = state
	_ = event
	return nil
}

func applyP1Call(state *State, event *eventsource.Event) error {
	// No data transformations for this transition
	_ = state
	_ = event
	return nil
}

func applyP1Raise(state *State, event *eventsource.Event) error {
	// No data transformations for this transition
	_ = state
	_ = event
	return nil
}

func applyP2Fold(state *State, event *eventsource.Event) error {
	// No data transformations for this transition
	_ = state
	_ = event
	return nil
}

func applyP2Check(state *State, event *eventsource.Event) error {
	// No data transformations for this transition
	_ = state
	_ = event
	return nil
}

func applyP2Call(state *State, event *eventsource.Event) error {
	// No data transformations for this transition
	_ = state
	_ = event
	return nil
}

func applyP2Raise(state *State, event *eventsource.Event) error {
	// No data transformations for this transition
	_ = state
	_ = event
	return nil
}

func applyP3Fold(state *State, event *eventsource.Event) error {
	// No data transformations for this transition
	_ = state
	_ = event
	return nil
}

func applyP3Check(state *State, event *eventsource.Event) error {
	// No data transformations for this transition
	_ = state
	_ = event
	return nil
}

func applyP3Call(state *State, event *eventsource.Event) error {
	// No data transformations for this transition
	_ = state
	_ = event
	return nil
}

func applyP3Raise(state *State, event *eventsource.Event) error {
	// No data transformations for this transition
	_ = state
	_ = event
	return nil
}

func applyP4Fold(state *State, event *eventsource.Event) error {
	// No data transformations for this transition
	_ = state
	_ = event
	return nil
}

func applyP4Check(state *State, event *eventsource.Event) error {
	// No data transformations for this transition
	_ = state
	_ = event
	return nil
}

func applyP4Call(state *State, event *eventsource.Event) error {
	// No data transformations for this transition
	_ = state
	_ = event
	return nil
}

func applyP4Raise(state *State, event *eventsource.Event) error {
	// No data transformations for this transition
	_ = state
	_ = event
	return nil
}

func applyP0Skip(state *State, event *eventsource.Event) error {
	// No data transformations for this transition
	_ = state
	_ = event
	return nil
}

func applyP1Skip(state *State, event *eventsource.Event) error {
	// No data transformations for this transition
	_ = state
	_ = event
	return nil
}

func applyP2Skip(state *State, event *eventsource.Event) error {
	// No data transformations for this transition
	_ = state
	_ = event
	return nil
}

func applyP3Skip(state *State, event *eventsource.Event) error {
	// No data transformations for this transition
	_ = state
	_ = event
	return nil
}

func applyP4Skip(state *State, event *eventsource.Event) error {
	// No data transformations for this transition
	_ = state
	_ = event
	return nil
}

// Application wires together the aggregate and event store.
type Application struct {
	store eventsource.Store
}

// NewApplication creates a new application instance.
func NewApplication(store eventsource.Store) *Application {
	return &Application{store: store}
}

// Create creates a new aggregate and returns its ID.
func (app *Application) Create(ctx context.Context) (string, error) {
	agg := NewAggregate("")
	return agg.ID(), nil
}

// Load loads an aggregate from the event store.
func (app *Application) Load(ctx context.Context, id string) (*Aggregate, error) {
	events, err := app.store.Read(ctx, id, 0)
	if err != nil {
		return nil, fmt.Errorf("reading events: %w", err)
	}

	agg := NewAggregate(id)
	for _, event := range events {
		if err := agg.Apply(event); err != nil {
			return nil, fmt.Errorf("applying event %s: %w", event.ID, err)
		}
	}

	return agg, nil
}

// Execute fires a transition on an aggregate and persists the event.
func (app *Application) Execute(ctx context.Context, id, transitionID string, data any) (*Aggregate, error) {
	// Load current state
	agg, err := app.Load(ctx, id)
	if err != nil {
		return nil, err
	}

	// Check if transition can fire
	if !agg.CanFire(transitionID) {
		return nil, fmt.Errorf("transition %s cannot fire from current state", transitionID)
	}

	// Fire transition (this updates token counts but not version)
	event, err := agg.Fire(transitionID, data)
	if err != nil {
		return nil, fmt.Errorf("firing transition: %w", err)
	}

	// Persist event (this assigns the event version)
	// The expected version should match the current stream version (-1 for new streams)
	_, err = app.store.Append(ctx, id, agg.Version(), []*eventsource.Event{event})
	if err != nil {
		return nil, fmt.Errorf("persisting event: %w", err)
	}

	// Apply the event to update the aggregate's version
	if err := agg.Apply(event); err != nil {
		return nil, fmt.Errorf("applying event: %w", err)
	}

	return agg, nil
}

// GetState returns the current state of an aggregate.
func (app *Application) GetState(ctx context.Context, id string) (*Aggregate, error) {
	return app.Load(ctx, id)
}

// TruncateTo truncates an aggregate's event stream to a specific version.
// Events after the target version are removed. This enables "undo and redo differently" workflows.
func (app *Application) TruncateTo(ctx context.Context, id string, targetVersion int) (*Aggregate, error) {
	// Read all events
	events, err := app.store.Read(ctx, id, 0)
	if err != nil {
		return nil, fmt.Errorf("reading events: %w", err)
	}

	// Validate target version
	if targetVersion < 0 || targetVersion > len(events) {
		return nil, fmt.Errorf("invalid target version %d (stream has %d events)", targetVersion, len(events))
	}

	// If already at target, just load and return
	if targetVersion == len(events) {
		return app.Load(ctx, id)
	}

	// Keep only events up to target version
	eventsToKeep := events[:targetVersion]

	// Delete the stream
	if err := app.store.DeleteStream(ctx, id); err != nil {
		return nil, fmt.Errorf("deleting stream: %w", err)
	}

	// Re-append the events we want to keep
	if len(eventsToKeep) > 0 {
		if _, err := app.store.Append(ctx, id, -1, eventsToKeep); err != nil {
			return nil, fmt.Errorf("re-appending events: %w", err)
		}
	}

	// Load and return the truncated aggregate
	return app.Load(ctx, id)
}

// HealthCheck verifies the event store is accessible.
func (app *Application) HealthCheck(ctx context.Context) error {
	// Try to read from a non-existent stream - this exercises the store connection
	_, err := app.store.Read(ctx, "__health_check__", 0)
	// Ignore "not found" errors - we just want to verify connectivity
	if err != nil && err.Error() != "stream not found" {
		return err
	}
	return nil
}

// Helper to unmarshal event data
func unmarshalEventData[T any](event *eventsource.Event) (*T, error) {
	var data T
	if err := json.Unmarshal(event.Data, &data); err != nil {
		return nil, err
	}
	return &data, nil
}
