// Code generated by petri-pilot. DO NOT EDIT.

package main

import (
	"context"
	"testing"

	"github.com/pflow-xyz/go-pflow/eventsource"
)

func TestWorkflowConstants(t *testing.T) {
	// Verify place constants
	places := AllPlaces()
	if len(places) != 18 {
		t.Errorf("expected 18 places, got %d", len(places))
	}

	// Verify transition constants
	transitions := AllTransitions()
	if len(transitions) != 27 {
		t.Errorf("expected 27 transitions, got %d", len(transitions))
	}
}

func TestInitialPlaces(t *testing.T) {
	initial := InitialPlaces()
	_ = initial // suppress unused variable warning if no places have initial values
	if initial[PlaceWaiting] != 1 {
		t.Errorf("expected PlaceWaiting initial = 1, got %d", initial[PlaceWaiting])
	}
	if initial[PlaceP0Active] != 1 {
		t.Errorf("expected PlaceP0Active initial = 1, got %d", initial[PlaceP0Active])
	}
	if initial[PlaceP1Active] != 1 {
		t.Errorf("expected PlaceP1Active initial = 1, got %d", initial[PlaceP1Active])
	}
	if initial[PlaceP2Active] != 1 {
		t.Errorf("expected PlaceP2Active initial = 1, got %d", initial[PlaceP2Active])
	}
	if initial[PlaceP3Active] != 1 {
		t.Errorf("expected PlaceP3Active initial = 1, got %d", initial[PlaceP3Active])
	}
	if initial[PlaceP4Active] != 1 {
		t.Errorf("expected PlaceP4Active initial = 1, got %d", initial[PlaceP4Active])
	}
}

func TestNewAggregate(t *testing.T) {
	agg := NewAggregate("")
	if agg.ID() == "" {
		t.Error("expected non-empty aggregate ID")
	}
	// Version starts at -1 before any events are applied
	if agg.Version() != -1 {
		t.Errorf("expected version -1, got %d", agg.Version())
	}
}

func TestAggregateWithID(t *testing.T) {
	agg := NewAggregate("test-123")
	if agg.ID() != "test-123" {
		t.Errorf("expected ID 'test-123', got %q", agg.ID())
	}
}

func TestInitialState(t *testing.T) {
	agg := NewAggregate("")
	places := agg.Places()
	_ = places // suppress unused variable warning if no places have initial values
	if places[PlaceWaiting] != 1 {
		t.Errorf("expected PlaceWaiting = 1, got %d", places[PlaceWaiting])
	}
	if places[PlaceP0Active] != 1 {
		t.Errorf("expected PlaceP0Active = 1, got %d", places[PlaceP0Active])
	}
	if places[PlaceP1Active] != 1 {
		t.Errorf("expected PlaceP1Active = 1, got %d", places[PlaceP1Active])
	}
	if places[PlaceP2Active] != 1 {
		t.Errorf("expected PlaceP2Active = 1, got %d", places[PlaceP2Active])
	}
	if places[PlaceP3Active] != 1 {
		t.Errorf("expected PlaceP3Active = 1, got %d", places[PlaceP3Active])
	}
	if places[PlaceP4Active] != 1 {
		t.Errorf("expected PlaceP4Active = 1, got %d", places[PlaceP4Active])
	}
}

func TestEnabledTransitions(t *testing.T) {
	agg := NewAggregate("")
	enabled := agg.EnabledTransitions()

	// At least one transition should be enabled in initial state
	if len(enabled) == 0 {
		t.Log("Warning: no transitions enabled in initial state")
	}
}

func TestApplicationCreate(t *testing.T) {
	store := eventsource.NewMemoryStore()
	defer store.Close()

	app := NewApplication(store)
	ctx := context.Background()

	id, err := app.Create(ctx)
	if err != nil {
		t.Fatalf("Create failed: %v", err)
	}
	if id == "" {
		t.Error("expected non-empty ID")
	}
}

func TestApplicationLoadNewAggregate(t *testing.T) {
	store := eventsource.NewMemoryStore()
	defer store.Close()

	app := NewApplication(store)
	ctx := context.Background()

	id, _ := app.Create(ctx)
	agg, err := app.Load(ctx, id)
	if err != nil {
		t.Fatalf("Load failed: %v", err)
	}
	if agg.ID() != id {
		t.Errorf("expected ID %q, got %q", id, agg.ID())
	}
}


func TestFirstTransition(t *testing.T) {
	store := eventsource.NewMemoryStore()
	defer store.Close()

	app := NewApplication(store)
	ctx := context.Background()

	// Create new aggregate
	id, _ := app.Create(ctx)

	// Load and check enabled transitions
	agg, _ := app.Load(ctx, id)
	enabled := agg.EnabledTransitions()

	if len(enabled) == 0 {
		t.Skip("No transitions enabled in initial state")
	}

	// Try to execute the first enabled transition
	firstTransition := enabled[0]
	agg, err := app.Execute(ctx, id, firstTransition, nil)
	if err != nil {
		t.Fatalf("Execute %s failed: %v", firstTransition, err)
	}

	// Verify version is 0 (first event, 0-indexed)
	if agg.Version() != 0 {
		t.Errorf("expected version 0 after first transition, got %d", agg.Version())
	}
}


func TestCannotFireDisabledTransition(t *testing.T) {
	store := eventsource.NewMemoryStore()
	defer store.Close()

	app := NewApplication(store)
	ctx := context.Background()

	id, _ := app.Create(ctx)
	agg, _ := app.Load(ctx, id)

	// Find a transition that is NOT enabled
	allTransitions := AllTransitions()
	enabled := agg.EnabledTransitions()
	enabledSet := make(map[string]bool)
	for _, t := range enabled {
		enabledSet[t] = true
	}

	var disabledTransition string
	for _, t := range allTransitions {
		if !enabledSet[t] {
			disabledTransition = t
			break
		}
	}

	if disabledTransition == "" {
		t.Skip("All transitions are enabled in initial state")
	}

	// Try to execute a disabled transition
	_, err := app.Execute(ctx, id, disabledTransition, nil)
	if err == nil {
		t.Errorf("expected error when firing disabled transition %s", disabledTransition)
	}
}
