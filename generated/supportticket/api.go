// Code generated by petri-pilot. DO NOT EDIT.

package supportticket

import (
	"encoding/base64"
	"encoding/json"
	"io/fs"
	"net/http"
	"os"
	"path/filepath"
	"strconv"
	"strings"

	"github.com/pflow-xyz/petri-pilot/pkg/runtime/api"
)

// BuildRouter creates an HTTP router for the support-ticket workflow.
func BuildRouter(app *Application, middleware *Middleware, sessions SessionStore, debugBroker *DebugBroker) http.Handler {
	r := api.NewRouter()

	// Apply auth middleware to extract user from token (optional, doesn't require auth)
	r.Use(OptionalAuthMiddleware(sessions))

	// Health check - always returns ok if server is running
	r.GET("/health", "Health check", func(w http.ResponseWriter, r *http.Request) {
		api.JSON(w, http.StatusOK, map[string]string{"status": "ok"})
	})

	// Readiness check - verifies dependencies (database, etc.)
	r.GET("/ready", "Readiness check", HandleReady(app))

	// Create new aggregate
	r.POST("/api/supportticket", "Create new support-ticket", HandleCreate(app))

	// Get aggregate state
	r.GET("/api/supportticket/{id}", "Get support-ticket state", HandleGetState(app))

	// View definitions
	r.GET("/api/views", "Get view definitions", HandleGetViews())


	// Schema viewer endpoint
	r.GET("/api/schema", "Get model schema", HandleGetSchema())



	// Event replay endpoints
	r.GET("/api/supportticket/{id}/events", "Get event history", HandleGetEvents(app))
	r.GET("/api/supportticket/{id}/at/{version}", "Get state at version", HandleGetStateAtVersion(app))
	r.POST("/api/supportticket/{id}/truncate", "Truncate event history to version", HandleTruncate(app))





	// GraphQL API
	r.Handle("POST", "/graphql", "GraphQL API endpoint", GraphQLHandler(app))
	r.GET("/playground", "GraphQL Playground", PlaygroundHandler())


	// Debug WebSocket and eval endpoints
	r.GET("/ws", "Debug WebSocket connection", HandleDebugWebSocket(debugBroker))
	r.GET("/api/debug/sessions", "List debug sessions", HandleListSessions(debugBroker))
	r.POST("/api/debug/sessions/{id}/eval", "Evaluate code in browser session", HandleSessionEval(debugBroker))
	// Test login endpoint (only available in debug mode)
	r.POST("/api/debug/login", "Create test session with roles", HandleTestLogin(sessions))

















	// Transition endpoints
	r.Transition("assign", "/api/assign", "Assign ticket to an agent", middleware.RequirePermission("assign")(HandleAssign(app)))
	r.Transition("start_work", "/api/start_work", "Begin working on the ticket", middleware.RequirePermission("start_work")(HandleStartWork(app)))
	r.Transition("escalate", "/api/escalate", "Escalate to senior support", middleware.RequirePermission("escalate")(HandleEscalate(app)))
	r.Transition("request_info", "/api/request_info", "Request more information from customer", middleware.RequirePermission("request_info")(HandleRequestInfo(app)))
	r.Transition("customer_reply", "/api/customer_reply", "Customer provides requested information", middleware.RequirePermission("customer_reply")(HandleCustomerReply(app)))
	r.Transition("resolve", "/api/resolve", "Mark issue as resolved from in_progress", middleware.RequirePermission("resolve")(HandleResolve(app)))
	r.Transition("resolve_escalated", "/api/resolve_escalated", "Mark escalated issue as resolved", middleware.RequirePermission("resolve_escalated")(HandleResolveEscalated(app)))
	r.Transition("close", "/api/close", "Close the ticket", middleware.RequirePermission("close")(HandleClose(app)))
	r.Transition("reopen", "/api/reopen", "Customer reopens a closed ticket", middleware.RequirePermission("reopen")(HandleReopen(app)))

	// Serve frontend static files
	r.StaticFiles("/", StaticFileHandler())

	return r.Build()
}

// StaticFileHandler returns an http.Handler that serves static files from frontend/.
// It supports SPA routing by returning index.html for paths that don't match static files.
func StaticFileHandler() http.HandlerFunc {
	// Find frontend directory - try custom frontends first, then generated
	frontendPath := ""
	candidates := []string{
		"frontends/support-ticket",                    // Custom frontend (top priority)
		"frontend",                                    // Running from service directory
		"generated/supportticket/frontend",         // Generated frontend from repo root
		filepath.Join("generated", "supportticket", "frontend"), // Platform-safe
	}

	// Also try relative to executable
	if exe, err := os.Executable(); err == nil {
		exeDir := filepath.Dir(exe)
		candidates = append(candidates,
			filepath.Join(exeDir, "frontends", "support-ticket"),
			filepath.Join(exeDir, "frontend"),
			filepath.Join(exeDir, "generated", "supportticket", "frontend"),
		)
	}

	for _, candidate := range candidates {
		if _, err := os.Stat(candidate); err == nil {
			frontendPath = candidate
			break
		}
	}

	return func(w http.ResponseWriter, r *http.Request) {
		// No frontend found
		if frontendPath == "" {
			http.Error(w, "Frontend not found", http.StatusNotFound)
			return
		}

		// Clean the path
		path := strings.TrimPrefix(r.URL.Path, "/")
		if path == "" {
			path = "index.html"
		}

		// Try to serve the file
		fullPath := filepath.Join(frontendPath, path)

		// Check if file exists
		info, err := os.Stat(fullPath)
		if err != nil || info.IsDir() {
			// File doesn't exist, serve index.html for SPA routing
			http.ServeFile(w, r, filepath.Join(frontendPath, "index.html"))
			return
		}

		http.ServeFile(w, r, fullPath)
	}
}

// StaticFS is a helper interface for embedding static files (optional).
type StaticFS interface {
	fs.FS
}

// HandleCreate creates a new aggregate instance.
func HandleCreate(app *Application) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()

		id, err := app.Create(ctx)
		if err != nil {
			api.Error(w, http.StatusInternalServerError, "CREATE_FAILED", err.Error())
			return
		}

		// Load the new aggregate to get initial state
		agg, err := app.Load(ctx, id)
		if err != nil {
			api.Error(w, http.StatusInternalServerError, "LOAD_FAILED", err.Error())
			return
		}

		api.JSON(w, http.StatusCreated, api.StateResponse{
			AggregateID:        agg.ID(),
			Version:            agg.Version(),
			State:              agg.State(),
			Places:             agg.Places(),
			EnabledTransitions: agg.EnabledTransitions(),
		})
	}
}

// HandleGetState returns the current state of an aggregate.
func HandleGetState(app *Application) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()
		id := r.PathValue("id")
		if id == "" {
			api.Error(w, http.StatusBadRequest, "MISSING_ID", "aggregate ID is required")
			return
		}

		agg, err := app.GetState(ctx, id)
		if err != nil {
			api.Error(w, http.StatusNotFound, "NOT_FOUND", err.Error())
			return
		}

		api.JSON(w, http.StatusOK, api.StateResponse{
			AggregateID:        agg.ID(),
			Version:            agg.Version(),
			State:              agg.State(),
			Places:             agg.Places(),
			EnabledTransitions: agg.EnabledTransitions(),
		})
	}
}

// HandleReady checks if the application is ready to serve requests.
// Returns 200 if all dependencies are available, 503 otherwise.
func HandleReady(app *Application) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		checks := make(map[string]string)
		ready := true

		// Check event store connectivity
		if err := app.HealthCheck(r.Context()); err != nil {
			checks["eventstore"] = err.Error()
			ready = false
		} else {
			checks["eventstore"] = "ok"
		}

		status := http.StatusOK
		statusText := "ready"
		if !ready {
			status = http.StatusServiceUnavailable
			statusText = "not ready"
		}

		api.JSON(w, status, map[string]any{
			"status": statusText,
			"checks": checks,
		})
	}
}


// HandleAssign handles the assign transition.
func HandleAssign(app *Application) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()

		var req api.TransitionRequest
		if err := api.DecodeJSON(r, &req); err != nil {
			api.Error(w, http.StatusBadRequest, "INVALID_REQUEST", err.Error())
			return
		}

		if req.AggregateID == "" {
			api.Error(w, http.StatusBadRequest, "MISSING_ID", "aggregate_id is required")
			return
		}

		agg, err := app.Execute(ctx, req.AggregateID, TransitionAssign, req.Data)
		if err != nil {
			api.Error(w, http.StatusConflict, "TRANSITION_FAILED", err.Error())
			return
		}

		api.JSON(w, http.StatusOK, api.TransitionResult{
			Success:            true,
			AggregateID:        agg.ID(),
			Version:            agg.Version(),
			State:              agg.Places(),
			EnabledTransitions: agg.EnabledTransitions(),
		})
	}
}


// HandleStartWork handles the start_work transition.
func HandleStartWork(app *Application) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()

		var req api.TransitionRequest
		if err := api.DecodeJSON(r, &req); err != nil {
			api.Error(w, http.StatusBadRequest, "INVALID_REQUEST", err.Error())
			return
		}

		if req.AggregateID == "" {
			api.Error(w, http.StatusBadRequest, "MISSING_ID", "aggregate_id is required")
			return
		}

		agg, err := app.Execute(ctx, req.AggregateID, TransitionStartWork, req.Data)
		if err != nil {
			api.Error(w, http.StatusConflict, "TRANSITION_FAILED", err.Error())
			return
		}

		api.JSON(w, http.StatusOK, api.TransitionResult{
			Success:            true,
			AggregateID:        agg.ID(),
			Version:            agg.Version(),
			State:              agg.Places(),
			EnabledTransitions: agg.EnabledTransitions(),
		})
	}
}


// HandleEscalate handles the escalate transition.
func HandleEscalate(app *Application) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()

		var req api.TransitionRequest
		if err := api.DecodeJSON(r, &req); err != nil {
			api.Error(w, http.StatusBadRequest, "INVALID_REQUEST", err.Error())
			return
		}

		if req.AggregateID == "" {
			api.Error(w, http.StatusBadRequest, "MISSING_ID", "aggregate_id is required")
			return
		}

		agg, err := app.Execute(ctx, req.AggregateID, TransitionEscalate, req.Data)
		if err != nil {
			api.Error(w, http.StatusConflict, "TRANSITION_FAILED", err.Error())
			return
		}

		api.JSON(w, http.StatusOK, api.TransitionResult{
			Success:            true,
			AggregateID:        agg.ID(),
			Version:            agg.Version(),
			State:              agg.Places(),
			EnabledTransitions: agg.EnabledTransitions(),
		})
	}
}


// HandleRequestInfo handles the request_info transition.
func HandleRequestInfo(app *Application) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()

		var req api.TransitionRequest
		if err := api.DecodeJSON(r, &req); err != nil {
			api.Error(w, http.StatusBadRequest, "INVALID_REQUEST", err.Error())
			return
		}

		if req.AggregateID == "" {
			api.Error(w, http.StatusBadRequest, "MISSING_ID", "aggregate_id is required")
			return
		}

		agg, err := app.Execute(ctx, req.AggregateID, TransitionRequestInfo, req.Data)
		if err != nil {
			api.Error(w, http.StatusConflict, "TRANSITION_FAILED", err.Error())
			return
		}

		api.JSON(w, http.StatusOK, api.TransitionResult{
			Success:            true,
			AggregateID:        agg.ID(),
			Version:            agg.Version(),
			State:              agg.Places(),
			EnabledTransitions: agg.EnabledTransitions(),
		})
	}
}


// HandleCustomerReply handles the customer_reply transition.
func HandleCustomerReply(app *Application) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()

		var req api.TransitionRequest
		if err := api.DecodeJSON(r, &req); err != nil {
			api.Error(w, http.StatusBadRequest, "INVALID_REQUEST", err.Error())
			return
		}

		if req.AggregateID == "" {
			api.Error(w, http.StatusBadRequest, "MISSING_ID", "aggregate_id is required")
			return
		}

		agg, err := app.Execute(ctx, req.AggregateID, TransitionCustomerReply, req.Data)
		if err != nil {
			api.Error(w, http.StatusConflict, "TRANSITION_FAILED", err.Error())
			return
		}

		api.JSON(w, http.StatusOK, api.TransitionResult{
			Success:            true,
			AggregateID:        agg.ID(),
			Version:            agg.Version(),
			State:              agg.Places(),
			EnabledTransitions: agg.EnabledTransitions(),
		})
	}
}


// HandleResolve handles the resolve transition.
func HandleResolve(app *Application) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()

		var req api.TransitionRequest
		if err := api.DecodeJSON(r, &req); err != nil {
			api.Error(w, http.StatusBadRequest, "INVALID_REQUEST", err.Error())
			return
		}

		if req.AggregateID == "" {
			api.Error(w, http.StatusBadRequest, "MISSING_ID", "aggregate_id is required")
			return
		}

		agg, err := app.Execute(ctx, req.AggregateID, TransitionResolve, req.Data)
		if err != nil {
			api.Error(w, http.StatusConflict, "TRANSITION_FAILED", err.Error())
			return
		}

		api.JSON(w, http.StatusOK, api.TransitionResult{
			Success:            true,
			AggregateID:        agg.ID(),
			Version:            agg.Version(),
			State:              agg.Places(),
			EnabledTransitions: agg.EnabledTransitions(),
		})
	}
}


// HandleResolveEscalated handles the resolve_escalated transition.
func HandleResolveEscalated(app *Application) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()

		var req api.TransitionRequest
		if err := api.DecodeJSON(r, &req); err != nil {
			api.Error(w, http.StatusBadRequest, "INVALID_REQUEST", err.Error())
			return
		}

		if req.AggregateID == "" {
			api.Error(w, http.StatusBadRequest, "MISSING_ID", "aggregate_id is required")
			return
		}

		agg, err := app.Execute(ctx, req.AggregateID, TransitionResolveEscalated, req.Data)
		if err != nil {
			api.Error(w, http.StatusConflict, "TRANSITION_FAILED", err.Error())
			return
		}

		api.JSON(w, http.StatusOK, api.TransitionResult{
			Success:            true,
			AggregateID:        agg.ID(),
			Version:            agg.Version(),
			State:              agg.Places(),
			EnabledTransitions: agg.EnabledTransitions(),
		})
	}
}


// HandleClose handles the close transition.
func HandleClose(app *Application) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()

		var req api.TransitionRequest
		if err := api.DecodeJSON(r, &req); err != nil {
			api.Error(w, http.StatusBadRequest, "INVALID_REQUEST", err.Error())
			return
		}

		if req.AggregateID == "" {
			api.Error(w, http.StatusBadRequest, "MISSING_ID", "aggregate_id is required")
			return
		}

		agg, err := app.Execute(ctx, req.AggregateID, TransitionClose, req.Data)
		if err != nil {
			api.Error(w, http.StatusConflict, "TRANSITION_FAILED", err.Error())
			return
		}

		api.JSON(w, http.StatusOK, api.TransitionResult{
			Success:            true,
			AggregateID:        agg.ID(),
			Version:            agg.Version(),
			State:              agg.Places(),
			EnabledTransitions: agg.EnabledTransitions(),
		})
	}
}


// HandleReopen handles the reopen transition.
func HandleReopen(app *Application) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()

		var req api.TransitionRequest
		if err := api.DecodeJSON(r, &req); err != nil {
			api.Error(w, http.StatusBadRequest, "INVALID_REQUEST", err.Error())
			return
		}

		if req.AggregateID == "" {
			api.Error(w, http.StatusBadRequest, "MISSING_ID", "aggregate_id is required")
			return
		}

		agg, err := app.Execute(ctx, req.AggregateID, TransitionReopen, req.Data)
		if err != nil {
			api.Error(w, http.StatusConflict, "TRANSITION_FAILED", err.Error())
			return
		}

		api.JSON(w, http.StatusOK, api.TransitionResult{
			Success:            true,
			AggregateID:        agg.ID(),
			Version:            agg.Version(),
			State:              agg.Places(),
			EnabledTransitions: agg.EnabledTransitions(),
		})
	}
}


// HandleGetViews returns the view definitions for the workflow.
func HandleGetViews() http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		data, err := ViewsJSON()
		if err != nil {
			api.Error(w, http.StatusInternalServerError, "VIEWS_ERROR", err.Error())
			return
		}
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusOK)
		w.Write(data)
	}
}






// HandleGetEvents returns the event history for an aggregate.
func HandleGetEvents(app *Application) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()
		id := r.PathValue("id")
		from := getIntQueryParam(r, "from", 0)

		events, err := app.store.Read(ctx, id, from)
		if err != nil {
			api.Error(w, http.StatusInternalServerError, "READ_FAILED", err.Error())
			return
		}

		api.JSON(w, http.StatusOK, map[string]interface{}{
			"events": events,
		})
	}
}

// HandleGetStateAtVersion returns the aggregate state at a specific version.
func HandleGetStateAtVersion(app *Application) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()
		id := r.PathValue("id")
		versionStr := r.PathValue("version")

		version := getInt(versionStr, 0)
		if version <= 0 {
			api.Error(w, http.StatusBadRequest, "INVALID_VERSION", "version must be a positive integer")
			return
		}

		events, err := app.store.Read(ctx, id, 0)
		if err != nil {
			api.Error(w, http.StatusInternalServerError, "READ_FAILED", err.Error())
			return
		}

		// Create temporary aggregate and replay up to version
		agg := NewAggregate(id)
		for _, evt := range events {
			if evt.Version > version {
				break
			}
			if err := agg.Apply(evt); err != nil {
				api.Error(w, http.StatusInternalServerError, "APPLY_FAILED", err.Error())
				return
			}
		}

		api.JSON(w, http.StatusOK, map[string]interface{}{
			"id":      agg.ID(),
			"version": version,
			"state":   agg.State(),
		})
	}
}

// HandleTruncate truncates the event stream to a specific version.
// This enables "undo and redo differently" workflows by discarding events after the target version.
func HandleTruncate(app *Application) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()
		id := r.PathValue("id")

		var req struct {
			Version int `json:"version"`
		}
		if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
			api.Error(w, http.StatusBadRequest, "INVALID_REQUEST", "request body must contain version field")
			return
		}

		if req.Version < 0 {
			api.Error(w, http.StatusBadRequest, "INVALID_VERSION", "version must be non-negative")
			return
		}

		agg, err := app.TruncateTo(ctx, id, req.Version)
		if err != nil {
			api.Error(w, http.StatusInternalServerError, "TRUNCATE_FAILED", err.Error())
			return
		}

		api.JSON(w, http.StatusOK, map[string]interface{}{
			"id":                    agg.ID(),
			"version":               agg.Version(),
			"state":                 agg.State(),
			"enabled_transitions":   agg.EnabledTransitions(),
		})
	}
}





// Helper functions

func getIntQueryParam(r *http.Request, name string, defaultVal int) int {
	val := r.URL.Query().Get(name)
	return getInt(val, defaultVal)
}

func getInt(s string, defaultVal int) int {
	if s == "" {
		return defaultVal
	}

	intVal, err := strconv.Atoi(s)
	if err != nil {
		return defaultVal
	}

	return intVal
}


// HandleGetSchema returns the model schema JSON for the schema viewer.
func HandleGetSchema() http.HandlerFunc {
	// Schema JSON is embedded at generation time (base64 encoded)
	schemaBase64 := "ewogICJuYW1lIjogInN1cHBvcnQtdGlja2V0IiwKICAiZGVzY3JpcHRpb24iOiAiQSBzdXBwb3J0IHRpY2tldCBzeXN0ZW06IG5ldyB0aWNrZXRzIGNhbiBiZSBhc3NpZ25lZCwgd29ya2VkIG9uLCBlc2NhbGF0ZWQsIHJlc29sdmVkLCBvciBjbG9zZWQuIEN1c3RvbWVycyBjYW4gcmVvcGVuIGNsb3NlZCB0aWNrZXRzLiIsCiAgInBsYWNlcyI6IFsKICAgIHsKICAgICAgImlkIjogIm5ldyIsCiAgICAgICJkZXNjcmlwdGlvbiI6ICJUaWNrZXQganVzdCBjcmVhdGVkLCBhd2FpdGluZyB0cmlhZ2UiLAogICAgICAiaW5pdGlhbCI6IDEsCiAgICAgICJraW5kIjogInRva2VuIgogICAgfSwKICAgIHsKICAgICAgImlkIjogImFzc2lnbmVkIiwKICAgICAgImRlc2NyaXB0aW9uIjogIlRpY2tldCBhc3NpZ25lZCB0byBhbiBhZ2VudCIsCiAgICAgICJpbml0aWFsIjogMCwKICAgICAgImtpbmQiOiAidG9rZW4iCiAgICB9LAogICAgewogICAgICAiaWQiOiAiaW5fcHJvZ3Jlc3MiLAogICAgICAiZGVzY3JpcHRpb24iOiAiQWdlbnQgaXMgYWN0aXZlbHkgd29ya2luZyBvbiB0aWNrZXQiLAogICAgICAiaW5pdGlhbCI6IDAsCiAgICAgICJraW5kIjogInRva2VuIgogICAgfSwKICAgIHsKICAgICAgImlkIjogImVzY2FsYXRlZCIsCiAgICAgICJkZXNjcmlwdGlvbiI6ICJUaWNrZXQgZXNjYWxhdGVkIHRvIHNlbmlvciBzdXBwb3J0IiwKICAgICAgImluaXRpYWwiOiAwLAogICAgICAia2luZCI6ICJ0b2tlbiIKICAgIH0sCiAgICB7CiAgICAgICJpZCI6ICJwZW5kaW5nX2N1c3RvbWVyIiwKICAgICAgImRlc2NyaXB0aW9uIjogIldhaXRpbmcgZm9yIGN1c3RvbWVyIHJlc3BvbnNlIiwKICAgICAgImluaXRpYWwiOiAwLAogICAgICAia2luZCI6ICJ0b2tlbiIKICAgIH0sCiAgICB7CiAgICAgICJpZCI6ICJyZXNvbHZlZCIsCiAgICAgICJkZXNjcmlwdGlvbiI6ICJJc3N1ZSBoYXMgYmVlbiByZXNvbHZlZCIsCiAgICAgICJpbml0aWFsIjogMCwKICAgICAgImtpbmQiOiAidG9rZW4iCiAgICB9LAogICAgewogICAgICAiaWQiOiAiY2xvc2VkIiwKICAgICAgImRlc2NyaXB0aW9uIjogIlRpY2tldCBpcyBjbG9zZWQiLAogICAgICAiaW5pdGlhbCI6IDAsCiAgICAgICJraW5kIjogInRva2VuIgogICAgfQogIF0sCiAgInRyYW5zaXRpb25zIjogWwogICAgewogICAgICAiaWQiOiAiYXNzaWduIiwKICAgICAgImRlc2NyaXB0aW9uIjogIkFzc2lnbiB0aWNrZXQgdG8gYW4gYWdlbnQiLAogICAgICAiaHR0cF9tZXRob2QiOiAiUE9TVCIsCiAgICAgICJodHRwX3BhdGgiOiAiL2FwaS9hc3NpZ24iLAogICAgICAiZXZlbnRfdHlwZSI6ICJBc3NpZ25lZCIKICAgIH0sCiAgICB7CiAgICAgICJpZCI6ICJzdGFydF93b3JrIiwKICAgICAgImRlc2NyaXB0aW9uIjogIkJlZ2luIHdvcmtpbmcgb24gdGhlIHRpY2tldCIsCiAgICAgICJodHRwX21ldGhvZCI6ICJQT1NUIiwKICAgICAgImh0dHBfcGF0aCI6ICIvYXBpL3N0YXJ0X3dvcmsiLAogICAgICAiZXZlbnRfdHlwZSI6ICJTdGFydFdvcmtlZCIKICAgIH0sCiAgICB7CiAgICAgICJpZCI6ICJlc2NhbGF0ZSIsCiAgICAgICJkZXNjcmlwdGlvbiI6ICJFc2NhbGF0ZSB0byBzZW5pb3Igc3VwcG9ydCIsCiAgICAgICJodHRwX21ldGhvZCI6ICJQT1NUIiwKICAgICAgImh0dHBfcGF0aCI6ICIvYXBpL2VzY2FsYXRlIiwKICAgICAgImV2ZW50X3R5cGUiOiAiRXNjYWxhdGVlZCIKICAgIH0sCiAgICB7CiAgICAgICJpZCI6ICJyZXF1ZXN0X2luZm8iLAogICAgICAiZGVzY3JpcHRpb24iOiAiUmVxdWVzdCBtb3JlIGluZm9ybWF0aW9uIGZyb20gY3VzdG9tZXIiLAogICAgICAiaHR0cF9tZXRob2QiOiAiUE9TVCIsCiAgICAgICJodHRwX3BhdGgiOiAiL2FwaS9yZXF1ZXN0X2luZm8iLAogICAgICAiZXZlbnRfdHlwZSI6ICJSZXF1ZXN0SW5mb2VkIgogICAgfSwKICAgIHsKICAgICAgImlkIjogImN1c3RvbWVyX3JlcGx5IiwKICAgICAgImRlc2NyaXB0aW9uIjogIkN1c3RvbWVyIHByb3ZpZGVzIHJlcXVlc3RlZCBpbmZvcm1hdGlvbiIsCiAgICAgICJodHRwX21ldGhvZCI6ICJQT1NUIiwKICAgICAgImh0dHBfcGF0aCI6ICIvYXBpL2N1c3RvbWVyX3JlcGx5IiwKICAgICAgImV2ZW50X3R5cGUiOiAiQ3VzdG9tZXJSZXBseWVkIgogICAgfSwKICAgIHsKICAgICAgImlkIjogInJlc29sdmUiLAogICAgICAiZGVzY3JpcHRpb24iOiAiTWFyayBpc3N1ZSBhcyByZXNvbHZlZCBmcm9tIGluX3Byb2dyZXNzIiwKICAgICAgImh0dHBfbWV0aG9kIjogIlBPU1QiLAogICAgICAiaHR0cF9wYXRoIjogIi9hcGkvcmVzb2x2ZSIsCiAgICAgICJldmVudF90eXBlIjogIlJlc29sdmVlZCIKICAgIH0sCiAgICB7CiAgICAgICJpZCI6ICJyZXNvbHZlX2VzY2FsYXRlZCIsCiAgICAgICJkZXNjcmlwdGlvbiI6ICJNYXJrIGVzY2FsYXRlZCBpc3N1ZSBhcyByZXNvbHZlZCIsCiAgICAgICJodHRwX21ldGhvZCI6ICJQT1NUIiwKICAgICAgImh0dHBfcGF0aCI6ICIvYXBpL3Jlc29sdmVfZXNjYWxhdGVkIiwKICAgICAgImV2ZW50X3R5cGUiOiAiUmVzb2x2ZUVzY2FsYXRlZCIKICAgIH0sCiAgICB7CiAgICAgICJpZCI6ICJjbG9zZSIsCiAgICAgICJkZXNjcmlwdGlvbiI6ICJDbG9zZSB0aGUgdGlja2V0IiwKICAgICAgImh0dHBfbWV0aG9kIjogIlBPU1QiLAogICAgICAiaHR0cF9wYXRoIjogIi9hcGkvY2xvc2UiLAogICAgICAiZXZlbnRfdHlwZSI6ICJDbG9zZWVkIgogICAgfSwKICAgIHsKICAgICAgImlkIjogInJlb3BlbiIsCiAgICAgICJkZXNjcmlwdGlvbiI6ICJDdXN0b21lciByZW9wZW5zIGEgY2xvc2VkIHRpY2tldCIsCiAgICAgICJodHRwX21ldGhvZCI6ICJQT1NUIiwKICAgICAgImh0dHBfcGF0aCI6ICIvYXBpL3Jlb3BlbiIsCiAgICAgICJldmVudF90eXBlIjogIlJlb3BlbmVkIgogICAgfQogIF0sCiAgImFyY3MiOiBbCiAgICB7CiAgICAgICJmcm9tIjogIm5ldyIsCiAgICAgICJ0byI6ICJhc3NpZ24iCiAgICB9LAogICAgewogICAgICAiZnJvbSI6ICJhc3NpZ24iLAogICAgICAidG8iOiAiYXNzaWduZWQiCiAgICB9LAogICAgewogICAgICAiZnJvbSI6ICJhc3NpZ25lZCIsCiAgICAgICJ0byI6ICJzdGFydF93b3JrIgogICAgfSwKICAgIHsKICAgICAgImZyb20iOiAic3RhcnRfd29yayIsCiAgICAgICJ0byI6ICJpbl9wcm9ncmVzcyIKICAgIH0sCiAgICB7CiAgICAgICJmcm9tIjogImluX3Byb2dyZXNzIiwKICAgICAgInRvIjogImVzY2FsYXRlIgogICAgfSwKICAgIHsKICAgICAgImZyb20iOiAiZXNjYWxhdGUiLAogICAgICAidG8iOiAiZXNjYWxhdGVkIgogICAgfSwKICAgIHsKICAgICAgImZyb20iOiAiZXNjYWxhdGVkIiwKICAgICAgInRvIjogInJlc29sdmVfZXNjYWxhdGVkIgogICAgfSwKICAgIHsKICAgICAgImZyb20iOiAicmVzb2x2ZV9lc2NhbGF0ZWQiLAogICAgICAidG8iOiAicmVzb2x2ZWQiCiAgICB9LAogICAgewogICAgICAiZnJvbSI6ICJpbl9wcm9ncmVzcyIsCiAgICAgICJ0byI6ICJyZXF1ZXN0X2luZm8iCiAgICB9LAogICAgewogICAgICAiZnJvbSI6ICJyZXF1ZXN0X2luZm8iLAogICAgICAidG8iOiAicGVuZGluZ19jdXN0b21lciIKICAgIH0sCiAgICB7CiAgICAgICJmcm9tIjogInBlbmRpbmdfY3VzdG9tZXIiLAogICAgICAidG8iOiAiY3VzdG9tZXJfcmVwbHkiCiAgICB9LAogICAgewogICAgICAiZnJvbSI6ICJjdXN0b21lcl9yZXBseSIsCiAgICAgICJ0byI6ICJpbl9wcm9ncmVzcyIKICAgIH0sCiAgICB7CiAgICAgICJmcm9tIjogImluX3Byb2dyZXNzIiwKICAgICAgInRvIjogInJlc29sdmUiCiAgICB9LAogICAgewogICAgICAiZnJvbSI6ICJyZXNvbHZlIiwKICAgICAgInRvIjogInJlc29sdmVkIgogICAgfSwKICAgIHsKICAgICAgImZyb20iOiAicmVzb2x2ZWQiLAogICAgICAidG8iOiAiY2xvc2UiCiAgICB9LAogICAgewogICAgICAiZnJvbSI6ICJjbG9zZSIsCiAgICAgICJ0byI6ICJjbG9zZWQiCiAgICB9LAogICAgewogICAgICAiZnJvbSI6ICJjbG9zZWQiLAogICAgICAidG8iOiAicmVvcGVuIgogICAgfSwKICAgIHsKICAgICAgImZyb20iOiAicmVvcGVuIiwKICAgICAgInRvIjogIm5ldyIKICAgIH0KICBdLAogICJhY2Nlc3MiOiBbCiAgICB7CiAgICAgICJ0cmFuc2l0aW9uIjogImFzc2lnbiIsCiAgICAgICJyb2xlcyI6IFsKICAgICAgICAiYWdlbnQiCiAgICAgIF0KICAgIH0sCiAgICB7CiAgICAgICJ0cmFuc2l0aW9uIjogInN0YXJ0X3dvcmsiLAogICAgICAicm9sZXMiOiBbCiAgICAgICAgImFnZW50IgogICAgICBdCiAgICB9LAogICAgewogICAgICAidHJhbnNpdGlvbiI6ICJlc2NhbGF0ZSIsCiAgICAgICJyb2xlcyI6IFsKICAgICAgICAiYWdlbnQiCiAgICAgIF0KICAgIH0sCiAgICB7CiAgICAgICJ0cmFuc2l0aW9uIjogInJlcXVlc3RfaW5mbyIsCiAgICAgICJyb2xlcyI6IFsKICAgICAgICAiYWdlbnQiCiAgICAgIF0KICAgIH0sCiAgICB7CiAgICAgICJ0cmFuc2l0aW9uIjogImN1c3RvbWVyX3JlcGx5IiwKICAgICAgInJvbGVzIjogWwogICAgICAgICJjdXN0b21lciIKICAgICAgXQogICAgfSwKICAgIHsKICAgICAgInRyYW5zaXRpb24iOiAicmVzb2x2ZSIsCiAgICAgICJyb2xlcyI6IFsKICAgICAgICAiYWdlbnQiCiAgICAgIF0KICAgIH0sCiAgICB7CiAgICAgICJ0cmFuc2l0aW9uIjogInJlc29sdmVfZXNjYWxhdGVkIiwKICAgICAgInJvbGVzIjogWwogICAgICAgICJzdXBlcnZpc29yIgogICAgICBdCiAgICB9LAogICAgewogICAgICAidHJhbnNpdGlvbiI6ICJjbG9zZSIsCiAgICAgICJyb2xlcyI6IFsKICAgICAgICAiYWdlbnQiCiAgICAgIF0KICAgIH0sCiAgICB7CiAgICAgICJ0cmFuc2l0aW9uIjogInJlb3BlbiIsCiAgICAgICJyb2xlcyI6IFsKICAgICAgICAiY3VzdG9tZXIiCiAgICAgIF0KICAgIH0KICBdLAogICJkZWJ1ZyI6IHsKICAgICJlbmFibGVkIjogdHJ1ZSwKICAgICJldmFsIjogdHJ1ZQogIH0sCiAgImdyYXBocWwiOiB7CiAgICAiZW5hYmxlZCI6IHRydWUsCiAgICAicGxheWdyb3VuZCI6IHRydWUKICB9Cn0="

	return func(w http.ResponseWriter, r *http.Request) {
		schemaJSON, err := base64.StdEncoding.DecodeString(schemaBase64)
		if err != nil {
			api.Error(w, http.StatusInternalServerError, "schema_decode_error", "Failed to decode schema")
			return
		}
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusOK)
		w.Write(schemaJSON)
	}
}

