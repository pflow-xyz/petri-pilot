// Code generated by petri-pilot. DO NOT EDIT.

package supportticket

import (
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"sync"
	"time"

	"github.com/gorilla/websocket"
	"github.com/pflow-xyz/petri-pilot/pkg/runtime/api"
)

// DebugMessage represents a message sent over the debug WebSocket.
type DebugMessage struct {
	ID   string          `json:"id"`
	Type string          `json:"type"`
	Data json.RawMessage `json:"data,omitempty"`
}

// DebugSession represents a connected browser session.
type DebugSession struct {
	ID          string
	conn        *websocket.Conn
	send        chan []byte
	pending     map[string]chan *DebugMessage
	pendingLock sync.Mutex
	createdAt   time.Time
}

// DebugBroker manages all debug sessions.
type DebugBroker struct {
	sessions     map[string]*DebugSession
	sessionsLock sync.RWMutex
	counter      int
}

// NewDebugBroker creates a new debug broker.
func NewDebugBroker() *DebugBroker {
	return &DebugBroker{
		sessions: make(map[string]*DebugSession),
	}
}

// AddSession adds a new session to the broker.
func (b *DebugBroker) AddSession(session *DebugSession) {
	b.sessionsLock.Lock()
	defer b.sessionsLock.Unlock()
	b.sessions[session.ID] = session
}

// RemoveSession removes a session from the broker.
func (b *DebugBroker) RemoveSession(id string) {
	b.sessionsLock.Lock()
	defer b.sessionsLock.Unlock()
	if session, ok := b.sessions[id]; ok {
		close(session.send)
		delete(b.sessions, id)
	}
}

// GetSession returns a session by ID.
func (b *DebugBroker) GetSession(id string) *DebugSession {
	b.sessionsLock.RLock()
	defer b.sessionsLock.RUnlock()
	return b.sessions[id]
}

// ListSessions returns all active sessions.
func (b *DebugBroker) ListSessions() []map[string]interface{} {
	b.sessionsLock.RLock()
	defer b.sessionsLock.RUnlock()

	result := make([]map[string]interface{}, 0, len(b.sessions))
	for _, session := range b.sessions {
		result = append(result, map[string]interface{}{
			"id":         session.ID,
			"created_at": session.createdAt,
		})
	}
	return result
}

// GenerateSessionID generates a unique session ID.
func (b *DebugBroker) GenerateSessionID() string {
	b.sessionsLock.Lock()
	defer b.sessionsLock.Unlock()
	b.counter++
	return fmt.Sprintf("session-%d", b.counter)
}

var upgrader = websocket.Upgrader{
	ReadBufferSize:  1024,
	WriteBufferSize: 1024,
	CheckOrigin: func(r *http.Request) bool {
		return true // Allow all origins in debug mode
	},
}

// HandleDebugWebSocket handles WebSocket connections for debug sessions.
func HandleDebugWebSocket(broker *DebugBroker) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		conn, err := upgrader.Upgrade(w, r, nil)
		if err != nil {
			log.Printf("WebSocket upgrade error: %v", err)
			return
		}

		sessionID := broker.GenerateSessionID()
		session := &DebugSession{
			ID:        sessionID,
			conn:      conn,
			send:      make(chan []byte, 256),
			pending:   make(map[string]chan *DebugMessage),
			createdAt: time.Now(),
		}

		broker.AddSession(session)
		log.Printf("Debug session connected: %s", sessionID)

		// Send session ID to client
		sessionMsg := DebugMessage{
			ID:   "session",
			Type: "session",
			Data: json.RawMessage(`{"session_id":"` + sessionID + `"}`),
		}
		msgBytes, _ := json.Marshal(sessionMsg)
		session.send <- msgBytes

		// Start read and write pumps
		go session.writePump(broker)
		go session.readPump(broker)
	}
}

// writePump pumps messages from the send channel to the WebSocket connection.
func (s *DebugSession) writePump(broker *DebugBroker) {
	defer func() {
		s.conn.Close()
		broker.RemoveSession(s.ID)
		log.Printf("Debug session disconnected: %s", s.ID)
	}()

	for {
		select {
		case message, ok := <-s.send:
			if !ok {
				s.conn.WriteMessage(websocket.CloseMessage, []byte{})
				return
			}

			if err := s.conn.WriteMessage(websocket.TextMessage, message); err != nil {
				return
			}
		}
	}
}

// readPump pumps messages from the WebSocket connection.
func (s *DebugSession) readPump(broker *DebugBroker) {
	defer func() {
		s.conn.Close()
	}()

	for {
		_, message, err := s.conn.ReadMessage()
		if err != nil {
			if websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) {
				log.Printf("WebSocket error: %v", err)
			}
			break
		}

		var msg DebugMessage
		if err := json.Unmarshal(message, &msg); err != nil {
			log.Printf("Invalid message: %v", err)
			continue
		}

		// Handle response messages
		if msg.Type == "response" {
			s.pendingLock.Lock()
			if ch, ok := s.pending[msg.ID]; ok {
				ch <- &msg
				delete(s.pending, msg.ID)
			}
			s.pendingLock.Unlock()
		}
	}
}

// SendEval sends an eval request to the session and waits for the response.
func (s *DebugSession) SendEval(id string, code string) (*DebugMessage, error) {
	responseChan := make(chan *DebugMessage, 1)

	s.pendingLock.Lock()
	s.pending[id] = responseChan
	s.pendingLock.Unlock()

	evalData := map[string]string{"code": code}
	dataBytes, _ := json.Marshal(evalData)

	msg := DebugMessage{
		ID:   id,
		Type: "eval",
		Data: dataBytes,
	}
	msgBytes, _ := json.Marshal(msg)

	select {
	case s.send <- msgBytes:
	default:
		s.pendingLock.Lock()
		delete(s.pending, id)
		s.pendingLock.Unlock()
		return nil, nil
	}

	// Wait for response with timeout
	select {
	case response := <-responseChan:
		return response, nil
	case <-time.After(30 * time.Second):
		s.pendingLock.Lock()
		delete(s.pending, id)
		s.pendingLock.Unlock()
		return nil, nil
	}
}

// HandleListSessions returns a list of active debug sessions.
func HandleListSessions(broker *DebugBroker) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		sessions := broker.ListSessions()
		api.JSON(w, http.StatusOK, map[string]interface{}{
			"sessions": sessions,
		})
	}
}


// HandleTestLogin creates a test session with specified roles (debug mode only).
func HandleTestLogin(sessions SessionStore) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var req struct {
			Login string   `json:"login"`
			Roles []string `json:"roles"`
		}
		if err := api.DecodeJSON(r, &req); err != nil {
			api.Error(w, http.StatusBadRequest, "INVALID_REQUEST", err.Error())
			return
		}

		if req.Login == "" {
			req.Login = "test-user"
		}
		if len(req.Roles) == 0 {
			req.Roles = []string{"admin", "fulfillment", "system", "customer"}
		}

		// Create a test user with the specified roles
		user := &User{
			ID:    12345,
			Login: req.Login,
			Name:  "Test User",
			Email: req.Login + "@test.local",
			Roles: req.Roles,
		}

		session, err := sessions.Create(r.Context(), user)
		if err != nil {
			api.Error(w, http.StatusInternalServerError, "SESSION_FAILED", err.Error())
			return
		}

		api.JSON(w, http.StatusOK, map[string]interface{}{
			"token":      session.Token,
			"expires_at": session.ExpiresAt,
			"user":       session.User,
		})
	}
}


// HandleSessionEval sends code to a browser session for evaluation.
func HandleSessionEval(broker *DebugBroker) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		sessionID := r.PathValue("id")
		if sessionID == "" {
			api.Error(w, http.StatusBadRequest, "MISSING_SESSION_ID", "session ID is required")
			return
		}

		session := broker.GetSession(sessionID)
		if session == nil {
			api.Error(w, http.StatusNotFound, "SESSION_NOT_FOUND", "session not found")
			return
		}

		var req struct {
			Code string `json:"code"`
		}
		if err := api.DecodeJSON(r, &req); err != nil {
			api.Error(w, http.StatusBadRequest, "INVALID_REQUEST", err.Error())
			return
		}

		if req.Code == "" {
			api.Error(w, http.StatusBadRequest, "MISSING_CODE", "code is required")
			return
		}

		// Generate unique request ID
		requestID := time.Now().Format("20060102150405.000000")

		response, err := session.SendEval(requestID, req.Code)
		if err != nil {
			api.Error(w, http.StatusInternalServerError, "EVAL_FAILED", err.Error())
			return
		}

		if response == nil {
			api.Error(w, http.StatusGatewayTimeout, "EVAL_TIMEOUT", "evaluation timed out")
			return
		}

		var result map[string]interface{}
		if err := json.Unmarshal(response.Data, &result); err != nil {
			result = map[string]interface{}{"raw": string(response.Data)}
		}

		api.JSON(w, http.StatusOK, result)
	}
}
