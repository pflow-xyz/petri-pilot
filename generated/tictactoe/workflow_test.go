// Code generated by petri-pilot. DO NOT EDIT.

package tictactoe

import (
	"context"
	"testing"

	"github.com/pflow-xyz/petri-pilot/pkg/runtime/eventstore"
)

func TestWorkflowConstants(t *testing.T) {
	// Verify place constants
	places := AllPlaces()
	if len(places) != 32 {
		t.Errorf("expected 32 places, got %d", len(places))
	}

	// Verify transition constants
	transitions := AllTransitions()
	if len(transitions) != 35 {
		t.Errorf("expected 35 transitions, got %d", len(transitions))
	}
}

func TestInitialPlaces(t *testing.T) {
	initial := InitialPlaces()
	_ = initial // suppress unused variable warning if no places have initial values
	if initial[PlaceP00] != 1 {
		t.Errorf("expected PlaceP00 initial = 1, got %d", initial[PlaceP00])
	}
	if initial[PlaceP01] != 1 {
		t.Errorf("expected PlaceP01 initial = 1, got %d", initial[PlaceP01])
	}
	if initial[PlaceP02] != 1 {
		t.Errorf("expected PlaceP02 initial = 1, got %d", initial[PlaceP02])
	}
	if initial[PlaceP10] != 1 {
		t.Errorf("expected PlaceP10 initial = 1, got %d", initial[PlaceP10])
	}
	if initial[PlaceP11] != 1 {
		t.Errorf("expected PlaceP11 initial = 1, got %d", initial[PlaceP11])
	}
	if initial[PlaceP12] != 1 {
		t.Errorf("expected PlaceP12 initial = 1, got %d", initial[PlaceP12])
	}
	if initial[PlaceP20] != 1 {
		t.Errorf("expected PlaceP20 initial = 1, got %d", initial[PlaceP20])
	}
	if initial[PlaceP21] != 1 {
		t.Errorf("expected PlaceP21 initial = 1, got %d", initial[PlaceP21])
	}
	if initial[PlaceP22] != 1 {
		t.Errorf("expected PlaceP22 initial = 1, got %d", initial[PlaceP22])
	}
	if initial[PlaceXTurn] != 1 {
		t.Errorf("expected PlaceXTurn initial = 1, got %d", initial[PlaceXTurn])
	}
	if initial[PlaceCanReset] != 1 {
		t.Errorf("expected PlaceCanReset initial = 1, got %d", initial[PlaceCanReset])
	}
}

func TestNewAggregate(t *testing.T) {
	agg := NewAggregate("")
	if agg.ID() == "" {
		t.Error("expected non-empty aggregate ID")
	}
	// Version starts at -1 before any events are applied
	if agg.Version() != -1 {
		t.Errorf("expected version -1, got %d", agg.Version())
	}
}

func TestAggregateWithID(t *testing.T) {
	agg := NewAggregate("test-123")
	if agg.ID() != "test-123" {
		t.Errorf("expected ID 'test-123', got %q", agg.ID())
	}
}

func TestInitialState(t *testing.T) {
	agg := NewAggregate("")
	places := agg.Places()
	_ = places // suppress unused variable warning if no places have initial values
	if places[PlaceP00] != 1 {
		t.Errorf("expected PlaceP00 = 1, got %d", places[PlaceP00])
	}
	if places[PlaceP01] != 1 {
		t.Errorf("expected PlaceP01 = 1, got %d", places[PlaceP01])
	}
	if places[PlaceP02] != 1 {
		t.Errorf("expected PlaceP02 = 1, got %d", places[PlaceP02])
	}
	if places[PlaceP10] != 1 {
		t.Errorf("expected PlaceP10 = 1, got %d", places[PlaceP10])
	}
	if places[PlaceP11] != 1 {
		t.Errorf("expected PlaceP11 = 1, got %d", places[PlaceP11])
	}
	if places[PlaceP12] != 1 {
		t.Errorf("expected PlaceP12 = 1, got %d", places[PlaceP12])
	}
	if places[PlaceP20] != 1 {
		t.Errorf("expected PlaceP20 = 1, got %d", places[PlaceP20])
	}
	if places[PlaceP21] != 1 {
		t.Errorf("expected PlaceP21 = 1, got %d", places[PlaceP21])
	}
	if places[PlaceP22] != 1 {
		t.Errorf("expected PlaceP22 = 1, got %d", places[PlaceP22])
	}
	if places[PlaceXTurn] != 1 {
		t.Errorf("expected PlaceXTurn = 1, got %d", places[PlaceXTurn])
	}
	if places[PlaceCanReset] != 1 {
		t.Errorf("expected PlaceCanReset = 1, got %d", places[PlaceCanReset])
	}
}

func TestEnabledTransitions(t *testing.T) {
	agg := NewAggregate("")
	enabled := agg.EnabledTransitions()

	// At least one transition should be enabled in initial state
	if len(enabled) == 0 {
		t.Log("Warning: no transitions enabled in initial state")
	}
}

func TestApplicationCreate(t *testing.T) {
	store := eventstore.NewMemoryStore()
	defer store.Close()

	app := NewApplication(store)
	ctx := context.Background()

	id, err := app.Create(ctx)
	if err != nil {
		t.Fatalf("Create failed: %v", err)
	}
	if id == "" {
		t.Error("expected non-empty ID")
	}
}

func TestApplicationLoadNewAggregate(t *testing.T) {
	store := eventstore.NewMemoryStore()
	defer store.Close()

	app := NewApplication(store)
	ctx := context.Background()

	id, _ := app.Create(ctx)
	agg, err := app.Load(ctx, id)
	if err != nil {
		t.Fatalf("Load failed: %v", err)
	}
	if agg.ID() != id {
		t.Errorf("expected ID %q, got %q", id, agg.ID())
	}
}


func TestFirstTransition(t *testing.T) {
	store := eventstore.NewMemoryStore()
	defer store.Close()

	app := NewApplication(store)
	ctx := context.Background()

	// Create new aggregate
	id, _ := app.Create(ctx)

	// Load and check enabled transitions
	agg, _ := app.Load(ctx, id)
	enabled := agg.EnabledTransitions()

	if len(enabled) == 0 {
		t.Skip("No transitions enabled in initial state")
	}

	// Try to execute the first enabled transition
	firstTransition := enabled[0]
	agg, err := app.Execute(ctx, id, firstTransition, nil)
	if err != nil {
		t.Fatalf("Execute %s failed: %v", firstTransition, err)
	}

	// Verify version is 0 (first event, 0-indexed)
	if agg.Version() != 0 {
		t.Errorf("expected version 0 after first transition, got %d", agg.Version())
	}
}


func TestCannotFireDisabledTransition(t *testing.T) {
	store := eventstore.NewMemoryStore()
	defer store.Close()

	app := NewApplication(store)
	ctx := context.Background()

	id, _ := app.Create(ctx)
	agg, _ := app.Load(ctx, id)

	// Find a transition that is NOT enabled
	allTransitions := AllTransitions()
	enabled := agg.EnabledTransitions()
	enabledSet := make(map[string]bool)
	for _, t := range enabled {
		enabledSet[t] = true
	}

	var disabledTransition string
	for _, t := range allTransitions {
		if !enabledSet[t] {
			disabledTransition = t
			break
		}
	}

	if disabledTransition == "" {
		t.Skip("All transitions are enabled in initial state")
	}

	// Try to execute a disabled transition
	_, err := app.Execute(ctx, id, disabledTransition, nil)
	if err == nil {
		t.Errorf("expected error when firing disabled transition %s", disabledTransition)
	}
}
