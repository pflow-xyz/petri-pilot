// Code generated by petri-pilot. DO NOT EDIT.

package graph

import (
	"context"
	"encoding/json"
	"fmt"

	"github.com/pflow-xyz/go-pflow/eventsource"
)

// Resolver is the root resolver for GraphQL queries and mutations.
type Resolver struct {
	App interface {
		Create(ctx context.Context) (string, error)
		Load(ctx context.Context, id string) (Aggregate, error)
		GetState(ctx context.Context, id string) (Aggregate, error)
		Execute(ctx context.Context, id, transition string, data map[string]any) (Aggregate, error)
		HealthCheck(ctx context.Context) error
		GetStore() eventsource.Store
	}
}

// Aggregate interface for type safety
type Aggregate interface {
	ID() string
	Version() int
	State() any
	Places() map[string]int
	EnabledTransitions() []string
}

// NewResolver creates a new GraphQL resolver.
func NewResolver(app interface {
	Create(ctx context.Context) (string, error)
	Load(ctx context.Context, id string) (Aggregate, error)
	GetState(ctx context.Context, id string) (Aggregate, error)
	Execute(ctx context.Context, id, transition string, data map[string]any) (Aggregate, error)
	HealthCheck(ctx context.Context) error
	GetStore() eventsource.Store
}) *Resolver {
	return &Resolver{App: app}
}

// Query resolvers

// TicTacToe returns the aggregate state by ID.
func (r *Resolver) TicTacToe(ctx context.Context, id string) (*AggregateState, error) {
	agg, err := r.App.GetState(ctx, id)
	if err != nil {
		return nil, err
	}
	return aggregateToState(agg), nil
}

// TicTacToeList returns a paginated list of aggregates.
func (r *Resolver) TicTacToeList(ctx context.Context, place *string, page *int, perPage *int) (*AggregateList, error) {
	// Default pagination
	p := 1
	pp := 50
	if page != nil {
		p = *page
	}
	if perPage != nil {
		pp = *perPage
	}

	placeFilter := ""
	if place != nil {
		placeFilter = *place
	}
	store := r.App.GetStore()
	adminStore, ok := store.(interface {
		ListInstances(ctx context.Context, place, from, to string, page, perPage int) ([]eventsource.Instance, int, error)
	})
	if !ok {
		return &AggregateList{
			Items:   []*AggregateState{},
			Total:   0,
			Page:    p,
			PerPage: pp,
		}, nil
	}

	instances, total, err := adminStore.ListInstances(ctx, placeFilter, "", "", p, pp)
	if err != nil {
		return nil, err
	}

	items := make([]*AggregateState, 0, len(instances))
	for _, inst := range instances {
		agg, err := r.App.Load(ctx, inst.ID)
		if err != nil {
			continue
		}
		items = append(items, aggregateToState(agg))
	}

	return &AggregateList{
		Items:   items,
		Total:   total,
		Page:    p,
		PerPage: pp,
	}, nil
}

// AdminStats returns admin statistics.
func (r *Resolver) AdminStats(ctx context.Context) (*AdminStats, error) {
	store := r.App.GetStore()
	adminStore, ok := store.(interface {
		GetStats(ctx context.Context) (*eventsource.Stats, error)
	})
	if !ok {
		return nil, fmt.Errorf("admin operations not supported")
	}

	stats, err := adminStore.GetStats(ctx)
	if err != nil {
		return nil, err
	}

	byPlace := make([]*PlaceCount, 0, len(stats.ByPlace))
	for place, count := range stats.ByPlace {
		byPlace = append(byPlace, &PlaceCount{
			Place: place,
			Count: count,
		})
	}

	return &AdminStats{
		TotalInstances: stats.TotalInstances,
		ByPlace:        byPlace,
	}, nil
}


// Events returns the event history for an aggregate.
func (r *Resolver) Events(ctx context.Context, aggregateID string, from *int) ([]*Event, error) {
	store := r.App.GetStore()
	fromVersion := 0
	if from != nil {
		fromVersion = *from
	}

	events, err := store.Read(ctx, aggregateID, fromVersion)
	if err != nil {
		return nil, err
	}

	result := make([]*Event, len(events))
	for i, evt := range events {
		data, _ := json.Marshal(evt.Data)
		result[i] = &Event{
			ID:        fmt.Sprintf("%s-%d", evt.StreamID, evt.Version),
			StreamID:  evt.StreamID,
			Type:      evt.Type,
			Version:   evt.Version,
			Timestamp: evt.Timestamp,
			Data:      string(data),
		}
	}

	return result, nil
}

// StateAtVersion returns the aggregate state at a specific version.
func (r *Resolver) StateAtVersion(ctx context.Context, aggregateID string, version int) (*AggregateState, error) {
	// This is a simplified implementation - would need aggregate rebuild logic
	agg, err := r.App.GetState(ctx, aggregateID)
	if err != nil {
		return nil, err
	}

	// TODO: Implement proper version replay
	state := aggregateToState(agg)
	state.Version = version
	return state, nil
}


// Mutation resolvers

// CreateTictactoe creates a new aggregate instance.
func (r *Resolver) CreateTictactoe(ctx context.Context) (*AggregateState, error) {
	id, err := r.App.Create(ctx)
	if err != nil {
		return nil, err
	}

	agg, err := r.App.Load(ctx, id)
	if err != nil {
		return nil, err
	}

	return aggregateToState(agg), nil
}


// XPlay00 executes the x_play_00 transition.
func (r *Resolver) XPlay00(ctx context.Context, input XPlay00Input) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "x_play_00", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// XPlay01 executes the x_play_01 transition.
func (r *Resolver) XPlay01(ctx context.Context, input XPlay01Input) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "x_play_01", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// XPlay02 executes the x_play_02 transition.
func (r *Resolver) XPlay02(ctx context.Context, input XPlay02Input) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "x_play_02", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// XPlay10 executes the x_play_10 transition.
func (r *Resolver) XPlay10(ctx context.Context, input XPlay10Input) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "x_play_10", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// XPlay11 executes the x_play_11 transition.
func (r *Resolver) XPlay11(ctx context.Context, input XPlay11Input) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "x_play_11", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// XPlay12 executes the x_play_12 transition.
func (r *Resolver) XPlay12(ctx context.Context, input XPlay12Input) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "x_play_12", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// XPlay20 executes the x_play_20 transition.
func (r *Resolver) XPlay20(ctx context.Context, input XPlay20Input) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "x_play_20", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// XPlay21 executes the x_play_21 transition.
func (r *Resolver) XPlay21(ctx context.Context, input XPlay21Input) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "x_play_21", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// XPlay22 executes the x_play_22 transition.
func (r *Resolver) XPlay22(ctx context.Context, input XPlay22Input) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "x_play_22", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// OPlay00 executes the o_play_00 transition.
func (r *Resolver) OPlay00(ctx context.Context, input OPlay00Input) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "o_play_00", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// OPlay01 executes the o_play_01 transition.
func (r *Resolver) OPlay01(ctx context.Context, input OPlay01Input) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "o_play_01", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// OPlay02 executes the o_play_02 transition.
func (r *Resolver) OPlay02(ctx context.Context, input OPlay02Input) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "o_play_02", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// OPlay10 executes the o_play_10 transition.
func (r *Resolver) OPlay10(ctx context.Context, input OPlay10Input) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "o_play_10", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// OPlay11 executes the o_play_11 transition.
func (r *Resolver) OPlay11(ctx context.Context, input OPlay11Input) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "o_play_11", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// OPlay12 executes the o_play_12 transition.
func (r *Resolver) OPlay12(ctx context.Context, input OPlay12Input) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "o_play_12", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// OPlay20 executes the o_play_20 transition.
func (r *Resolver) OPlay20(ctx context.Context, input OPlay20Input) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "o_play_20", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// OPlay21 executes the o_play_21 transition.
func (r *Resolver) OPlay21(ctx context.Context, input OPlay21Input) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "o_play_21", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// OPlay22 executes the o_play_22 transition.
func (r *Resolver) OPlay22(ctx context.Context, input OPlay22Input) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "o_play_22", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// Reset executes the reset transition.
func (r *Resolver) Reset(ctx context.Context, input ResetInput) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "reset", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// XWinRow0 executes the x_win_row0 transition.
func (r *Resolver) XWinRow0(ctx context.Context, input XWinRow0Input) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "x_win_row0", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// XWinRow1 executes the x_win_row1 transition.
func (r *Resolver) XWinRow1(ctx context.Context, input XWinRow1Input) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "x_win_row1", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// XWinRow2 executes the x_win_row2 transition.
func (r *Resolver) XWinRow2(ctx context.Context, input XWinRow2Input) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "x_win_row2", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// XWinCol0 executes the x_win_col0 transition.
func (r *Resolver) XWinCol0(ctx context.Context, input XWinCol0Input) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "x_win_col0", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// XWinCol1 executes the x_win_col1 transition.
func (r *Resolver) XWinCol1(ctx context.Context, input XWinCol1Input) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "x_win_col1", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// XWinCol2 executes the x_win_col2 transition.
func (r *Resolver) XWinCol2(ctx context.Context, input XWinCol2Input) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "x_win_col2", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// XWinDiag executes the x_win_diag transition.
func (r *Resolver) XWinDiag(ctx context.Context, input XWinDiagInput) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "x_win_diag", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// XWinAnti executes the x_win_anti transition.
func (r *Resolver) XWinAnti(ctx context.Context, input XWinAntiInput) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "x_win_anti", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// OWinRow0 executes the o_win_row0 transition.
func (r *Resolver) OWinRow0(ctx context.Context, input OWinRow0Input) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "o_win_row0", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// OWinRow1 executes the o_win_row1 transition.
func (r *Resolver) OWinRow1(ctx context.Context, input OWinRow1Input) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "o_win_row1", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// OWinRow2 executes the o_win_row2 transition.
func (r *Resolver) OWinRow2(ctx context.Context, input OWinRow2Input) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "o_win_row2", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// OWinCol0 executes the o_win_col0 transition.
func (r *Resolver) OWinCol0(ctx context.Context, input OWinCol0Input) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "o_win_col0", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// OWinCol1 executes the o_win_col1 transition.
func (r *Resolver) OWinCol1(ctx context.Context, input OWinCol1Input) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "o_win_col1", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// OWinCol2 executes the o_win_col2 transition.
func (r *Resolver) OWinCol2(ctx context.Context, input OWinCol2Input) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "o_win_col2", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// OWinDiag executes the o_win_diag transition.
func (r *Resolver) OWinDiag(ctx context.Context, input OWinDiagInput) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "o_win_diag", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// OWinAnti executes the o_win_anti transition.
func (r *Resolver) OWinAnti(ctx context.Context, input OWinAntiInput) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "o_win_anti", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// Draw executes the draw transition.
func (r *Resolver) Draw(ctx context.Context, input DrawInput) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "draw", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}



// Helper functions

func aggregateToState(agg Aggregate) *AggregateState {
	places := agg.Places()
	return &AggregateState{
		ID:                 agg.ID(),
		Version:            agg.Version(),
		State:              stateToModel(agg.State()),
		Places:             placesToModel(places),
		EnabledTransitions: agg.EnabledTransitions(),
	}
}

func stateToModel(state any) *State {
	s := &State{}
	// Convert struct to map via JSON roundtrip for uniform field access
	m := stateToMap(state)
	if v, ok := m["p00"]; ok {
		s.P00 = v
	}
	if v, ok := m["p01"]; ok {
		s.P01 = v
	}
	if v, ok := m["p02"]; ok {
		s.P02 = v
	}
	if v, ok := m["p10"]; ok {
		s.P10 = v
	}
	if v, ok := m["p11"]; ok {
		s.P11 = v
	}
	if v, ok := m["p12"]; ok {
		s.P12 = v
	}
	if v, ok := m["p20"]; ok {
		s.P20 = v
	}
	if v, ok := m["p21"]; ok {
		s.P21 = v
	}
	if v, ok := m["p22"]; ok {
		s.P22 = v
	}
	if v, ok := m["x00"]; ok {
		s.X00 = v
	}
	if v, ok := m["x01"]; ok {
		s.X01 = v
	}
	if v, ok := m["x02"]; ok {
		s.X02 = v
	}
	if v, ok := m["x10"]; ok {
		s.X10 = v
	}
	if v, ok := m["x11"]; ok {
		s.X11 = v
	}
	if v, ok := m["x12"]; ok {
		s.X12 = v
	}
	if v, ok := m["x20"]; ok {
		s.X20 = v
	}
	if v, ok := m["x21"]; ok {
		s.X21 = v
	}
	if v, ok := m["x22"]; ok {
		s.X22 = v
	}
	if v, ok := m["o00"]; ok {
		s.O00 = v
	}
	if v, ok := m["o01"]; ok {
		s.O01 = v
	}
	if v, ok := m["o02"]; ok {
		s.O02 = v
	}
	if v, ok := m["o10"]; ok {
		s.O10 = v
	}
	if v, ok := m["o11"]; ok {
		s.O11 = v
	}
	if v, ok := m["o12"]; ok {
		s.O12 = v
	}
	if v, ok := m["o20"]; ok {
		s.O20 = v
	}
	if v, ok := m["o21"]; ok {
		s.O21 = v
	}
	if v, ok := m["o22"]; ok {
		s.O22 = v
	}
	if v, ok := m["x_turn"]; ok {
		s.XTurn = v
	}
	if v, ok := m["o_turn"]; ok {
		s.OTurn = v
	}
	if v, ok := m["win_x"]; ok {
		s.WinX = v
	}
	if v, ok := m["win_o"]; ok {
		s.WinO = v
	}
	if v, ok := m["can_reset"]; ok {
		s.CanReset = v
	}
	if v, ok := m["game_active"]; ok {
		s.GameActive = v
	}
	if v, ok := m["move_tokens"]; ok {
		s.MoveTokens = v
	}
	return s
}

func stateToMap(state any) map[string]any {
	// Try direct map assertion first
	if m, ok := state.(map[string]any); ok {
		return m
	}
	// Fall back to JSON roundtrip for struct types
	b, err := json.Marshal(state)
	if err != nil {
		return nil
	}
	var m map[string]any
	if err := json.Unmarshal(b, &m); err != nil {
		return nil
	}
	return m
}

func placesToModel(places map[string]int) *Places {
	p := &Places{}
	if v, ok := places["p00"]; ok {
		p.P00 = v
	}
	if v, ok := places["p01"]; ok {
		p.P01 = v
	}
	if v, ok := places["p02"]; ok {
		p.P02 = v
	}
	if v, ok := places["p10"]; ok {
		p.P10 = v
	}
	if v, ok := places["p11"]; ok {
		p.P11 = v
	}
	if v, ok := places["p12"]; ok {
		p.P12 = v
	}
	if v, ok := places["p20"]; ok {
		p.P20 = v
	}
	if v, ok := places["p21"]; ok {
		p.P21 = v
	}
	if v, ok := places["p22"]; ok {
		p.P22 = v
	}
	if v, ok := places["x00"]; ok {
		p.X00 = v
	}
	if v, ok := places["x01"]; ok {
		p.X01 = v
	}
	if v, ok := places["x02"]; ok {
		p.X02 = v
	}
	if v, ok := places["x10"]; ok {
		p.X10 = v
	}
	if v, ok := places["x11"]; ok {
		p.X11 = v
	}
	if v, ok := places["x12"]; ok {
		p.X12 = v
	}
	if v, ok := places["x20"]; ok {
		p.X20 = v
	}
	if v, ok := places["x21"]; ok {
		p.X21 = v
	}
	if v, ok := places["x22"]; ok {
		p.X22 = v
	}
	if v, ok := places["o00"]; ok {
		p.O00 = v
	}
	if v, ok := places["o01"]; ok {
		p.O01 = v
	}
	if v, ok := places["o02"]; ok {
		p.O02 = v
	}
	if v, ok := places["o10"]; ok {
		p.O10 = v
	}
	if v, ok := places["o11"]; ok {
		p.O11 = v
	}
	if v, ok := places["o12"]; ok {
		p.O12 = v
	}
	if v, ok := places["o20"]; ok {
		p.O20 = v
	}
	if v, ok := places["o21"]; ok {
		p.O21 = v
	}
	if v, ok := places["o22"]; ok {
		p.O22 = v
	}
	if v, ok := places["x_turn"]; ok {
		p.XTurn = v
	}
	if v, ok := places["o_turn"]; ok {
		p.OTurn = v
	}
	if v, ok := places["win_x"]; ok {
		p.WinX = v
	}
	if v, ok := places["win_o"]; ok {
		p.WinO = v
	}
	if v, ok := places["can_reset"]; ok {
		p.CanReset = v
	}
	if v, ok := places["game_active"]; ok {
		p.GameActive = v
	}
	if v, ok := places["move_tokens"]; ok {
		p.MoveTokens = v
	}
	return p
}

// GraphQL model types

type AggregateState struct {
	ID                 string   `json:"id"`
	Version            int      `json:"version"`
	State              *State   `json:"state"`
	Places             *Places  `json:"places"`
	EnabledTransitions []string `json:"enabledTransitions"`
}

type State struct {
	P00 any `json:"p00"`
	P01 any `json:"p01"`
	P02 any `json:"p02"`
	P10 any `json:"p10"`
	P11 any `json:"p11"`
	P12 any `json:"p12"`
	P20 any `json:"p20"`
	P21 any `json:"p21"`
	P22 any `json:"p22"`
	X00 any `json:"x00"`
	X01 any `json:"x01"`
	X02 any `json:"x02"`
	X10 any `json:"x10"`
	X11 any `json:"x11"`
	X12 any `json:"x12"`
	X20 any `json:"x20"`
	X21 any `json:"x21"`
	X22 any `json:"x22"`
	O00 any `json:"o00"`
	O01 any `json:"o01"`
	O02 any `json:"o02"`
	O10 any `json:"o10"`
	O11 any `json:"o11"`
	O12 any `json:"o12"`
	O20 any `json:"o20"`
	O21 any `json:"o21"`
	O22 any `json:"o22"`
	XTurn any `json:"xTurn"`
	OTurn any `json:"oTurn"`
	WinX any `json:"winX"`
	WinO any `json:"winO"`
	CanReset any `json:"canReset"`
	GameActive any `json:"gameActive"`
	MoveTokens any `json:"moveTokens"`
}

type Places struct {
	P00 int `json:"p00"`
	P01 int `json:"p01"`
	P02 int `json:"p02"`
	P10 int `json:"p10"`
	P11 int `json:"p11"`
	P12 int `json:"p12"`
	P20 int `json:"p20"`
	P21 int `json:"p21"`
	P22 int `json:"p22"`
	X00 int `json:"x00"`
	X01 int `json:"x01"`
	X02 int `json:"x02"`
	X10 int `json:"x10"`
	X11 int `json:"x11"`
	X12 int `json:"x12"`
	X20 int `json:"x20"`
	X21 int `json:"x21"`
	X22 int `json:"x22"`
	O00 int `json:"o00"`
	O01 int `json:"o01"`
	O02 int `json:"o02"`
	O10 int `json:"o10"`
	O11 int `json:"o11"`
	O12 int `json:"o12"`
	O20 int `json:"o20"`
	O21 int `json:"o21"`
	O22 int `json:"o22"`
	XTurn int `json:"xTurn"`
	OTurn int `json:"oTurn"`
	WinX int `json:"winX"`
	WinO int `json:"winO"`
	CanReset int `json:"canReset"`
	GameActive int `json:"gameActive"`
	MoveTokens int `json:"moveTokens"`
}

type TransitionResult struct {
	Success            bool     `json:"success"`
	AggregateID        *string  `json:"aggregateId"`
	Version            *int     `json:"version"`
	State              *Places  `json:"state"`
	EnabledTransitions []string `json:"enabledTransitions"`
	Error              *string  `json:"error"`
}

type AggregateList struct {
	Items   []*AggregateState `json:"items"`
	Total   int               `json:"total"`
	Page    int               `json:"page"`
	PerPage int               `json:"perPage"`
}

type AdminStats struct {
	TotalInstances int           `json:"totalInstances"`
	ByPlace        []*PlaceCount `json:"byPlace"`
}

type PlaceCount struct {
	Place string `json:"place"`
	Count int    `json:"count"`
}


type Event struct {
	ID        string `json:"id"`
	StreamID  string `json:"streamId"`
	Type      string `json:"type"`
	Version   int    `json:"version"`
	Timestamp any    `json:"timestamp"`
	Data      string `json:"data"`
}


// Input types

type XPlay00Input struct {
	AggregateID string
}


type XPlay01Input struct {
	AggregateID string
}


type XPlay02Input struct {
	AggregateID string
}


type XPlay10Input struct {
	AggregateID string
}


type XPlay11Input struct {
	AggregateID string
}


type XPlay12Input struct {
	AggregateID string
}


type XPlay20Input struct {
	AggregateID string
}


type XPlay21Input struct {
	AggregateID string
}


type XPlay22Input struct {
	AggregateID string
}


type OPlay00Input struct {
	AggregateID string
}


type OPlay01Input struct {
	AggregateID string
}


type OPlay02Input struct {
	AggregateID string
}


type OPlay10Input struct {
	AggregateID string
}


type OPlay11Input struct {
	AggregateID string
}


type OPlay12Input struct {
	AggregateID string
}


type OPlay20Input struct {
	AggregateID string
}


type OPlay21Input struct {
	AggregateID string
}


type OPlay22Input struct {
	AggregateID string
}


type ResetInput struct {
	AggregateID string
}


type XWinRow0Input struct {
	AggregateID string
}


type XWinRow1Input struct {
	AggregateID string
}


type XWinRow2Input struct {
	AggregateID string
}


type XWinCol0Input struct {
	AggregateID string
}


type XWinCol1Input struct {
	AggregateID string
}


type XWinCol2Input struct {
	AggregateID string
}


type XWinDiagInput struct {
	AggregateID string
}


type XWinAntiInput struct {
	AggregateID string
}


type OWinRow0Input struct {
	AggregateID string
}


type OWinRow1Input struct {
	AggregateID string
}


type OWinRow2Input struct {
	AggregateID string
}


type OWinCol0Input struct {
	AggregateID string
}


type OWinCol1Input struct {
	AggregateID string
}


type OWinCol2Input struct {
	AggregateID string
}


type OWinDiagInput struct {
	AggregateID string
}


type OWinAntiInput struct {
	AggregateID string
}


type DrawInput struct {
	AggregateID string
}

