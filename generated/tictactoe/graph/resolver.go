// Code generated by petri-pilot. DO NOT EDIT.

package graph

import (
	"context"
	"encoding/json"
	"fmt"

	"github.com/pflow-xyz/go-pflow/eventsource"
)

// Resolver is the root resolver for GraphQL queries and mutations.
type Resolver struct {
	App interface {
		Create(ctx context.Context) (string, error)
		Load(ctx context.Context, id string) (Aggregate, error)
		GetState(ctx context.Context, id string) (Aggregate, error)
		Execute(ctx context.Context, id, transition string, data map[string]any) (Aggregate, error)
		HealthCheck(ctx context.Context) error
		GetStore() eventsource.Store
	}
}

// Aggregate interface for type safety
type Aggregate interface {
	ID() string
	Version() int
	State() any
	Places() map[string]int
	EnabledTransitions() []string
}

// NewResolver creates a new GraphQL resolver.
func NewResolver(app interface {
	Create(ctx context.Context) (string, error)
	Load(ctx context.Context, id string) (Aggregate, error)
	GetState(ctx context.Context, id string) (Aggregate, error)
	Execute(ctx context.Context, id, transition string, data map[string]any) (Aggregate, error)
	HealthCheck(ctx context.Context) error
	GetStore() eventsource.Store
}) *Resolver {
	return &Resolver{App: app}
}

// Query resolvers

// TicTacToe returns the aggregate state by ID.
func (r *Resolver) TicTacToe(ctx context.Context, id string) (*AggregateState, error) {
	agg, err := r.App.GetState(ctx, id)
	if err != nil {
		return nil, err
	}
	return aggregateToState(agg), nil
}

// TicTacToeList returns a paginated list of aggregates.
func (r *Resolver) TicTacToeList(ctx context.Context, place *string, page *int, perPage *int) (*AggregateList, error) {
	// Default pagination
	p := 1
	pp := 50
	if page != nil {
		p = *page
	}
	if perPage != nil {
		pp = *perPage
	}

	placeFilter := ""
	if place != nil {
		placeFilter = *place
	}
	store := r.App.GetStore()
	adminStore, ok := store.(interface {
		ListInstances(ctx context.Context, place, from, to string, page, perPage int) ([]eventsource.Instance, int, error)
	})
	if !ok {
		return &AggregateList{
			Items:   []*AggregateState{},
			Total:   0,
			Page:    p,
			PerPage: pp,
		}, nil
	}

	instances, total, err := adminStore.ListInstances(ctx, placeFilter, "", "", p, pp)
	if err != nil {
		return nil, err
	}

	items := make([]*AggregateState, 0, len(instances))
	for _, inst := range instances {
		agg, err := r.App.Load(ctx, inst.ID)
		if err != nil {
			continue
		}
		items = append(items, aggregateToState(agg))
	}

	return &AggregateList{
		Items:   items,
		Total:   total,
		Page:    p,
		PerPage: pp,
	}, nil
}

// AdminStats returns admin statistics.
func (r *Resolver) AdminStats(ctx context.Context) (*AdminStats, error) {
	store := r.App.GetStore()
	adminStore, ok := store.(interface {
		GetStats(ctx context.Context) (*eventsource.Stats, error)
	})
	if !ok {
		return nil, fmt.Errorf("admin operations not supported")
	}

	stats, err := adminStore.GetStats(ctx)
	if err != nil {
		return nil, err
	}

	byPlace := make([]*PlaceCount, 0, len(stats.ByPlace))
	for place, count := range stats.ByPlace {
		byPlace = append(byPlace, &PlaceCount{
			Place: place,
			Count: count,
		})
	}

	return &AdminStats{
		TotalInstances: stats.TotalInstances,
		ByPlace:        byPlace,
	}, nil
}


// Events returns the event history for an aggregate.
func (r *Resolver) Events(ctx context.Context, aggregateID string, from *int) ([]*Event, error) {
	store := r.App.GetStore()
	fromVersion := 0
	if from != nil {
		fromVersion = *from
	}

	events, err := store.Read(ctx, aggregateID, fromVersion)
	if err != nil {
		return nil, err
	}

	result := make([]*Event, len(events))
	for i, evt := range events {
		data, _ := json.Marshal(evt.Data)
		result[i] = &Event{
			ID:        fmt.Sprintf("%s-%d", evt.StreamID, evt.Version),
			StreamID:  evt.StreamID,
			Type:      evt.Type,
			Version:   evt.Version,
			Timestamp: evt.Timestamp,
			Data:      string(data),
		}
	}

	return result, nil
}

// StateAtVersion returns the aggregate state at a specific version.
func (r *Resolver) StateAtVersion(ctx context.Context, aggregateID string, version int) (*AggregateState, error) {
	// This is a simplified implementation - would need aggregate rebuild logic
	agg, err := r.App.GetState(ctx, aggregateID)
	if err != nil {
		return nil, err
	}

	// TODO: Implement proper version replay
	state := aggregateToState(agg)
	state.Version = version
	return state, nil
}


// Mutation resolvers

// CreateTicTacToe creates a new aggregate instance.
func (r *Resolver) CreateTicTacToe(ctx context.Context) (*AggregateState, error) {
	id, err := r.App.Create(ctx)
	if err != nil {
		return nil, err
	}

	agg, err := r.App.Load(ctx, id)
	if err != nil {
		return nil, err
	}

	return aggregateToState(agg), nil
}


// XPlay00 executes the x_play_00 transition.
func (r *Resolver) XPlay00(ctx context.Context, input XPlay00Input) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "x_play_00", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// XPlay01 executes the x_play_01 transition.
func (r *Resolver) XPlay01(ctx context.Context, input XPlay01Input) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "x_play_01", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// XPlay02 executes the x_play_02 transition.
func (r *Resolver) XPlay02(ctx context.Context, input XPlay02Input) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "x_play_02", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// XPlay10 executes the x_play_10 transition.
func (r *Resolver) XPlay10(ctx context.Context, input XPlay10Input) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "x_play_10", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// XPlay11 executes the x_play_11 transition.
func (r *Resolver) XPlay11(ctx context.Context, input XPlay11Input) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "x_play_11", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// XPlay12 executes the x_play_12 transition.
func (r *Resolver) XPlay12(ctx context.Context, input XPlay12Input) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "x_play_12", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// XPlay20 executes the x_play_20 transition.
func (r *Resolver) XPlay20(ctx context.Context, input XPlay20Input) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "x_play_20", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// XPlay21 executes the x_play_21 transition.
func (r *Resolver) XPlay21(ctx context.Context, input XPlay21Input) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "x_play_21", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// XPlay22 executes the x_play_22 transition.
func (r *Resolver) XPlay22(ctx context.Context, input XPlay22Input) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "x_play_22", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// OPlay00 executes the o_play_00 transition.
func (r *Resolver) OPlay00(ctx context.Context, input OPlay00Input) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "o_play_00", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// OPlay01 executes the o_play_01 transition.
func (r *Resolver) OPlay01(ctx context.Context, input OPlay01Input) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "o_play_01", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// OPlay02 executes the o_play_02 transition.
func (r *Resolver) OPlay02(ctx context.Context, input OPlay02Input) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "o_play_02", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// OPlay10 executes the o_play_10 transition.
func (r *Resolver) OPlay10(ctx context.Context, input OPlay10Input) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "o_play_10", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// OPlay11 executes the o_play_11 transition.
func (r *Resolver) OPlay11(ctx context.Context, input OPlay11Input) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "o_play_11", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// OPlay12 executes the o_play_12 transition.
func (r *Resolver) OPlay12(ctx context.Context, input OPlay12Input) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "o_play_12", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// OPlay20 executes the o_play_20 transition.
func (r *Resolver) OPlay20(ctx context.Context, input OPlay20Input) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "o_play_20", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// OPlay21 executes the o_play_21 transition.
func (r *Resolver) OPlay21(ctx context.Context, input OPlay21Input) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "o_play_21", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// OPlay22 executes the o_play_22 transition.
func (r *Resolver) OPlay22(ctx context.Context, input OPlay22Input) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "o_play_22", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// Reset executes the reset transition.
func (r *Resolver) Reset(ctx context.Context, input ResetInput) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "reset", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// XWinRow0 executes the x_win_row0 transition.
func (r *Resolver) XWinRow0(ctx context.Context, input XWinRow0Input) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "x_win_row0", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// XWinRow1 executes the x_win_row1 transition.
func (r *Resolver) XWinRow1(ctx context.Context, input XWinRow1Input) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "x_win_row1", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// XWinRow2 executes the x_win_row2 transition.
func (r *Resolver) XWinRow2(ctx context.Context, input XWinRow2Input) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "x_win_row2", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// XWinCol0 executes the x_win_col0 transition.
func (r *Resolver) XWinCol0(ctx context.Context, input XWinCol0Input) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "x_win_col0", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// XWinCol1 executes the x_win_col1 transition.
func (r *Resolver) XWinCol1(ctx context.Context, input XWinCol1Input) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "x_win_col1", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// XWinCol2 executes the x_win_col2 transition.
func (r *Resolver) XWinCol2(ctx context.Context, input XWinCol2Input) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "x_win_col2", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// XWinDiag executes the x_win_diag transition.
func (r *Resolver) XWinDiag(ctx context.Context, input XWinDiagInput) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "x_win_diag", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// XWinAnti executes the x_win_anti transition.
func (r *Resolver) XWinAnti(ctx context.Context, input XWinAntiInput) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "x_win_anti", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// OWinRow0 executes the o_win_row0 transition.
func (r *Resolver) OWinRow0(ctx context.Context, input OWinRow0Input) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "o_win_row0", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// OWinRow1 executes the o_win_row1 transition.
func (r *Resolver) OWinRow1(ctx context.Context, input OWinRow1Input) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "o_win_row1", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// OWinRow2 executes the o_win_row2 transition.
func (r *Resolver) OWinRow2(ctx context.Context, input OWinRow2Input) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "o_win_row2", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// OWinCol0 executes the o_win_col0 transition.
func (r *Resolver) OWinCol0(ctx context.Context, input OWinCol0Input) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "o_win_col0", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// OWinCol1 executes the o_win_col1 transition.
func (r *Resolver) OWinCol1(ctx context.Context, input OWinCol1Input) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "o_win_col1", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// OWinCol2 executes the o_win_col2 transition.
func (r *Resolver) OWinCol2(ctx context.Context, input OWinCol2Input) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "o_win_col2", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// OWinDiag executes the o_win_diag transition.
func (r *Resolver) OWinDiag(ctx context.Context, input OWinDiagInput) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "o_win_diag", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// OWinAnti executes the o_win_anti transition.
func (r *Resolver) OWinAnti(ctx context.Context, input OWinAntiInput) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "o_win_anti", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}



// Helper functions

func aggregateToState(agg Aggregate) *AggregateState {
	places := agg.Places()
	return &AggregateState{
		ID:                 agg.ID(),
		Version:            agg.Version(),
		State:              stateToModel(agg.State()),
		Places:             placesToModel(places),
		EnabledTransitions: agg.EnabledTransitions(),
	}
}

func stateToModel(state any) *State {
	s := &State{}
	if m, ok := state.(map[string]any); ok {
		if v, ok := m["p00"].(int); ok {
			s.P00 = v
		}
		if v, ok := m["p01"].(int); ok {
			s.P01 = v
		}
		if v, ok := m["p02"].(int); ok {
			s.P02 = v
		}
		if v, ok := m["p10"].(int); ok {
			s.P10 = v
		}
		if v, ok := m["p11"].(int); ok {
			s.P11 = v
		}
		if v, ok := m["p12"].(int); ok {
			s.P12 = v
		}
		if v, ok := m["p20"].(int); ok {
			s.P20 = v
		}
		if v, ok := m["p21"].(int); ok {
			s.P21 = v
		}
		if v, ok := m["p22"].(int); ok {
			s.P22 = v
		}
		if v, ok := m["x00"].(int); ok {
			s.X00 = v
		}
		if v, ok := m["x01"].(int); ok {
			s.X01 = v
		}
		if v, ok := m["x02"].(int); ok {
			s.X02 = v
		}
		if v, ok := m["x10"].(int); ok {
			s.X10 = v
		}
		if v, ok := m["x11"].(int); ok {
			s.X11 = v
		}
		if v, ok := m["x12"].(int); ok {
			s.X12 = v
		}
		if v, ok := m["x20"].(int); ok {
			s.X20 = v
		}
		if v, ok := m["x21"].(int); ok {
			s.X21 = v
		}
		if v, ok := m["x22"].(int); ok {
			s.X22 = v
		}
		if v, ok := m["o00"].(int); ok {
			s.O00 = v
		}
		if v, ok := m["o01"].(int); ok {
			s.O01 = v
		}
		if v, ok := m["o02"].(int); ok {
			s.O02 = v
		}
		if v, ok := m["o10"].(int); ok {
			s.O10 = v
		}
		if v, ok := m["o11"].(int); ok {
			s.O11 = v
		}
		if v, ok := m["o12"].(int); ok {
			s.O12 = v
		}
		if v, ok := m["o20"].(int); ok {
			s.O20 = v
		}
		if v, ok := m["o21"].(int); ok {
			s.O21 = v
		}
		if v, ok := m["o22"].(int); ok {
			s.O22 = v
		}
		if v, ok := m["x_turn"].(int); ok {
			s.XTurn = v
		}
		if v, ok := m["o_turn"].(int); ok {
			s.OTurn = v
		}
		if v, ok := m["win_x"].(int); ok {
			s.WinX = v
		}
		if v, ok := m["win_o"].(int); ok {
			s.WinO = v
		}
		if v, ok := m["can_reset"].(int); ok {
			s.CanReset = v
		}
		if v, ok := m["game_active"].(int); ok {
			s.GameActive = v
		}
	}
	return s
}

func placesToModel(places map[string]int) *Places {
	p := &Places{}
	if v, ok := places["p00"]; ok {
		p.P00 = v
	}
	if v, ok := places["p01"]; ok {
		p.P01 = v
	}
	if v, ok := places["p02"]; ok {
		p.P02 = v
	}
	if v, ok := places["p10"]; ok {
		p.P10 = v
	}
	if v, ok := places["p11"]; ok {
		p.P11 = v
	}
	if v, ok := places["p12"]; ok {
		p.P12 = v
	}
	if v, ok := places["p20"]; ok {
		p.P20 = v
	}
	if v, ok := places["p21"]; ok {
		p.P21 = v
	}
	if v, ok := places["p22"]; ok {
		p.P22 = v
	}
	if v, ok := places["x00"]; ok {
		p.X00 = v
	}
	if v, ok := places["x01"]; ok {
		p.X01 = v
	}
	if v, ok := places["x02"]; ok {
		p.X02 = v
	}
	if v, ok := places["x10"]; ok {
		p.X10 = v
	}
	if v, ok := places["x11"]; ok {
		p.X11 = v
	}
	if v, ok := places["x12"]; ok {
		p.X12 = v
	}
	if v, ok := places["x20"]; ok {
		p.X20 = v
	}
	if v, ok := places["x21"]; ok {
		p.X21 = v
	}
	if v, ok := places["x22"]; ok {
		p.X22 = v
	}
	if v, ok := places["o00"]; ok {
		p.O00 = v
	}
	if v, ok := places["o01"]; ok {
		p.O01 = v
	}
	if v, ok := places["o02"]; ok {
		p.O02 = v
	}
	if v, ok := places["o10"]; ok {
		p.O10 = v
	}
	if v, ok := places["o11"]; ok {
		p.O11 = v
	}
	if v, ok := places["o12"]; ok {
		p.O12 = v
	}
	if v, ok := places["o20"]; ok {
		p.O20 = v
	}
	if v, ok := places["o21"]; ok {
		p.O21 = v
	}
	if v, ok := places["o22"]; ok {
		p.O22 = v
	}
	if v, ok := places["x_turn"]; ok {
		p.XTurn = v
	}
	if v, ok := places["o_turn"]; ok {
		p.OTurn = v
	}
	if v, ok := places["win_x"]; ok {
		p.WinX = v
	}
	if v, ok := places["win_o"]; ok {
		p.WinO = v
	}
	if v, ok := places["can_reset"]; ok {
		p.CanReset = v
	}
	if v, ok := places["game_active"]; ok {
		p.GameActive = v
	}
	return p
}

// GraphQL model types

type AggregateState struct {
	ID                 string
	Version            int
	State              *State
	Places             *Places
	EnabledTransitions []string
}

type State struct {
	P00 int
	P01 int
	P02 int
	P10 int
	P11 int
	P12 int
	P20 int
	P21 int
	P22 int
	X00 int
	X01 int
	X02 int
	X10 int
	X11 int
	X12 int
	X20 int
	X21 int
	X22 int
	O00 int
	O01 int
	O02 int
	O10 int
	O11 int
	O12 int
	O20 int
	O21 int
	O22 int
	XTurn int
	OTurn int
	WinX int
	WinO int
	CanReset int
	GameActive int
}

type Places struct {
	P00 int
	P01 int
	P02 int
	P10 int
	P11 int
	P12 int
	P20 int
	P21 int
	P22 int
	X00 int
	X01 int
	X02 int
	X10 int
	X11 int
	X12 int
	X20 int
	X21 int
	X22 int
	O00 int
	O01 int
	O02 int
	O10 int
	O11 int
	O12 int
	O20 int
	O21 int
	O22 int
	XTurn int
	OTurn int
	WinX int
	WinO int
	CanReset int
	GameActive int
}

type TransitionResult struct {
	Success            bool
	AggregateID        *string
	Version            *int
	State              *Places
	EnabledTransitions []string
	Error              *string
}

type AggregateList struct {
	Items   []*AggregateState
	Total   int
	Page    int
	PerPage int
}

type AdminStats struct {
	TotalInstances int
	ByPlace        []*PlaceCount
}

type PlaceCount struct {
	Place string
	Count int
}


type Event struct {
	ID        string
	StreamID  string
	Type      string
	Version   int
	Timestamp any
	Data      string
}


// Input types

type XPlay00Input struct {
	AggregateID string
}


type XPlay01Input struct {
	AggregateID string
}


type XPlay02Input struct {
	AggregateID string
}


type XPlay10Input struct {
	AggregateID string
}


type XPlay11Input struct {
	AggregateID string
}


type XPlay12Input struct {
	AggregateID string
}


type XPlay20Input struct {
	AggregateID string
}


type XPlay21Input struct {
	AggregateID string
}


type XPlay22Input struct {
	AggregateID string
}


type OPlay00Input struct {
	AggregateID string
}


type OPlay01Input struct {
	AggregateID string
}


type OPlay02Input struct {
	AggregateID string
}


type OPlay10Input struct {
	AggregateID string
}


type OPlay11Input struct {
	AggregateID string
}


type OPlay12Input struct {
	AggregateID string
}


type OPlay20Input struct {
	AggregateID string
}


type OPlay21Input struct {
	AggregateID string
}


type OPlay22Input struct {
	AggregateID string
}


type ResetInput struct {
	AggregateID string
}


type XWinRow0Input struct {
	AggregateID string
}


type XWinRow1Input struct {
	AggregateID string
}


type XWinRow2Input struct {
	AggregateID string
}


type XWinCol0Input struct {
	AggregateID string
}


type XWinCol1Input struct {
	AggregateID string
}


type XWinCol2Input struct {
	AggregateID string
}


type XWinDiagInput struct {
	AggregateID string
}


type XWinAntiInput struct {
	AggregateID string
}


type OWinRow0Input struct {
	AggregateID string
}


type OWinRow1Input struct {
	AggregateID string
}


type OWinRow2Input struct {
	AggregateID string
}


type OWinCol0Input struct {
	AggregateID string
}


type OWinCol1Input struct {
	AggregateID string
}


type OWinCol2Input struct {
	AggregateID string
}


type OWinDiagInput struct {
	AggregateID string
}


type OWinAntiInput struct {
	AggregateID string
}

