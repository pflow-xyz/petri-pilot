// Generated by petri-pilot. DO NOT EDIT.

import { createNavigation, refreshNavigation } from './navigation.js'
import { navigate, initRouter, getRouteParams, getCurrentRoute } from './router.js'
import { loadViews, renderFormView, renderDetailView, renderTableView, getFormData } from './views.js'

// Import custom components (preserved across regeneration)
import '../custom/components.js'

// Check if a custom dashboard component is registered
function hasCustomDashboard() {
  return customElements.get('tictactoe-dashboard') !== undefined
}

// API client
const API_BASE = window.API_BASE || ''

// ============================================================================
// Token Amount Scaling
// ============================================================================
// Decimals: 0 (0 = no scaling)
// Unit: ""

const TOKEN_DECIMALS = 0
const TOKEN_UNIT = ""
const TOKEN_SCALE = TOKEN_DECIMALS > 0 ? Math.pow(10, TOKEN_DECIMALS) : 1

// Convert from smallest unit (wei) to display unit (ETH)
// e.g., "1000000000000000000" -> "1"
// Handles both string and number inputs
function toDisplayAmount(rawAmount) {
  if (TOKEN_DECIMALS === 0) return rawAmount
  if (rawAmount === null || rawAmount === undefined) return ''

  // Handle string amounts (may be very large)
  const str = String(rawAmount)
  if (str === '0') return '0'

  // Pad with leading zeros if needed
  const padded = str.padStart(TOKEN_DECIMALS + 1, '0')
  const intPart = padded.slice(0, -TOKEN_DECIMALS) || '0'
  const fracPart = padded.slice(-TOKEN_DECIMALS).replace(/0+$/, '')

  return fracPart ? `${intPart}.${fracPart}` : intPart
}

// Convert from display unit (ETH) to smallest unit (wei)
// e.g., 1.0 -> "1000000000000000000"
// Returns a STRING to avoid JavaScript number precision issues with large values
function toRawAmount(displayAmount) {
  if (TOKEN_DECIMALS === 0) return displayAmount
  if (displayAmount === null || displayAmount === undefined || displayAmount === '') return "0"

  const amount = typeof displayAmount === 'string' ? parseFloat(displayAmount) : displayAmount
  if (isNaN(amount)) return "0"

  // Use BigInt arithmetic to avoid precision loss
  const multiplier = BigInt(10 ** TOKEN_DECIMALS)
  const whole = BigInt(Math.floor(amount))
  const frac = amount - Math.floor(amount)
  const fracWei = BigInt(Math.round(frac * Number(multiplier)))
  return String(whole * multiplier + fracWei)
}

// Format amount for display with unit
function formatAmount(rawAmount) {
  const display = toDisplayAmount(rawAmount)
  if (TOKEN_UNIT) {
    return `${display} ${TOKEN_UNIT}`
  }
  return display.toString()
}

// Check if a field name represents a token amount (should be scaled)
function isAmountField(fieldName) {
  const amountFields = ['amount', 'value', 'balance', 'total_supply', 'allowance']
  return amountFields.some(f => fieldName.toLowerCase().includes(f))
}

// Scale form data for API submission
function scaleFormData(data) {
  if (TOKEN_DECIMALS === 0) return data
  const scaled = { ...data }
  for (const [key, value] of Object.entries(scaled)) {
    if (isAmountField(key) && (typeof value === 'number' || !isNaN(parseFloat(value)))) {
      scaled[key] = toRawAmount(value)
    }
  }
  return scaled
}

// Check if value is a numeric amount (number or numeric string)
function isNumericAmount(value) {
  if (typeof value === 'number') return true
  if (typeof value === 'string' && /^\d+$/.test(value)) return true
  return false
}

// Unscale state data for display
function unscaleStateData(state) {
  if (TOKEN_DECIMALS === 0) return state
  const unscaled = { ...state }
  for (const [key, value] of Object.entries(unscaled)) {
    if (isAmountField(key)) {
      if (isNumericAmount(value)) {
        unscaled[key] = toDisplayAmount(value)
      } else if (typeof value === 'object' && value !== null) {
        // Handle maps like balances: { alice: 1000000000000000000 }
        // and nested maps like allowances: { owner: { spender: amount } }
        unscaled[key] = {}
        for (const [k, v] of Object.entries(value)) {
          if (isNumericAmount(v)) {
            unscaled[key][k] = toDisplayAmount(v)
          } else if (typeof v === 'object' && v !== null) {
            // Handle nested map (2 levels deep)
            unscaled[key][k] = {}
            for (const [k2, v2] of Object.entries(v)) {
              unscaled[key][k][k2] = isNumericAmount(v2) ? toDisplayAmount(v2) : v2
            }
          } else {
            unscaled[key][k] = v
          }
        }
      }
    }
  }
  return unscaled
}

// App state
let currentUser = null
let authToken = null
let instances = []
let currentInstance = null

// Transition definitions with fields (populated in renderInstanceDetail)
const TRANSITION_DEFS = [
  {
    id: 'x_play_00',
    name: 'X Play 00',
    description: "X plays at (0,0)",
    fields: [
    ]
  },
  {
    id: 'x_play_01',
    name: 'X Play 01',
    description: "X plays at (0,1)",
    fields: [
    ]
  },
  {
    id: 'x_play_02',
    name: 'X Play 02',
    description: "X plays at (0,2)",
    fields: [
    ]
  },
  {
    id: 'x_play_10',
    name: 'X Play 10',
    description: "X plays at (1,0)",
    fields: [
    ]
  },
  {
    id: 'x_play_11',
    name: 'X Play 11',
    description: "X plays at (1,1) - center",
    fields: [
    ]
  },
  {
    id: 'x_play_12',
    name: 'X Play 12',
    description: "X plays at (1,2)",
    fields: [
    ]
  },
  {
    id: 'x_play_20',
    name: 'X Play 20',
    description: "X plays at (2,0)",
    fields: [
    ]
  },
  {
    id: 'x_play_21',
    name: 'X Play 21',
    description: "X plays at (2,1)",
    fields: [
    ]
  },
  {
    id: 'x_play_22',
    name: 'X Play 22',
    description: "X plays at (2,2)",
    fields: [
    ]
  },
  {
    id: 'o_play_00',
    name: 'O Play 00',
    description: "O plays at (0,0)",
    fields: [
    ]
  },
  {
    id: 'o_play_01',
    name: 'O Play 01',
    description: "O plays at (0,1)",
    fields: [
    ]
  },
  {
    id: 'o_play_02',
    name: 'O Play 02',
    description: "O plays at (0,2)",
    fields: [
    ]
  },
  {
    id: 'o_play_10',
    name: 'O Play 10',
    description: "O plays at (1,0)",
    fields: [
    ]
  },
  {
    id: 'o_play_11',
    name: 'O Play 11',
    description: "O plays at (1,1) - center",
    fields: [
    ]
  },
  {
    id: 'o_play_12',
    name: 'O Play 12',
    description: "O plays at (1,2)",
    fields: [
    ]
  },
  {
    id: 'o_play_20',
    name: 'O Play 20',
    description: "O plays at (2,0)",
    fields: [
    ]
  },
  {
    id: 'o_play_21',
    name: 'O Play 21',
    description: "O plays at (2,1)",
    fields: [
    ]
  },
  {
    id: 'o_play_22',
    name: 'O Play 22',
    description: "O plays at (2,2)",
    fields: [
    ]
  },
  {
    id: 'reset',
    name: 'Reset',
    description: "Reset game to initial state",
    fields: [
    ]
  },
  {
    id: 'x_win_row0',
    name: 'X Win Row0',
    description: "X wins top row (0,0)-(0,1)-(0,2)",
    fields: [
    ]
  },
  {
    id: 'x_win_row1',
    name: 'X Win Row1',
    description: "X wins middle row (1,0)-(1,1)-(1,2)",
    fields: [
    ]
  },
  {
    id: 'x_win_row2',
    name: 'X Win Row2',
    description: "X wins bottom row (2,0)-(2,1)-(2,2)",
    fields: [
    ]
  },
  {
    id: 'x_win_col0',
    name: 'X Win Col0',
    description: "X wins left column (0,0)-(1,0)-(2,0)",
    fields: [
    ]
  },
  {
    id: 'x_win_col1',
    name: 'X Win Col1',
    description: "X wins center column (0,1)-(1,1)-(2,1)",
    fields: [
    ]
  },
  {
    id: 'x_win_col2',
    name: 'X Win Col2',
    description: "X wins right column (0,2)-(1,2)-(2,2)",
    fields: [
    ]
  },
  {
    id: 'x_win_diag',
    name: 'X Win Diag',
    description: "X wins main diagonal (0,0)-(1,1)-(2,2)",
    fields: [
    ]
  },
  {
    id: 'x_win_anti',
    name: 'X Win Anti',
    description: "X wins anti-diagonal (0,2)-(1,1)-(2,0)",
    fields: [
    ]
  },
  {
    id: 'o_win_row0',
    name: 'O Win Row0',
    description: "O wins top row (0,0)-(0,1)-(0,2)",
    fields: [
    ]
  },
  {
    id: 'o_win_row1',
    name: 'O Win Row1',
    description: "O wins middle row (1,0)-(1,1)-(1,2)",
    fields: [
    ]
  },
  {
    id: 'o_win_row2',
    name: 'O Win Row2',
    description: "O wins bottom row (2,0)-(2,1)-(2,2)",
    fields: [
    ]
  },
  {
    id: 'o_win_col0',
    name: 'O Win Col0',
    description: "O wins left column (0,0)-(1,0)-(2,0)",
    fields: [
    ]
  },
  {
    id: 'o_win_col1',
    name: 'O Win Col1',
    description: "O wins center column (0,1)-(1,1)-(2,1)",
    fields: [
    ]
  },
  {
    id: 'o_win_col2',
    name: 'O Win Col2',
    description: "O wins right column (0,2)-(1,2)-(2,2)",
    fields: [
    ]
  },
  {
    id: 'o_win_diag',
    name: 'O Win Diag',
    description: "O wins main diagonal (0,0)-(1,1)-(2,2)",
    fields: [
    ]
  },
  {
    id: 'o_win_anti',
    name: 'O Win Anti',
    description: "O wins anti-diagonal (0,2)-(1,1)-(2,0)",
    fields: [
    ]
  },
]

// ============================================================================
// Auth
// ============================================================================

function loadAuth() {
  const stored = localStorage.getItem('auth')
  if (stored) {
    try {
      const auth = JSON.parse(stored)
      if (auth.expires_at && new Date(auth.expires_at) > new Date()) {
        authToken = auth.token
        currentUser = auth.user
        return true
      }
      localStorage.removeItem('auth')
    } catch (e) {
      localStorage.removeItem('auth')
    }
  }
  return false
}

function saveAuth(data) {
  localStorage.setItem('auth', JSON.stringify(data))
  authToken = data.token
  currentUser = data.user
  window.dispatchEvent(new CustomEvent('auth-change'))
}

function clearAuth() {
  localStorage.removeItem('auth')
  authToken = null
  currentUser = null
  window.dispatchEvent(new CustomEvent('auth-change'))
}

// Reload auth from localStorage (called when wallet module updates auth)
function reloadAuth() {
  const stored = localStorage.getItem('auth')
  if (stored) {
    try {
      const auth = JSON.parse(stored)
      authToken = auth.token
      currentUser = auth.user
      return true
    } catch (e) {
      return false
    }
  }
  authToken = null
  currentUser = null
  return false
}

// Listen for auth changes from wallet module
window.addEventListener('auth-change', () => {
  reloadAuth()
})

function getHeaders() {
  const headers = { 'Content-Type': 'application/json' }
  if (authToken) {
    headers['Authorization'] = `Bearer ${authToken}`
  }
  return headers
}

// ============================================================================
// API
// ============================================================================

async function handleResponse(response) {
  if (response.status === 401) {
    clearAuth()
    showError('Session expired. Please log in again.')
    throw new Error('Unauthorized')
  }
  if (!response.ok) {
    const error = await response.json().catch(() => ({}))
    throw new Error(error.message || response.statusText)
  }
  return response.json()
}

const api = {
  async getMe() {
    const response = await fetch(`${API_BASE}/auth/me`, { headers: getHeaders() })
    return handleResponse(response)
  },

  async logout() {
    await fetch(`${API_BASE}/auth/logout`, { method: 'POST', headers: getHeaders() })
    clearAuth()
  },

  async listInstances() {
    const response = await fetch(`${API_BASE}/admin/instances`, { headers: getHeaders() })
    return handleResponse(response)
  },

  async getInstance(id) {
    const response = await fetch(`${API_BASE}/api/tictactoe/${id}`, { headers: getHeaders() })
    return handleResponse(response)
  },

  async createInstance(data = {}) {
    const response = await fetch(`${API_BASE}/api/tictactoe`, {
      method: 'POST',
      headers: getHeaders(),
      body: JSON.stringify(data),
    })
    return handleResponse(response)
  },

  async executeTransition(transitionId, aggregateId, data = {}) {
    // Scale amount fields before sending to API
    const scaledData = scaleFormData(data)
    // Get the API path from transition definition, or fall back to default
    const transition = window.pilot?.getTransition?.(transitionId)
    let apiPath = transition?.apiPath || `/api/${transitionId}`
    // Substitute {id} placeholder with actual aggregate ID
    apiPath = apiPath.replace('{id}', aggregateId)
    const response = await fetch(`${API_BASE}${apiPath}`, {
      method: 'POST',
      headers: getHeaders(),
      body: JSON.stringify({ aggregate_id: aggregateId, data: scaledData }),
    })
    return handleResponse(response)
  },
}

// Export for global access
window.api = api

// Export current instance for debug wallet view
Object.defineProperty(window, 'currentInstance', {
  get: function() { return currentInstance }
})

// Export auth functions for testing
window.setAuthToken = function(token) {
  authToken = token
}
window.saveAuth = saveAuth
window.clearAuth = clearAuth

// ============================================================================
// UI Helpers
// ============================================================================

function showError(message) {
  const app = document.getElementById('app')
  const existing = app.querySelector('.alert-error')
  if (existing) existing.remove()

  const alert = document.createElement('div')
  alert.className = 'alert alert-error'
  alert.textContent = message
  app.insertBefore(alert, app.firstChild)

  setTimeout(() => alert.remove(), 5000)
}

function showSuccess(message) {
  const app = document.getElementById('app')
  const existing = app.querySelector('.alert-success')
  if (existing) existing.remove()

  const alert = document.createElement('div')
  alert.className = 'alert alert-success'
  alert.textContent = message
  app.insertBefore(alert, app.firstChild)

  setTimeout(() => alert.remove(), 3000)
}

// Status configuration from schema
const STATUS_PLACES = {}
const STATUS_DEFAULT = "Unknown"

// Get human-readable status from places
function getStatus(places) {
  if (!places) return STATUS_DEFAULT
  // Check for configured status labels first
  for (const [place, tokens] of Object.entries(places)) {
    if (tokens > 0 && STATUS_PLACES[place]) {
      return STATUS_PLACES[place]
    }
  }
  // Default status for active workflows
  return STATUS_DEFAULT
}

// Format status as badge
function formatStatus(status) {
  const statusClass = `badge-${status.toLowerCase().replace(/_/g, '-')}`
  return `<span class="badge ${statusClass}">${status.replace(/_/g, ' ')}</span>`
}

// ============================================================================
// Page Renderers
// ============================================================================

// List page - shows all instances (or custom dashboard if available)
async function renderListPage() {
  const app = document.getElementById('app')

  // Check if a custom dashboard component is registered
  if (hasCustomDashboard()) {
    app.innerHTML = `<tictactoe-dashboard></tictactoe-dashboard>`
    return
  }

  // Default list view
  app.innerHTML = `
    <div class="page">
      <div class="page-header">
        <h1>tic-tac-toe</h1>
        <button class="btn btn-primary" onclick="handleCreateNew()">+ New</button>
      </div>
      <div id="instances-list" class="entity-list">
        <div class="loading">Loading...</div>
      </div>
    </div>
  `

  try {
    const result = await api.listInstances()
    instances = result.instances || []
    renderInstancesList()
  } catch (err) {
    document.getElementById('instances-list').innerHTML = `
      <div class="empty-state">
        <h3>No instances yet</h3>
        <p>Create your first instance to get started.</p>
        <button class="btn btn-primary" onclick="handleCreateNew()" style="margin-top: 1rem">+ Create New</button>
      </div>
    `
  }
}

function renderInstancesList() {
  const container = document.getElementById('instances-list')
  if (!container) return

  if (instances.length === 0) {
    container.innerHTML = `
      <div class="empty-state">
        <h3>No instances yet</h3>
        <p>Create your first instance to get started.</p>
        <button class="btn btn-primary" onclick="handleCreateNew()" style="margin-top: 1rem">+ Create New</button>
      </div>
    `
    return
  }

  container.innerHTML = instances.map(inst => {
    const status = getStatus(inst.state || inst.places)
    return `
      <div class="entity-card" onclick="navigate('/tic-tac-toe/${inst.id}')">
        <div class="entity-info">
          <h3>${inst.id}</h3>
          <div class="entity-meta">
            ${formatStatus(status)} &middot; Version ${inst.version || 0}
          </div>
        </div>
        <div class="entity-actions">
          <button class="btn btn-sm btn-secondary" onclick="event.stopPropagation(); navigate('/tic-tac-toe/${inst.id}')">
            View
          </button>
        </div>
      </div>
    `
  }).join('')
}

// Detail page - shows single instance with actions
async function renderDetailPage() {
  const params = getRouteParams()
  const id = params.id

  const app = document.getElementById('app')
  app.innerHTML = `
    <div class="page">
      <div class="page-header">
        <div>
          <button class="btn btn-link" onclick="navigate('/tic-tac-toe')" style="margin-left: -0.5rem">
            &larr; Back to List
          </button>
          <h1 style="margin-top: 0.5rem">Instance: ${id}</h1>
        </div>
      </div>
      <div id="instance-detail">
        <div class="loading">Loading...</div>
      </div>
    </div>
  `

  try {
    const result = await api.getInstance(id)
    currentInstance = {
      id: result.aggregate_id || id,
      version: result.version,
      state: result.state,
      displayState: unscaleStateData(result.state), // Unscaled for display
      places: result.places,
      enabled: result.enabled || result.enabled_transitions || [],
    }
    // Store state for debug wallet view
    window.currentInstanceState = currentInstance.state
    renderInstanceDetail()
  } catch (err) {
    document.getElementById('instance-detail').innerHTML = `
      <div class="alert alert-error">Failed to load instance: ${err.message}</div>
    `
  }
}

function renderInstanceDetail() {
  const container = document.getElementById('instance-detail')
  if (!container || !currentInstance) return

  const status = getStatus(currentInstance.places)
  const enabled = currentInstance.enabled || []

  // Use global transition definitions
  const transitions = TRANSITION_DEFS

  container.innerHTML = `
    <div class="card">
      <div class="card-header">Status</div>
      <div class="detail-list">
        <div class="detail-field">
          <dt>ID</dt>
          <dd><code>${currentInstance.id}</code></dd>
        </div>
        <div class="detail-field">
          <dt>Status</dt>
          <dd>${formatStatus(status)}</dd>
        </div>
        <div class="detail-field">
          <dt>Version</dt>
          <dd>${currentInstance.version || 0}</dd>
        </div>
      </div>
    </div>

    <div class="card">
      <div class="card-header">Actions</div>
      <div class="view-actions">
        ${transitions.map(t => {
          const isEnabled = enabled.includes(t.id)
          return `
            <button
              class="btn ${isEnabled ? 'btn-primary' : 'btn-secondary'}"
              onclick="handleTransition('${t.id}')"
              ${isEnabled ? '' : 'disabled'}
              title="${t.description || t.name}"
            >
              ${t.name}
            </button>
          `
        }).join('')}
      </div>
      ${enabled.length === 0 ? '<p style="color: #666; margin-top: 1rem;">No actions available in current state.</p>' : ''}
    </div>

    <div class="card">
      <div class="card-header">Current State${TOKEN_UNIT ? ` (${TOKEN_UNIT})` : ''}</div>
      <div class="detail-list">
        ${renderStateDisplay(currentInstance.displayState || currentInstance.state)}
      </div>
    </div>
  `
}

// Render state data for display (handles nested objects like balances map)
function renderStateDisplay(state) {
  if (!state || Object.keys(state).length === 0) {
    return '<p style="color: #999;">No state data</p>'
  }

  return Object.entries(state).map(([key, value]) => {
    if (typeof value === 'object' && value !== null) {
      // Render nested object (like balances: { alice: 750, bob: 250 })
      // or doubly nested (like allowances: { owner: { spender: amount } })
      const entries = Object.entries(value)
      if (entries.length === 0) {
        return `
          <div class="detail-field">
            <dt>${formatFieldName(key)}</dt>
            <dd><span style="color: #999;">Empty</span></dd>
          </div>
        `
      }
      return `
        <div class="detail-field">
          <dt>${formatFieldName(key)}</dt>
          <dd>
            <div class="nested-state">
              ${entries.map(([k, v]) => {
                if (typeof v === 'object' && v !== null) {
                  // Handle nested map (2 levels deep, like allowances)
                  const innerEntries = Object.entries(v)
                  if (innerEntries.length === 0) {
                    return `
                      <div class="state-entry">
                        <span class="state-key">${k}</span>
                        <span class="state-value" style="color: #999;">Empty</span>
                      </div>
                    `
                  }
                  return `
                    <div class="state-entry nested-group">
                      <span class="state-key">${k}</span>
                      <div class="nested-state" style="margin-left: 1rem;">
                        ${innerEntries.map(([k2, v2]) => `
                          <div class="state-entry">
                            <span class="state-key">${k2}</span>
                            <span class="state-value">${formatStateValue(key, v2)}</span>
                          </div>
                        `).join('')}
                      </div>
                    </div>
                  `
                }
                return `
                  <div class="state-entry">
                    <span class="state-key">${k}</span>
                    <span class="state-value">${formatStateValue(key, v)}</span>
                  </div>
                `
              }).join('')}
            </div>
          </dd>
        </div>
      `
    }
    return `
      <div class="detail-field">
        <dt>${formatFieldName(key)}</dt>
        <dd>${formatStateValue(key, value)}</dd>
      </div>
    `
  }).join('')
}

// Format field name for display (e.g., "total_supply" -> "Total Supply")
function formatFieldName(name) {
  return name.replace(/_/g, ' ').replace(/\b\w/g, c => c.toUpperCase())
}

// Format state value with unit if applicable
function formatStateValue(fieldName, value) {
  if (isAmountField(fieldName) && TOKEN_UNIT) {
    return `<strong>${value}</strong> ${TOKEN_UNIT}`
  }
  return `<strong>${value}</strong>`
}

// ============================================================================
// Action Form Modal
// ============================================================================

// Get the connected wallet address (if wallet feature is enabled)
function getConnectedWallet() {
  if (typeof wallet !== 'undefined' && wallet.getAccount) {
    const account = wallet.getAccount()
    return account?.address || null
  }
  return null
}

// Resolve auto-fill value
function resolveAutoFill(autoFill, state) {
  if (!autoFill) return ''
  if (autoFill === 'wallet') {
    return getConnectedWallet() || ''
  }
  if (autoFill === 'user') {
    return currentUser?.id || currentUser?.login || ''
  }
  // State path like "balances.{wallet}"
  if (autoFill.startsWith('balances.') || autoFill.includes('.')) {
    // Could resolve from state if needed
    return ''
  }
  return ''
}

// Create action form modal HTML
function createActionModal() {
  return `
    <div id="action-modal" class="modal" style="display: none;">
      <div class="modal-backdrop" onclick="hideActionModal()"></div>
      <div class="modal-content">
        <div class="modal-header">
          <h3 id="action-modal-title">Execute Action</h3>
          <button onclick="hideActionModal()" class="modal-close">&times;</button>
        </div>
        <div class="modal-body">
          <form id="action-form" onsubmit="handleActionSubmit(event)">
            <div id="action-form-fields"></div>
            <div class="form-actions">
              <button type="submit" class="btn btn-primary">Execute</button>
              <button type="button" class="btn btn-secondary" onclick="hideActionModal()">Cancel</button>
            </div>
          </form>
        </div>
      </div>
    </div>
    <style>
      .modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 1000;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .modal-backdrop {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
      }
      .modal-content {
        position: relative;
        background: white;
        border-radius: 8px;
        padding: 0;
        min-width: 400px;
        max-width: 90%;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
      }
      .modal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 1rem 1.5rem;
        border-bottom: 1px solid #eee;
      }
      .modal-header h3 {
        margin: 0;
        font-size: 1.25rem;
      }
      .modal-close {
        background: none;
        border: none;
        font-size: 1.5rem;
        cursor: pointer;
        color: #666;
        padding: 0;
        line-height: 1;
      }
      .modal-close:hover {
        color: #333;
      }
      .modal-body {
        padding: 1.5rem;
      }
      .address-input-wrapper {
        position: relative;
      }
      .address-picker-btn {
        position: absolute;
        right: 4px;
        top: 50%;
        transform: translateY(-50%);
        background: #f0f0f0;
        border: 1px solid #ddd;
        border-radius: 4px;
        padding: 4px 8px;
        font-size: 0.85rem;
        cursor: pointer;
      }
      .address-picker-btn:hover {
        background: #e0e0e0;
      }
      .field-description {
        font-size: 0.85rem;
        color: #666;
        margin-top: 0.25rem;
      }
    </style>
  `
}

// Current action being executed
let currentActionId = null

// Show action modal for a transition
function showActionModal(transitionId) {
  const transition = TRANSITION_DEFS.find(t => t.id === transitionId)
  if (!transition) return

  currentActionId = transitionId

  // Update modal title
  document.getElementById('action-modal-title').textContent = transition.name

  // Build form fields
  const fieldsHtml = transition.fields.map(field => {
    const autoValue = resolveAutoFill(field.autoFill, currentInstance?.state)
    const value = autoValue || field.defaultValue || ''
    const required = field.required ? 'required' : ''

    // Determine input type
    let inputHtml = ''
    if (field.type === 'amount') {
      inputHtml = `
        <input
          type="number"
          name="${field.name}"
          value="${value}"
          placeholder="${field.placeholder || 'Amount'}"
          step="any"
          ${required}
          class="form-control"
        />
        ${TOKEN_UNIT ? `<span class="field-description">Amount in ${TOKEN_UNIT}</span>` : ''}
      `
    } else if (field.type === 'address') {
      // Use dropdown for address fields in demo mode
      const accounts = getWalletAccounts()
      if (accounts.length > 0) {
        inputHtml = `
          <select name="${field.name}" ${required} class="form-control">
            <option value="">Select address...</option>
            ${accounts.map(acc => `
              <option value="${acc.address}" ${acc.address === value ? 'selected' : ''}>
                ${acc.name || 'Account'} (${acc.address.slice(0, 8)}...${acc.address.slice(-6)})
              </option>
            `).join('')}
          </select>
        `
      } else {
        inputHtml = `
          <input
            type="text"
            name="${field.name}"
            value="${value}"
            placeholder="${field.placeholder || '0x...'}"
            ${required}
            class="form-control"
          />
        `
      }
    } else if (field.type === 'hidden') {
      inputHtml = `<input type="hidden" name="${field.name}" value="${value}" />`
    } else {
      inputHtml = `
        <input
          type="${field.type === 'number' ? 'number' : 'text'}"
          name="${field.name}"
          value="${value}"
          placeholder="${field.placeholder || ''}"
          ${required}
          class="form-control"
        />
      `
    }

    // Hidden fields don't need labels
    if (field.type === 'hidden') {
      return inputHtml
    }

    return `
      <div class="form-field">
        <label>${field.label}${field.required ? ' *' : ''}</label>
        ${inputHtml}
      </div>
    `
  }).join('')

  document.getElementById('action-form-fields').innerHTML = fieldsHtml

  // Show modal
  document.getElementById('action-modal').style.display = 'flex'
}

// Hide action modal
window.hideActionModal = function() {
  document.getElementById('action-modal').style.display = 'none'
  currentActionId = null
}

// Handle action form submission
window.handleActionSubmit = async function(event) {
  event.preventDefault()

  if (!currentActionId || !currentInstance) return

  // Save action ID before hiding modal (which clears it)
  const actionId = currentActionId
  const instanceId = currentInstance.id

  const form = event.target
  const formData = new FormData(form)
  const data = {}

  for (const [key, value] of formData.entries()) {
    // Convert numeric strings to numbers for amount fields
    const field = TRANSITION_DEFS.find(t => t.id === actionId)?.fields.find(f => f.name === key)
    if (field && (field.type === 'amount' || field.type === 'number')) {
      data[key] = parseFloat(value) || 0
    } else {
      data[key] = value
    }
  }

  hideActionModal()

  try {
    const result = await api.executeTransition(actionId, instanceId, data)
    currentInstance = {
      ...currentInstance,
      version: result.version,
      state: result.state,
      displayState: unscaleStateData(result.state),
      places: result.state,
      enabled: result.enabled || [],
    }
    // Store state for wallet balance display
    window.currentInstanceState = currentInstance.state
    renderInstanceDetail()
    showSuccess(`Action "${actionId}" completed!`)
  } catch (err) {
    showError(`Failed to execute ${actionId}: ${err.message}`)
  }
}

// Check if wallet accounts are available for address picker
function hasWalletAccounts() {
  if (typeof wallet !== 'undefined' && wallet.getAccounts) {
    const accounts = wallet.getAccounts()
    return accounts && accounts.length > 0
  }
  return false
}

// Get wallet accounts for dropdowns
function getWalletAccounts() {
  if (typeof wallet !== 'undefined' && wallet.getAccounts) {
    return wallet.getAccounts() || []
  }
  return []
}

// Show address picker dropdown
window.showAddressPicker = function(fieldName) {
  if (typeof wallet === 'undefined' || !wallet.getAccounts) return

  const accounts = wallet.getAccounts()
  if (!accounts || accounts.length === 0) return

  // Create dropdown
  const existing = document.querySelector('.address-picker-dropdown')
  if (existing) existing.remove()

  const input = document.querySelector(`[name="${fieldName}"]`)
  if (!input) return

  const rect = input.getBoundingClientRect()
  const dropdown = document.createElement('div')
  dropdown.className = 'address-picker-dropdown'
  dropdown.style.cssText = `
    position: fixed;
    top: ${rect.bottom + 4}px;
    left: ${rect.left}px;
    width: ${rect.width}px;
    background: white;
    border: 1px solid #ddd;
    border-radius: 4px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    z-index: 2000;
    max-height: 200px;
    overflow-y: auto;
  `

  dropdown.innerHTML = accounts.map(acc => `
    <div class="address-picker-option" onclick="selectAddress('${fieldName}', '${acc.address}')" style="
      padding: 8px 12px;
      cursor: pointer;
      border-bottom: 1px solid #eee;
    ">
      <div style="font-weight: 500;">${acc.name || 'Account'}</div>
      <div style="font-size: 0.85rem; color: #666; font-family: monospace;">${acc.address.slice(0, 10)}...${acc.address.slice(-8)}</div>
    </div>
  `).join('')

  document.body.appendChild(dropdown)

  // Close on click outside
  setTimeout(() => {
    document.addEventListener('click', function closeDropdown(e) {
      if (!dropdown.contains(e.target)) {
        dropdown.remove()
        document.removeEventListener('click', closeDropdown)
      }
    })
  }, 0)
}

// Select address from picker
window.selectAddress = function(fieldName, address) {
  const input = document.querySelector(`[name="${fieldName}"]`)
  if (input) {
    input.value = address
    input.dispatchEvent(new Event('input', { bubbles: true }))
  }
  const dropdown = document.querySelector('.address-picker-dropdown')
  if (dropdown) dropdown.remove()
}

// Form page - create new instance
async function renderFormPage() {
  const app = document.getElementById('app')
  app.innerHTML = `
    <div class="page">
      <div class="page-header">
        <div>
          <button class="btn btn-link" onclick="navigate('/tic-tac-toe')" style="margin-left: -0.5rem">
            &larr; Cancel
          </button>
          <h1 style="margin-top: 0.5rem">Create New</h1>
        </div>
      </div>
      <div class="card">
        <form id="create-form" onsubmit="handleSubmitCreate(event)">
          <p style="color: #666; margin-bottom: 1rem;">Create a new workflow instance. The instance will start in the initial state.</p>
          <div class="form-actions">
            <button type="submit" class="btn btn-primary">Create</button>
            <button type="button" class="btn btn-secondary" onclick="navigate('/tic-tac-toe')">Cancel</button>
          </div>
        </form>
      </div>
    </div>
  `
}

// Schema viewer page
async function renderSchemaPage() {
  const app = document.getElementById('app')
  app.innerHTML = `
    <div class="page">
      <div class="page-header">
        <h1>Schema Viewer</h1>
        <p style="color: #666; margin-top: 0.5rem;">Inspect the Petri net model that powers this application</p>
      </div>
      <div id="schema-content" class="card">
        <div class="loading">Loading schema...</div>
      </div>
    </div>
  `

  try {
    const response = await fetch(`${API_BASE}/api/schema`)
    const schema = await response.json()

    // Store schema for petri-view
    _currentSchema = schema

    const schemaContent = document.getElementById('schema-content')
    schemaContent.innerHTML = `
      <div class="schema-viewer">
        <div class="schema-tabs">
          <button class="schema-tab active" onclick="showSchemaTab('overview')">Overview</button>
          <button class="schema-tab" onclick="showSchemaTab('petrinet')">Petri Net</button>
          <button class="schema-tab" onclick="showSchemaTab('places')">Places (${schema.places?.length || 0})</button>
          <button class="schema-tab" onclick="showSchemaTab('transitions')">Transitions (${schema.transitions?.length || 0})</button>
          <button class="schema-tab" onclick="showSchemaTab('arcs')">Arcs (${schema.arcs?.length || 0})</button>
          <button class="schema-tab" onclick="showSchemaTab('raw')">Raw JSON</button>
        </div>

        <div id="schema-tab-overview" class="schema-tab-content active">
          <div class="schema-overview">
            <div class="schema-info-card">
              <h3>${schema.name || 'Unnamed'}</h3>
              <p>${schema.description || 'No description'}</p>
              <a class="pflow-link" href="/pflow?model=${encodeURIComponent(schema.name || '')}" target="_blank">
                Open in <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 490 115"><g transform="translate(5,5)"><path d="M100.88 28.02H78.46v5.61h-5.6v5.6h-5.6v-5.6h5.6v-5.61h5.6V5.6h-5.6V0H61.65v5.6h-5.6v28.02h-5.6V5.6h-5.6V0H33.64v5.6h-5.6v22.42h5.6v5.61h5.6v5.6h-5.6v-5.6h-5.6v-5.61H5.6v5.61H0v11.21h5.6v5.6h28.02v5.6H5.6v5.61H0v11.21h5.6v5.6h22.42v-5.6h5.6v-5.61h5.6v5.61h-5.6v5.6h-5.6v22.42h5.6v5.6h11.21v-5.6h5.6V72.86h5.6v28.02h5.6v5.6h11.21v-5.6h5.6V78.46h-5.6v-5.6h-5.6v-5.61h5.6v5.61h5.6v5.6h22.42v-5.6h5.6V61.65h-5.6v-5.61H72.84v-5.6h28.02v-5.6h5.6V33.63h-5.6v-5.61zM67.25 56.04v5.61h-5.6v5.6H44.84v-5.6h-5.6V44.84h5.6v-5.6h16.81v5.6h5.6v11.21zm89.89-28.02h-11.21v11.21h11.21zm33.63 11.21h11.21V28.02h-33.63v11.21z"/><path d="M179.56 72.86h-11.21V39.23h-11.21v56.05h-11.21v11.21h33.63V95.28h-11.21V84.07h33.63V72.86zm22.42-22.42v22.42h11.21V39.23h-11.21zm33.63-22.42H224.4v11.21h11.21v33.63H224.4v11.21h33.63V72.86h-11.21V39.23h11.21V28.02h-11.21V16.81h-11.21z"/><path d="M246.82 5.6v11.21h22.42V5.6zm56.05 56.05V5.6h-22.42v11.21h11.21v56.05h-11.21v11.21h33.63V72.86h-11.21zm33.63-11.21V39.23h-11.21v33.63h11.21zm22.42 0h-11.21v11.21h11.21zm0-11.21h11.21V28.02H336.5v11.21zm-11.21 33.63H336.5v11.21h33.63V72.86zm22.42-22.42v22.42h11.21V39.23h-11.21zm44.84-11.21V28.02h-22.42v11.21h11.21v22.42h11.21zm11.21 22.42h-11.21v11.21h11.21zm11.21 11.21h-11.21v11.21h11.21zm11.21-22.42V28.02h-11.21v44.84h11.21zm11.21 22.42H448.6v11.21h11.21zm11.21-11.21h-11.21v11.21h11.21zm11.21-33.63h-11.21v33.63h11.21V39.23h11.21V28.02z"/></g></svg>
              </a>
            </div>
            <div class="schema-stats">
              <div class="stat-item">
                <span class="stat-value">${schema.places?.length || 0}</span>
                <span class="stat-label">Places</span>
              </div>
              <div class="stat-item">
                <span class="stat-value">${schema.transitions?.length || 0}</span>
                <span class="stat-label">Transitions</span>
              </div>
              <div class="stat-item">
                <span class="stat-value">${schema.arcs?.length || 0}</span>
                <span class="stat-label">Arcs</span>
              </div>
              <div class="stat-item">
                <span class="stat-value">${schema.roles?.length || 0}</span>
                <span class="stat-label">Roles</span>
              </div>
            </div>
          </div>
        </div>

        <div id="schema-tab-places" class="schema-tab-content" style="display: none;">
          <table class="schema-table">
            <thead>
              <tr>
                <th>ID</th>
                <th>Description</th>
                <th>Initial</th>
                <th>Capacity</th>
              </tr>
            </thead>
            <tbody>
              ${(schema.places || []).map(p => `
                <tr>
                  <td><code>${p.id}</code></td>
                  <td>${p.description || '-'}</td>
                  <td>${p.initial || 0}</td>
                  <td>${p.capacity || 'âˆž'}</td>
                </tr>
              `).join('')}
            </tbody>
          </table>
        </div>

        <div id="schema-tab-transitions" class="schema-tab-content" style="display: none;">
          <table class="schema-table">
            <thead>
              <tr>
                <th>ID</th>
                <th>Description</th>
                <th>Guard</th>
                <th>Roles</th>
              </tr>
            </thead>
            <tbody>
              ${(schema.transitions || []).map(t => `
                <tr>
                  <td><code>${t.id}</code></td>
                  <td>${t.description || '-'}</td>
                  <td><code>${t.guard || '-'}</code></td>
                  <td>${(t.roles || []).join(', ') || '-'}</td>
                </tr>
              `).join('')}
            </tbody>
          </table>
        </div>

        <div id="schema-tab-arcs" class="schema-tab-content" style="display: none;">
          <table class="schema-table">
            <thead>
              <tr>
                <th>From</th>
                <th>To</th>
                <th>Weight</th>
                <th>Type</th>
              </tr>
            </thead>
            <tbody>
              ${(schema.arcs || []).map(a => `
                <tr>
                  <td><code>${a.from}</code></td>
                  <td><code>${a.to}</code></td>
                  <td>${a.weight || 1}</td>
                  <td>${a.type || 'normal'}</td>
                </tr>
              `).join('')}
            </tbody>
          </table>
        </div>

        <div id="schema-tab-petrinet" class="schema-tab-content" style="display: none;">
          <div class="petrinet-container">
            <petri-view id="schema-petri-view"></petri-view>
          </div>
        </div>

        <div id="schema-tab-raw" class="schema-tab-content" style="display: none;">
          <pre class="schema-json">${JSON.stringify(schema, null, 2)}</pre>
        </div>
      </div>

      <style>
        .schema-viewer {
          padding: 1rem;
        }
        .schema-tabs {
          display: flex;
          gap: 0.5rem;
          margin-bottom: 1rem;
          border-bottom: 1px solid #eee;
          padding-bottom: 0.5rem;
        }
        .schema-tab {
          padding: 0.5rem 1rem;
          border: none;
          background: #f5f5f5;
          border-radius: 4px;
          cursor: pointer;
          font-size: 0.9rem;
        }
        .schema-tab:hover {
          background: #e9e9e9;
        }
        .schema-tab.active {
          background: #007bff;
          color: white;
        }
        .schema-tab-content {
          display: none;
        }
        .schema-tab-content.active {
          display: block;
        }
        .schema-overview {
          display: flex;
          flex-direction: column;
          gap: 1.5rem;
        }
        .schema-info-card h3 {
          margin: 0 0 0.5rem 0;
          font-size: 1.5rem;
        }
        .schema-info-card p {
          margin: 0;
          color: #666;
        }
        .pflow-link {
          display: inline-flex;
          align-items: center;
          gap: 6px;
          margin-top: 0.75rem;
          padding: 6px 14px;
          background: #f5f5f5;
          border: 1px solid #ddd;
          border-radius: 6px;
          text-decoration: none;
          color: #555;
          font-size: 0.85rem;
          transition: background 0.15s, border-color 0.15s;
        }
        .pflow-link:hover {
          background: #e9e9e9;
          border-color: #bbb;
          color: #333;
        }
        .pflow-link svg {
          height: 16px;
          width: auto;
          fill: currentColor;
          vertical-align: -2px;
        }
        .schema-stats {
          display: grid;
          grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
          gap: 1rem;
        }
        .stat-item {
          background: #f8f9fa;
          padding: 1rem;
          border-radius: 8px;
          text-align: center;
        }
        .stat-value {
          display: block;
          font-size: 2rem;
          font-weight: 600;
          color: #007bff;
        }
        .stat-label {
          display: block;
          font-size: 0.85rem;
          color: #666;
          margin-top: 0.25rem;
        }
        .schema-table {
          width: 100%;
          border-collapse: collapse;
        }
        .schema-table th,
        .schema-table td {
          padding: 0.75rem;
          text-align: left;
          border-bottom: 1px solid #eee;
        }
        .schema-table th {
          background: #f8f9fa;
          font-weight: 600;
        }
        .schema-table code {
          background: #f0f0f0;
          padding: 0.2rem 0.4rem;
          border-radius: 3px;
          font-size: 0.85rem;
        }
        .schema-json {
          background: #1e1e1e;
          color: #d4d4d4;
          padding: 1rem;
          border-radius: 8px;
          overflow-x: auto;
          font-size: 0.85rem;
          line-height: 1.5;
        }
        .petrinet-container {
          width: 100%;
          height: calc(100vh - 280px);
          min-height: 500px;
          border: 1px solid #ddd;
          border-radius: 8px;
          overflow: hidden;
        }
        .petrinet-container petri-view {
          width: 100%;
          height: 100%;
        }
      </style>
    `
  } catch (err) {
    console.error('Failed to load schema:', err)
    document.getElementById('schema-content').innerHTML = `
      <div class="error">Failed to load schema: ${err.message}</div>
    `
  }
}

// Store schema globally for petri-view
let _currentSchema = null

// Convert schema to pflow.xyz format
function schemaToPflowModel(schema) {
  const places = {}
  const transitions = {}
  const arcs = []

  // Build adjacency info for flow-based layout
  const placeIds = new Set((schema.places || []).map(p => p.id))
  const transitionIds = new Set((schema.transitions || []).map(t => t.id))

  // Track connections
  const placeToTransitions = {}
  const transitionToPlaces = {}
  const placeInputs = {}
  const transitionInputs = {}

  ;(schema.places || []).forEach(p => {
    placeToTransitions[p.id] = []
    placeInputs[p.id] = []
  })
  ;(schema.transitions || []).forEach(t => {
    transitionToPlaces[t.id] = []
    transitionInputs[t.id] = []
  })

  ;(schema.arcs || []).forEach(a => {
    if (placeIds.has(a.from) && transitionIds.has(a.to)) {
      placeToTransitions[a.from].push(a.to)
      transitionInputs[a.to].push(a.from)
    } else if (transitionIds.has(a.from) && placeIds.has(a.to)) {
      transitionToPlaces[a.from].push(a.to)
      placeInputs[a.to].push(a.from)
    }
  })

  // ============================================================
  // Flow-based layout: arrange places by flow order, transitions alongside
  // ============================================================

  // Compute flow order using BFS from initial/source places
  const placeOrder = []
  const placeVisited = new Set()
  const queue = []

  // Start with places that have initial tokens or no inputs (sources)
  ;(schema.places || []).forEach(p => {
    if ((p.initial || 0) > 0 || placeInputs[p.id].length === 0) {
      queue.push(p.id)
      placeVisited.add(p.id)
    }
  })

  // BFS traversal to get flow order
  while (queue.length > 0) {
    const pid = queue.shift()
    placeOrder.push(pid)

    // Find reachable places through transitions
    placeToTransitions[pid].forEach(tid => {
      transitionToPlaces[tid].forEach(nextPid => {
        if (!placeVisited.has(nextPid)) {
          placeVisited.add(nextPid)
          queue.push(nextPid)
        }
      })
    })
  }

  // Add any remaining places not reached by BFS
  ;(schema.places || []).forEach(p => {
    if (!placeVisited.has(p.id)) {
      placeOrder.push(p.id)
    }
  })

  // Group places/transitions by prefix for semantic clustering
  // Examples: p00->p, x_turn->x, win_x->win, x_play_00->x_play, x_win_row0->x_win
  function getPrefix(id) {
    // Common workflow/state names that should not be split
    const keepWhole = ['in_review', 'in_progress', 'create_post', 'can_reset', 'game_active']
    if (keepWhole.includes(id)) return id

    // x_play_00, o_play_11 -> x_play, o_play (underscore before digits)
    let match = id.match(/^([a-zA-Z]+_[a-zA-Z]+)_\d/)
    if (match) return match[1]

    // p00, x00 -> p, x (letter(s) directly followed by digits)
    match = id.match(/^([a-zA-Z]+)\d/)
    if (match) return match[1]

    // x_win_row0, o_win_col1 -> x_win, o_win (two parts before final part with digit)
    match = id.match(/^([a-zA-Z]+_[a-zA-Z]+)_[a-zA-Z]+\d/)
    if (match) return match[1]

    // x_win_diag, x_win_anti -> x_win (three parts, no trailing digit)
    match = id.match(/^([a-zA-Z]+_[a-zA-Z]+)_[a-zA-Z]+$/)
    if (match) return match[1]

    // win_x, win_o -> win (two parts, second is single letter)
    match = id.match(/^([a-zA-Z]+)_[a-zA-Z]$/)
    if (match) return match[1]

    // For two-part names not in keepWhole, keep them whole if second part is long
    // e.g., x_turn -> x (short suffix), but game_active -> game_active (long suffix, but in keepWhole)
    match = id.match(/^([a-zA-Z]+)_([a-zA-Z]+)$/)
    if (match && match[2].length <= 4) return match[1]  // Short suffix like "turn" -> use first part

    return id
  }

  // Group ordered places by prefix while maintaining relative order
  const prefixGroups = {}
  placeOrder.forEach((pid, orderIndex) => {
    const prefix = getPrefix(pid)
    if (!prefixGroups[prefix]) {
      prefixGroups[prefix] = { places: [], minOrder: orderIndex }
    }
    prefixGroups[prefix].places.push({ id: pid, order: orderIndex })
  })

  // Sort prefix groups by their earliest member's order
  const sortedPrefixes = Object.entries(prefixGroups)
    .sort((a, b) => a[1].minOrder - b[1].minOrder)
    .map(([prefix, data]) => ({ prefix, ...data }))

  // Layout constants
  const MARGIN_TOP = 80
  const MARGIN_LEFT = 100
  const H_SPACING = 130  // Horizontal spacing within groups
  const V_SPACING = 120  // Vertical spacing between rows
  const GROUP_V_GAP = 80 // Vertical gap between prefix groups

  const placePositions = {}
  const placeData = {}  // Store place data for lookup
  ;(schema.places || []).forEach(p => { placeData[p.id] = p })

  let currentY = MARGIN_TOP
  let maxX = MARGIN_LEFT

  // Layout each prefix group
  sortedPrefixes.forEach((group, groupIndex) => {
    const places = group.places.sort((a, b) => {
      // Sort by numeric suffix if present
      const aNum = parseInt(a.id.match(/\d+$/)?.[0] || '0')
      const bNum = parseInt(b.id.match(/\d+$/)?.[0] || '0')
      return aNum - bNum
    })

    // Determine grid size - try to make it roughly square
    const count = places.length
    let cols, rows
    if (count <= 4) {
      cols = count
      rows = 1
    } else if (count === 9) {
      // Special case for 3x3 grids (like tic-tac-toe cells)
      cols = 3
      rows = 3
    } else if (count <= 9) {
      cols = Math.ceil(Math.sqrt(count))
      rows = Math.ceil(count / cols)
    } else {
      cols = Math.min(count, 6)
      rows = Math.ceil(count / cols)
    }

    // Position places in a grid for this group
    places.forEach((p, i) => {
      const col = i % cols
      const row = Math.floor(i / cols)
      const x = MARGIN_LEFT + col * H_SPACING
      const y = currentY + row * V_SPACING
      placePositions[p.id] = { x, y }
      maxX = Math.max(maxX, x)
    })

    // Move to next row for next group
    currentY += rows * V_SPACING + GROUP_V_GAP
  })

  let maxYInLayer = currentY

  // Create place objects
  ;(schema.places || []).forEach(p => {
    // Use explicit x,y coordinates if provided in schema, otherwise use auto-calculated position
    const hasExplicitPos = p.x !== undefined && p.y !== undefined && (p.x !== 0 || p.y !== 0)
    const pos = hasExplicitPos ? { x: p.x, y: p.y } : (placePositions[p.id] || { x: MARGIN_LEFT, y: MARGIN_TOP })
    const initial = p.initial || 0
    const capacity = p.capacity !== undefined ? p.capacity : null  // null = unlimited
    places[p.id] = {
      '@type': 'Place',
      initial: [initial],
      capacity: [capacity],
      x: pos.x,
      y: pos.y
    }
  })

  // Group transitions by prefix for consistent positioning
  const transitionGroups = {}
  ;(schema.transitions || []).forEach(t => {
    const prefix = getPrefix(t.id)
    if (!transitionGroups[prefix]) transitionGroups[prefix] = []
    transitionGroups[prefix].push(t)
  })

  // Position transitions to the right of places, arranged in a grid
  const transitionPositions = {}
  const T_MARGIN_LEFT = maxX + H_SPACING + 80  // Start transitions to the right of all places
  const T_H_SPACING = 100
  const T_V_SPACING = 80

  // Group transitions by their primary input place's Y position
  const transitionsByInputY = {}
  ;(schema.transitions || []).forEach(t => {
    const inputs = transitionInputs[t.id] || []
    let primaryY = MARGIN_TOP
    if (inputs.length > 0) {
      // Use average Y of input places
      let sumY = 0, count = 0
      inputs.forEach(pid => {
        const pos = placePositions[pid]
        if (pos) { sumY += pos.y; count++ }
      })
      if (count > 0) primaryY = Math.round(sumY / count)
    }
    const yKey = Math.round(primaryY / 80) * 80  // Round to grid
    if (!transitionsByInputY[yKey]) transitionsByInputY[yKey] = []
    transitionsByInputY[yKey].push({ t, primaryY })
  })

  // Layout transitions row by row
  const sortedYKeys = Object.keys(transitionsByInputY).map(Number).sort((a, b) => a - b)

  sortedYKeys.forEach((yKey, rowIndex) => {
    const row = transitionsByInputY[yKey]
    // Sort transitions within row by name for consistency
    row.sort((a, b) => a.t.id.localeCompare(b.t.id))

    row.forEach((item, colIndex) => {
      const x = T_MARGIN_LEFT + colIndex * T_H_SPACING
      const y = item.primaryY
      transitionPositions[item.t.id] = { x, y }
    })
  })

  // Create transition objects
  ;(schema.transitions || []).forEach(t => {
    // Use explicit x,y coordinates if provided in schema, otherwise use auto-calculated position
    const hasExplicitPos = t.x !== undefined && t.y !== undefined && (t.x !== 0 || t.y !== 0)
    const pos = hasExplicitPos ? { x: t.x, y: t.y } : (transitionPositions[t.id] || { x: MARGIN_LEFT, y: maxYInLayer + 150 })
    transitions[t.id] = {
      '@type': 'Transition',
      x: pos.x,
      y: pos.y
    }
  })

  // Create arcs - omit weights if all are 1 (cleaner visualization)
  const allWeightsAreOne = (schema.arcs || []).every(a => (a.weight || 1) === 1)
  ;(schema.arcs || []).forEach(a => {
    const arc = {
      '@type': 'Arrow',
      source: a.from,
      target: a.to,
      inhibit: a.type === 'inhibitor'
    }
    if (!allWeightsAreOne) {
      arc.weight = [a.weight || 1]
    }
    arcs.push(arc)
  })

  return {
    '@context': 'https://pflow.xyz/schema',
    '@type': 'PetriNet',
    name: schema.name || 'Model',
    description: schema.description || '',
    places,
    transitions,
    arcs
  }
}

// Load petri-view component from CDN
let petriViewLoaded = false
async function loadPetriView() {
  if (petriViewLoaded) return

  // Load CSS
  if (!document.querySelector('link[href*="petri-view.css"]')) {
    const css = document.createElement('link')
    css.rel = 'stylesheet'
    css.href = 'https://cdn.jsdelivr.net/gh/pflow-xyz/pflow-xyz@main/public/petri-view.css'
    document.head.appendChild(css)
  }

  // Load JS as ES module (petri-view.js uses export)
  if (!customElements.get('petri-view')) {
    await new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.type = 'module'
      script.src = 'https://cdn.jsdelivr.net/gh/pflow-xyz/pflow-xyz@main/public/petri-view.js'
      script.onload = resolve
      script.onerror = reject
      document.head.appendChild(script)
    })
    // Wait for custom element to be defined
    await customElements.whenDefined('petri-view')
  }

  petriViewLoaded = true
}

// Initialize petri-view with schema
async function initPetriView() {
  if (!_currentSchema) return

  await loadPetriView()

  const petriView = document.getElementById('schema-petri-view')
  if (!petriView) return

  // Wait for component to be ready with setModel
  const waitForReady = async (maxAttempts = 20) => {
    for (let i = 0; i < maxAttempts; i++) {
      if (petriView.setModel) {
        const model = schemaToPflowModel(_currentSchema)
        petriView.setModel(model)
        // Start simulation mode so transitions can be fired by clicking
        // Wait a frame for the model to be processed
        await new Promise(r => requestAnimationFrame(r))
        if (petriView._toggleSim && !petriView._simRunning) {
          petriView._toggleSim()
        }
        // Move toolbar to top by injecting CSS into shadow DOM
        moveToolbarToTop(petriView)
        return
      }
      await new Promise(r => setTimeout(r, 50))
    }
    console.warn('petri-view setModel not available after waiting')
  }

  await waitForReady()
}

// Move petri-view toolbar to top of canvas (no shadow DOM, inject into document)
function moveToolbarToTop(petriView) {
  // Check if we already injected our styles
  if (document.getElementById('petri-toolbar-override')) return

  const style = document.createElement('style')
  style.id = 'petri-toolbar-override'
  style.textContent = `
    /* Move petri-view toolbar from bottom to top of canvas, aligned with hamburger menu */
    .pv-menu.pv-mode-menu {
      bottom: auto !important;
      top: 260px !important;
    }
  `
  document.head.appendChild(style)
}

// Schema tab switching
window.showSchemaTab = function(tabName) {
  // Update tab buttons
  document.querySelectorAll('.schema-tab').forEach(tab => {
    tab.classList.remove('active')
  })
  event.target.classList.add('active')

  // Update tab content
  document.querySelectorAll('.schema-tab-content').forEach(content => {
    content.style.display = 'none'
    content.classList.remove('active')
  })
  const targetContent = document.getElementById(`schema-tab-${tabName}`)
  if (targetContent) {
    targetContent.style.display = 'block'
    targetContent.classList.add('active')
  }

  // Initialize petri-view when tab is shown
  if (tabName === 'petrinet') {
    initPetriView()
  } else {
    // Restore scroll behavior when leaving petri-view tab
    // petri-view sets overflow:hidden on body/html for pan/zoom
    document.body.style.overflow = 'auto'
    document.documentElement.style.overflow = 'auto'
  }
}


// Admin dashboard (fallback when admin module not available)
async function renderAdminPage() {
  const app = document.getElementById('app')
  app.innerHTML = `
    <div class="page">
      <div class="page-header">
        <h1>Admin Dashboard</h1>
      </div>
      <div id="admin-stats" class="card">
        <div class="loading">Loading statistics...</div>
      </div>
      <div id="admin-instances" class="card">
        <div class="card-header">Recent Instances</div>
        <div class="loading">Loading...</div>
      </div>
    </div>
  `

  try {
    const [stats, instancesResult] = await Promise.all([
      fetch(`${API_BASE}/admin/stats`, { headers: getHeaders() }).then(r => r.json()).catch(() => null),
      api.listInstances()
    ])

    if (stats) {
      document.getElementById('admin-stats').innerHTML = `
        <div class="card-header">Statistics</div>
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 1rem;">
          <div>
            <div style="font-size: 2rem; font-weight: 600;">${stats.total_streams || 0}</div>
            <div style="color: #666;">Total Instances</div>
          </div>
          <div>
            <div style="font-size: 2rem; font-weight: 600;">${stats.total_events || 0}</div>
            <div style="color: #666;">Total Events</div>
          </div>
        </div>
      `
    } else {
      document.getElementById('admin-stats').innerHTML = ''
    }

    instances = instancesResult.instances || []
    const container = document.getElementById('admin-instances').querySelector('.loading')
    if (container) {
      container.outerHTML = instances.length > 0
        ? `<table class="table">
            <thead>
              <tr>
                <th>ID</th>
                <th>Status</th>
                <th>Version</th>
                <th>Actions</th>
              </tr>
            </thead>
            <tbody>
              ${instances.slice(0, 20).map(inst => {
                const status = getStatus(inst.state || inst.places)
                return `
                  <tr>
                    <td><code>${inst.id}</code></td>
                    <td>${formatStatus(status)}</td>
                    <td>${inst.version || 0}</td>
                    <td><button class="btn btn-sm btn-link" onclick="navigate('/tic-tac-toe/${inst.id}')">View</button></td>
                  </tr>
                `
              }).join('')}
            </tbody>
          </table>`
        : '<p style="color: #666; padding: 1rem;">No instances yet.</p>'
    }
  } catch (err) {
    showError('Failed to load admin data: ' + err.message)
  }
}


// ============================================================================
// Event Handlers
// ============================================================================

window.navigate = navigate

window.handleCreateNew = async function() {
  navigate('/tic-tac-toe/new')
}

window.handleSubmitCreate = async function(event) {
  event.preventDefault()
  try {
    const result = await api.createInstance({})
    showSuccess('Instance created successfully!')
    navigate(`/tic-tac-toe/${result.aggregate_id || result.id}`)
  } catch (err) {
    showError('Failed to create: ' + err.message)
  }
}

window.handleTransition = async function(transitionId) {
  if (!currentInstance) return

  // Check if transition has fields - show modal if so
  const transition = TRANSITION_DEFS.find(t => t.id === transitionId)
  if (transition && transition.fields && transition.fields.length > 0) {
    showActionModal(transitionId)
    return
  }

  // No fields - execute directly
  try {
    const result = await api.executeTransition(transitionId, currentInstance.id)
    currentInstance = {
      ...currentInstance,
      version: result.version,
      state: result.state,
      displayState: unscaleStateData(result.state),
      places: result.state,
      enabled: result.enabled || [],
    }
    // Store state for wallet balance display
    window.currentInstanceState = currentInstance.state
    renderInstanceDetail()
    showSuccess(`Action "${transitionId}" completed!`)
  } catch (err) {
    showError(`Failed to execute ${transitionId}: ${err.message}`)
  }
}

// ============================================================================
// Routing
// ============================================================================

function handleRouteChange(event) {
  const route = event.detail?.route || getCurrentRoute()
  if (!route) {
    renderListPage()
    return
  }

  const path = route.path
  if (path === '/tic-tac-toe' || path === '/') {
    renderListPage()
  } else if (path === '/tic-tac-toe/new') {
    renderFormPage()
  } else if (path === '/tic-tac-toe/:id') {
    renderDetailPage()
  } else if (path === '/schema') {
    renderSchemaPage()
  } else {
    renderListPage()
  }
}

// ============================================================================
// OAuth Callback Handler
// ============================================================================

async function handleOAuthCallback() {
  const params = new URLSearchParams(window.location.search)
  const token = params.get('token')
  const expiresAt = params.get('expires_at')

  if (token) {
    authToken = token
    try {
      const user = await api.getMe()
      saveAuth({ token, expires_at: expiresAt, user })
      window.history.replaceState({}, '', window.location.pathname)
      await refreshNavigation()
    } catch (err) {
      clearAuth()
      showError('Failed to complete login')
    }
  }
}

// ============================================================================
// Initialize
// ============================================================================

async function init() {
  // Load auth state
  loadAuth()

  // Handle OAuth callback
  await handleOAuthCallback()

  // Load view definitions
  await loadViews()

  // Render navigation
  const nav = document.getElementById('nav')
  nav.innerHTML = await createNavigation()

  // Add action modal to body
  const modalContainer = document.createElement('div')
  modalContainer.innerHTML = createActionModal()
  document.body.appendChild(modalContainer)

  // Setup routing
  window.addEventListener('route-change', handleRouteChange)
  initRouter()

  // Initial render
  handleRouteChange({ detail: { route: getCurrentRoute() } })
}



// Start the app
init()

