// Code generated by petri-pilot. DO NOT EDIT.

package tictactoe

import (
	"context"
	"encoding/base64"
	"encoding/json"
	"io/fs"
	"net/http"
	"os"
	"path/filepath"
	"strconv"
	"strings"

	"github.com/pflow-xyz/petri-pilot/pkg/runtime/api"
	"github.com/pflow-xyz/petri-pilot/pkg/runtime/eventstore"
)

// BuildRouter creates an HTTP router for the tic-tac-toe workflow.
func BuildRouter(app *Application, debugBroker *DebugBroker) http.Handler {
	r := api.NewRouter()

	// Health check
	r.GET("/health", "Health check", func(w http.ResponseWriter, r *http.Request) {
		api.JSON(w, http.StatusOK, map[string]string{"status": "ok"})
	})

	// Readiness check
	r.GET("/ready", "Readiness check", HandleReady(app))

	// Create new game
	r.POST("/api/tictactoe", "Create new game", HandleCreate(app))

	// Get game state
	r.GET("/api/tictactoe/{id}", "Get game state", HandleGetState(app))

	// Get events
	r.GET("/api/tictactoe/{id}/events", "Get event history", HandleGetEvents(app))

	// Schema endpoint
	r.GET("/api/schema", "Get model schema", HandleGetSchema())

	// Simulation endpoint
	r.GET("/api/simulation", "Get simulation data", HandleGetSimulation())

	// Admin endpoints
	r.GET("/admin/stats", "Admin statistics", HandleAdminStats(app))
	r.GET("/admin/instances", "List instances", HandleAdminListInstances(app))

	// Debug WebSocket
	r.GET("/ws", "Debug WebSocket connection", HandleDebugWebSocket(debugBroker))
	r.GET("/api/debug/sessions", "List debug sessions", HandleListSessions(debugBroker))
	r.POST("/api/debug/sessions/{id}/eval", "Evaluate code", HandleSessionEval(debugBroker))

	// Transition endpoints - X moves
	r.Transition("x_play_00", "/api/x_play_00", "X plays position (0,0)", HandleTransition(app, TransitionXPlay00))
	r.Transition("x_play_01", "/api/x_play_01", "X plays position (0,1)", HandleTransition(app, TransitionXPlay01))
	r.Transition("x_play_02", "/api/x_play_02", "X plays position (0,2)", HandleTransition(app, TransitionXPlay02))
	r.Transition("x_play_10", "/api/x_play_10", "X plays position (1,0)", HandleTransition(app, TransitionXPlay10))
	r.Transition("x_play_11", "/api/x_play_11", "X plays position (1,1)", HandleTransition(app, TransitionXPlay11))
	r.Transition("x_play_12", "/api/x_play_12", "X plays position (1,2)", HandleTransition(app, TransitionXPlay12))
	r.Transition("x_play_20", "/api/x_play_20", "X plays position (2,0)", HandleTransition(app, TransitionXPlay20))
	r.Transition("x_play_21", "/api/x_play_21", "X plays position (2,1)", HandleTransition(app, TransitionXPlay21))
	r.Transition("x_play_22", "/api/x_play_22", "X plays position (2,2)", HandleTransition(app, TransitionXPlay22))

	// Transition endpoints - O moves
	r.Transition("o_play_00", "/api/o_play_00", "O plays position (0,0)", HandleTransition(app, TransitionOPlay00))
	r.Transition("o_play_01", "/api/o_play_01", "O plays position (0,1)", HandleTransition(app, TransitionOPlay01))
	r.Transition("o_play_02", "/api/o_play_02", "O plays position (0,2)", HandleTransition(app, TransitionOPlay02))
	r.Transition("o_play_10", "/api/o_play_10", "O plays position (1,0)", HandleTransition(app, TransitionOPlay10))
	r.Transition("o_play_11", "/api/o_play_11", "O plays position (1,1)", HandleTransition(app, TransitionOPlay11))
	r.Transition("o_play_12", "/api/o_play_12", "O plays position (1,2)", HandleTransition(app, TransitionOPlay12))
	r.Transition("o_play_20", "/api/o_play_20", "O plays position (2,0)", HandleTransition(app, TransitionOPlay20))
	r.Transition("o_play_21", "/api/o_play_21", "O plays position (2,1)", HandleTransition(app, TransitionOPlay21))
	r.Transition("o_play_22", "/api/o_play_22", "O plays position (2,2)", HandleTransition(app, TransitionOPlay22))

	// Reset game
	r.Transition("reset", "/api/reset", "Reset game", HandleTransition(app, TransitionReset))

	// Serve frontend static files
	r.StaticFiles("/", StaticFileHandler())

	return r.Build()
}

// StaticFileHandler returns an http.Handler that serves static files from frontend/.
func StaticFileHandler() http.HandlerFunc {
	frontendPath := "frontend"
	if _, err := os.Stat(frontendPath); os.IsNotExist(err) {
		exe, _ := os.Executable()
		frontendPath = filepath.Join(filepath.Dir(exe), "frontend")
	}

	return func(w http.ResponseWriter, r *http.Request) {
		path := strings.TrimPrefix(r.URL.Path, "/")
		if path == "" {
			path = "index.html"
		}

		fullPath := filepath.Join(frontendPath, path)
		info, err := os.Stat(fullPath)
		if err != nil || info.IsDir() {
			http.ServeFile(w, r, filepath.Join(frontendPath, "index.html"))
			return
		}

		http.ServeFile(w, r, fullPath)
	}
}

// StaticFS interface for embedding static files
type StaticFS interface {
	fs.FS
}

// HandleCreate creates a new game instance.
func HandleCreate(app *Application) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()

		id, err := app.Create(ctx)
		if err != nil {
			api.Error(w, http.StatusInternalServerError, "CREATE_FAILED", err.Error())
			return
		}

		agg, err := app.Load(ctx, id)
		if err != nil {
			api.Error(w, http.StatusInternalServerError, "LOAD_FAILED", err.Error())
			return
		}

		api.JSON(w, http.StatusCreated, api.StateResponse{
			AggregateID:        agg.ID(),
			Version:            agg.Version(),
			State:              agg.State(),
			Places:             agg.Places(),
			EnabledTransitions: agg.EnabledTransitions(),
		})
	}
}

// HandleGetState returns the current state of a game.
func HandleGetState(app *Application) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()
		id := r.PathValue("id")
		if id == "" {
			api.Error(w, http.StatusBadRequest, "MISSING_ID", "game ID is required")
			return
		}

		agg, err := app.GetState(ctx, id)
		if err != nil {
			api.Error(w, http.StatusNotFound, "NOT_FOUND", err.Error())
			return
		}

		api.JSON(w, http.StatusOK, api.StateResponse{
			AggregateID:        agg.ID(),
			Version:            agg.Version(),
			State:              agg.State(),
			Places:             agg.Places(),
			EnabledTransitions: agg.EnabledTransitions(),
		})
	}
}

// HandleReady checks if the application is ready.
func HandleReady(app *Application) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		checks := make(map[string]string)
		ready := true

		if err := app.HealthCheck(r.Context()); err != nil {
			checks["eventstore"] = err.Error()
			ready = false
		} else {
			checks["eventstore"] = "ok"
		}

		status := http.StatusOK
		statusText := "ready"
		if !ready {
			status = http.StatusServiceUnavailable
			statusText = "not ready"
		}

		api.JSON(w, status, map[string]any{
			"status": statusText,
			"checks": checks,
		})
	}
}

// HandleTransition handles any transition execution.
func HandleTransition(app *Application, transitionID string) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()

		var req api.TransitionRequest
		if err := api.DecodeJSON(r, &req); err != nil {
			api.Error(w, http.StatusBadRequest, "INVALID_REQUEST", err.Error())
			return
		}

		if req.AggregateID == "" {
			api.Error(w, http.StatusBadRequest, "MISSING_ID", "aggregate_id is required")
			return
		}

		// Parse the data as a generic map
		var data map[string]interface{}
		if len(req.Data) > 0 {
			if err := json.Unmarshal(req.Data, &data); err != nil {
				data = nil
			}
		}

		agg, err := app.Execute(ctx, req.AggregateID, transitionID, data)
		if err != nil {
			api.Error(w, http.StatusConflict, "TRANSITION_FAILED", err.Error())
			return
		}

		api.JSON(w, http.StatusOK, api.TransitionResult{
			Success:            true,
			AggregateID:        agg.ID(),
			Version:            agg.Version(),
			State:              agg.Places(),
			EnabledTransitions: agg.EnabledTransitions(),
		})
	}
}

// HandleGetEvents returns the event history for a game.
func HandleGetEvents(app *Application) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()
		id := r.PathValue("id")
		from := getIntQueryParam(r, "from", 0)

		events, err := app.store.Read(ctx, id, from)
		if err != nil {
			api.Error(w, http.StatusInternalServerError, "READ_FAILED", err.Error())
			return
		}

		api.JSON(w, http.StatusOK, map[string]interface{}{
			"events": events,
		})
	}
}

// HandleAdminStats returns admin statistics.
func HandleAdminStats(app *Application) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()

		adminStore, ok := app.store.(interface {
			GetStats(ctx context.Context) (*eventstore.Stats, error)
		})
		if !ok {
			api.Error(w, http.StatusInternalServerError, "UNSUPPORTED", "Admin operations not supported")
			return
		}

		stats, err := adminStore.GetStats(ctx)
		if err != nil {
			api.Error(w, http.StatusInternalServerError, "STATS_FAILED", err.Error())
			return
		}

		api.JSON(w, http.StatusOK, stats)
	}
}

// HandleAdminListInstances lists all game instances.
func HandleAdminListInstances(app *Application) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()

		place := r.URL.Query().Get("place")
		from := r.URL.Query().Get("from")
		to := r.URL.Query().Get("to")
		page := getIntQueryParam(r, "page", 1)
		perPage := getIntQueryParam(r, "per_page", 50)

		adminStore, ok := app.store.(interface {
			ListInstances(ctx context.Context, place, from, to string, page, perPage int) ([]eventstore.Instance, int, error)
		})
		if !ok {
			api.Error(w, http.StatusInternalServerError, "UNSUPPORTED", "Admin operations not supported")
			return
		}

		instances, total, err := adminStore.ListInstances(ctx, place, from, to, page, perPage)
		if err != nil {
			api.Error(w, http.StatusInternalServerError, "LIST_FAILED", err.Error())
			return
		}

		for i := range instances {
			agg, err := app.Load(ctx, instances[i].ID)
			if err != nil {
				continue
			}
			instances[i].State = agg.Places()
		}

		api.JSON(w, http.StatusOK, map[string]interface{}{
			"instances": instances,
			"total":     total,
			"page":      page,
			"per_page":  perPage,
		})
	}
}

// HandleGetSchema returns the model schema.
func HandleGetSchema() http.HandlerFunc {
	schemaJSON := `{
  "name": "tic-tac-toe",
  "description": "Tic-Tac-Toe game modeled as a Petri net",
  "places": [
    {"id": "p00", "description": "Empty cell (0,0)", "initial": 1},
    {"id": "p01", "description": "Empty cell (0,1)", "initial": 1},
    {"id": "p02", "description": "Empty cell (0,2)", "initial": 1},
    {"id": "p10", "description": "Empty cell (1,0)", "initial": 1},
    {"id": "p11", "description": "Empty cell (1,1) - center", "initial": 1},
    {"id": "p12", "description": "Empty cell (1,2)", "initial": 1},
    {"id": "p20", "description": "Empty cell (2,0)", "initial": 1},
    {"id": "p21", "description": "Empty cell (2,1)", "initial": 1},
    {"id": "p22", "description": "Empty cell (2,2)", "initial": 1},
    {"id": "x_turn", "description": "X's turn", "initial": 1},
    {"id": "o_turn", "description": "O's turn", "initial": 0},
    {"id": "x00", "description": "X at (0,0)", "initial": 0},
    {"id": "x01", "description": "X at (0,1)", "initial": 0},
    {"id": "x02", "description": "X at (0,2)", "initial": 0},
    {"id": "x10", "description": "X at (1,0)", "initial": 0},
    {"id": "x11", "description": "X at (1,1)", "initial": 0},
    {"id": "x12", "description": "X at (1,2)", "initial": 0},
    {"id": "x20", "description": "X at (2,0)", "initial": 0},
    {"id": "x21", "description": "X at (2,1)", "initial": 0},
    {"id": "x22", "description": "X at (2,2)", "initial": 0},
    {"id": "o00", "description": "O at (0,0)", "initial": 0},
    {"id": "o01", "description": "O at (0,1)", "initial": 0},
    {"id": "o02", "description": "O at (0,2)", "initial": 0},
    {"id": "o10", "description": "O at (1,0)", "initial": 0},
    {"id": "o11", "description": "O at (1,1)", "initial": 0},
    {"id": "o12", "description": "O at (1,2)", "initial": 0},
    {"id": "o20", "description": "O at (2,0)", "initial": 0},
    {"id": "o21", "description": "O at (2,1)", "initial": 0},
    {"id": "o22", "description": "O at (2,2)", "initial": 0},
    {"id": "x_wins", "description": "X wins", "initial": 0},
    {"id": "o_wins", "description": "O wins", "initial": 0},
    {"id": "draw", "description": "Game is a draw", "initial": 0},
    {"id": "game_over", "description": "Game has ended", "initial": 0}
  ],
  "transitions": [
    {"id": "x_play_00", "description": "X plays (0,0)"},
    {"id": "x_play_01", "description": "X plays (0,1)"},
    {"id": "x_play_02", "description": "X plays (0,2)"},
    {"id": "x_play_10", "description": "X plays (1,0)"},
    {"id": "x_play_11", "description": "X plays (1,1)"},
    {"id": "x_play_12", "description": "X plays (1,2)"},
    {"id": "x_play_20", "description": "X plays (2,0)"},
    {"id": "x_play_21", "description": "X plays (2,1)"},
    {"id": "x_play_22", "description": "X plays (2,2)"},
    {"id": "o_play_00", "description": "O plays (0,0)"},
    {"id": "o_play_01", "description": "O plays (0,1)"},
    {"id": "o_play_02", "description": "O plays (0,2)"},
    {"id": "o_play_10", "description": "O plays (1,0)"},
    {"id": "o_play_11", "description": "O plays (1,1)"},
    {"id": "o_play_12", "description": "O plays (1,2)"},
    {"id": "o_play_20", "description": "O plays (2,0)"},
    {"id": "o_play_21", "description": "O plays (2,1)"},
    {"id": "o_play_22", "description": "O plays (2,2)"},
    {"id": "reset", "description": "Reset game"}
  ],
  "strategic_values": {
    "description": "Strategic position values derived from Petri net topology (ODE simulation)",
    "center": 0.430,
    "corners": 0.316,
    "edges": 0.218,
    "positions": {
      "00": 0.316, "01": 0.218, "02": 0.316,
      "10": 0.218, "11": 0.430, "12": 0.218,
      "20": 0.316, "21": 0.218, "22": 0.316
    }
  }
}`

	schemaBase64 := base64.StdEncoding.EncodeToString([]byte(schemaJSON))

	return func(w http.ResponseWriter, r *http.Request) {
		decoded, err := base64.StdEncoding.DecodeString(schemaBase64)
		if err != nil {
			api.Error(w, http.StatusInternalServerError, "schema_decode_error", "Failed to decode schema")
			return
		}
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusOK)
		w.Write(decoded)
	}
}

// HandleGetSimulation returns simulation data for the tic-tac-toe game.
func HandleGetSimulation() http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// Strategic values from ODE simulation
		// Based on the blog post: center participates in 4 winning patterns,
		// corners in 3, edges in 2
		simulation := map[string]interface{}{
			"description": "Petri net ODE-based strategic evaluation",
			"method":      "Continuous dynamics approximating minimax evaluation",
			"positions": []map[string]interface{}{
				{"row": 0, "col": 0, "type": "corner", "value": 0.316, "patterns": 3},
				{"row": 0, "col": 1, "type": "edge", "value": 0.218, "patterns": 2},
				{"row": 0, "col": 2, "type": "corner", "value": 0.316, "patterns": 3},
				{"row": 1, "col": 0, "type": "edge", "value": 0.218, "patterns": 2},
				{"row": 1, "col": 1, "type": "center", "value": 0.430, "patterns": 4},
				{"row": 1, "col": 2, "type": "edge", "value": 0.218, "patterns": 2},
				{"row": 2, "col": 0, "type": "corner", "value": 0.316, "patterns": 3},
				{"row": 2, "col": 1, "type": "edge", "value": 0.218, "patterns": 2},
				{"row": 2, "col": 2, "type": "corner", "value": 0.316, "patterns": 3},
			},
			"win_patterns": [][]int{
				{0, 1, 2},    // top row
				{3, 4, 5},    // middle row
				{6, 7, 8},    // bottom row
				{0, 3, 6},    // left column
				{1, 4, 7},    // center column
				{2, 5, 8},    // right column
				{0, 4, 8},    // diagonal
				{2, 4, 6},    // anti-diagonal
			},
		}

		api.JSON(w, http.StatusOK, simulation)
	}
}

// Helper functions

func getIntQueryParam(r *http.Request, name string, defaultVal int) int {
	val := r.URL.Query().Get(name)
	if val == "" {
		return defaultVal
	}
	intVal, err := strconv.Atoi(val)
	if err != nil {
		return defaultVal
	}
	return intVal
}

// Ensure eventstore is used (for compiler)
var _ = json.Marshal
