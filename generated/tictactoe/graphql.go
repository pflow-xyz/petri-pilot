// Code generated by petri-pilot. DO NOT EDIT.

package tictactoe

import (
	"context"
	"encoding/json"
	"net/http"

	"github.com/pflow-xyz/petri-pilot/generated/tictactoe/graph"
	"github.com/pflow-xyz/go-pflow/eventsource"
	"github.com/pflow-xyz/petri-pilot/pkg/serve"
)

// GraphQLConfig holds the GraphQL server configuration.
var GraphQLConfig = struct {
	Path       string
	Playground bool
}{
	Path:       "/graphql",
	Playground: true,
}

// GraphQLHandler creates the GraphQL HTTP handler.
func GraphQLHandler(app *Application) http.HandlerFunc {
	resolver := graph.NewResolver(&graphQLApp{app: app})
	h := &graphQLHandler{resolver: resolver}
	return h.ServeHTTP
}

// PlaygroundHandler serves the GraphQL Playground UI.
func PlaygroundHandler() http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "text/html; charset=utf-8")
		w.Write([]byte(playgroundHTML))
	}
}

var playgroundHTML = "<!DOCTYPE html>\n" +
	"<html>\n" +
	"<head>\n" +
	"  <title>tic-tac-toe GraphQL Playground</title>\n" +
	"  <link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/graphql-playground-react/build/static/css/index.css\" />\n" +
	"  <link rel=\"shortcut icon\" href=\"https://cdn.jsdelivr.net/npm/graphql-playground-react/build/favicon.png\" />\n" +
	"  <script src=\"https://cdn.jsdelivr.net/npm/graphql-playground-react/build/static/js/middleware.js\"></script>\n" +
	"</head>\n" +
	"<body>\n" +
	"  <div id=\"root\"></div>\n" +
	"  <script>\n" +
	"    window.addEventListener('load', function() {\n" +
	"      GraphQLPlayground.init(document.getElementById('root'), {\n" +
	"        endpoint: '/graphql',\n" +
	"        settings: {\n" +
	"          'editor.theme': 'dark',\n" +
	"          'editor.fontFamily': \"'Source Code Pro', 'Consolas', 'Inconsolata', 'Droid Sans Mono', 'Monaco', monospace\",\n" +
	"          'editor.fontSize': 14,\n" +
	"          'request.credentials': 'same-origin'\n" +
	"        }\n" +
	"      })\n" +
	"    })\n" +
	"  </script>\n" +
	"</body>\n" +
	"</html>\n"


// graphQLApp wraps Application to implement the resolver interface.
type graphQLApp struct {
	app *Application
}

func (a *graphQLApp) Create(ctx context.Context) (string, error) {
	return a.app.Create(ctx)
}

func (a *graphQLApp) Load(ctx context.Context, id string) (graph.Aggregate, error) {
	return a.app.Load(ctx, id)
}

func (a *graphQLApp) GetState(ctx context.Context, id string) (graph.Aggregate, error) {
	return a.app.GetState(ctx, id)
}

func (a *graphQLApp) Execute(ctx context.Context, id, transition string, data map[string]any) (graph.Aggregate, error) {
	return a.app.Execute(ctx, id, transition, data)
}

func (a *graphQLApp) HealthCheck(ctx context.Context) error {
	return a.app.HealthCheck(ctx)
}

func (a *graphQLApp) GetStore() eventsource.Store {
	return a.app.store
}


// graphQLHandler implements a simple GraphQL HTTP handler.
type graphQLHandler struct {
	resolver *graph.Resolver
}

func (h *graphQLHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	var req struct {
		Query         string                 `json:"query"`
		OperationName string                 `json:"operationName"`
		Variables     map[string]interface{} `json:"variables"`
	}

	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}

	// Execute the GraphQL operation
	result := h.executeGraphQL(r.Context(), req.Query, req.OperationName, req.Variables)

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(result)
}

func (h *graphQLHandler) executeGraphQL(ctx context.Context, query, operationName string, variables map[string]interface{}) map[string]interface{} {
	// This is a simplified GraphQL executor
	// In production, use github.com/99designs/gqlgen for full spec compliance

	result := make(map[string]interface{})
	data := make(map[string]interface{})
	var errors []map[string]interface{}

	// Detect mutation vs query
	isMutation := containsString(query, "mutation")

	// Handle create mutation
	if isMutation && containsString(query, "createTicTacToe") {
		state, err := h.resolver.CreateTicTacToe(ctx)
		if err != nil {
			errors = append(errors, map[string]interface{}{"message": err.Error()})
		} else {
			data["createTicTacToe"] = state
		}
	}

	// Handle transition mutations

	if isMutation && containsString(query, "xPlay00") {
		input := graph.XPlay00Input{}
		if vars, ok := variables["input"].(map[string]interface{}); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		res, err := h.resolver.XPlay00(ctx, input)
		if err != nil {
			errors = append(errors, map[string]interface{}{"message": err.Error()})
		} else {
			data["xPlay00"] = res
		}
	}

	if isMutation && containsString(query, "xPlay01") {
		input := graph.XPlay01Input{}
		if vars, ok := variables["input"].(map[string]interface{}); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		res, err := h.resolver.XPlay01(ctx, input)
		if err != nil {
			errors = append(errors, map[string]interface{}{"message": err.Error()})
		} else {
			data["xPlay01"] = res
		}
	}

	if isMutation && containsString(query, "xPlay02") {
		input := graph.XPlay02Input{}
		if vars, ok := variables["input"].(map[string]interface{}); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		res, err := h.resolver.XPlay02(ctx, input)
		if err != nil {
			errors = append(errors, map[string]interface{}{"message": err.Error()})
		} else {
			data["xPlay02"] = res
		}
	}

	if isMutation && containsString(query, "xPlay10") {
		input := graph.XPlay10Input{}
		if vars, ok := variables["input"].(map[string]interface{}); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		res, err := h.resolver.XPlay10(ctx, input)
		if err != nil {
			errors = append(errors, map[string]interface{}{"message": err.Error()})
		} else {
			data["xPlay10"] = res
		}
	}

	if isMutation && containsString(query, "xPlay11") {
		input := graph.XPlay11Input{}
		if vars, ok := variables["input"].(map[string]interface{}); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		res, err := h.resolver.XPlay11(ctx, input)
		if err != nil {
			errors = append(errors, map[string]interface{}{"message": err.Error()})
		} else {
			data["xPlay11"] = res
		}
	}

	if isMutation && containsString(query, "xPlay12") {
		input := graph.XPlay12Input{}
		if vars, ok := variables["input"].(map[string]interface{}); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		res, err := h.resolver.XPlay12(ctx, input)
		if err != nil {
			errors = append(errors, map[string]interface{}{"message": err.Error()})
		} else {
			data["xPlay12"] = res
		}
	}

	if isMutation && containsString(query, "xPlay20") {
		input := graph.XPlay20Input{}
		if vars, ok := variables["input"].(map[string]interface{}); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		res, err := h.resolver.XPlay20(ctx, input)
		if err != nil {
			errors = append(errors, map[string]interface{}{"message": err.Error()})
		} else {
			data["xPlay20"] = res
		}
	}

	if isMutation && containsString(query, "xPlay21") {
		input := graph.XPlay21Input{}
		if vars, ok := variables["input"].(map[string]interface{}); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		res, err := h.resolver.XPlay21(ctx, input)
		if err != nil {
			errors = append(errors, map[string]interface{}{"message": err.Error()})
		} else {
			data["xPlay21"] = res
		}
	}

	if isMutation && containsString(query, "xPlay22") {
		input := graph.XPlay22Input{}
		if vars, ok := variables["input"].(map[string]interface{}); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		res, err := h.resolver.XPlay22(ctx, input)
		if err != nil {
			errors = append(errors, map[string]interface{}{"message": err.Error()})
		} else {
			data["xPlay22"] = res
		}
	}

	if isMutation && containsString(query, "oPlay00") {
		input := graph.OPlay00Input{}
		if vars, ok := variables["input"].(map[string]interface{}); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		res, err := h.resolver.OPlay00(ctx, input)
		if err != nil {
			errors = append(errors, map[string]interface{}{"message": err.Error()})
		} else {
			data["oPlay00"] = res
		}
	}

	if isMutation && containsString(query, "oPlay01") {
		input := graph.OPlay01Input{}
		if vars, ok := variables["input"].(map[string]interface{}); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		res, err := h.resolver.OPlay01(ctx, input)
		if err != nil {
			errors = append(errors, map[string]interface{}{"message": err.Error()})
		} else {
			data["oPlay01"] = res
		}
	}

	if isMutation && containsString(query, "oPlay02") {
		input := graph.OPlay02Input{}
		if vars, ok := variables["input"].(map[string]interface{}); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		res, err := h.resolver.OPlay02(ctx, input)
		if err != nil {
			errors = append(errors, map[string]interface{}{"message": err.Error()})
		} else {
			data["oPlay02"] = res
		}
	}

	if isMutation && containsString(query, "oPlay10") {
		input := graph.OPlay10Input{}
		if vars, ok := variables["input"].(map[string]interface{}); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		res, err := h.resolver.OPlay10(ctx, input)
		if err != nil {
			errors = append(errors, map[string]interface{}{"message": err.Error()})
		} else {
			data["oPlay10"] = res
		}
	}

	if isMutation && containsString(query, "oPlay11") {
		input := graph.OPlay11Input{}
		if vars, ok := variables["input"].(map[string]interface{}); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		res, err := h.resolver.OPlay11(ctx, input)
		if err != nil {
			errors = append(errors, map[string]interface{}{"message": err.Error()})
		} else {
			data["oPlay11"] = res
		}
	}

	if isMutation && containsString(query, "oPlay12") {
		input := graph.OPlay12Input{}
		if vars, ok := variables["input"].(map[string]interface{}); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		res, err := h.resolver.OPlay12(ctx, input)
		if err != nil {
			errors = append(errors, map[string]interface{}{"message": err.Error()})
		} else {
			data["oPlay12"] = res
		}
	}

	if isMutation && containsString(query, "oPlay20") {
		input := graph.OPlay20Input{}
		if vars, ok := variables["input"].(map[string]interface{}); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		res, err := h.resolver.OPlay20(ctx, input)
		if err != nil {
			errors = append(errors, map[string]interface{}{"message": err.Error()})
		} else {
			data["oPlay20"] = res
		}
	}

	if isMutation && containsString(query, "oPlay21") {
		input := graph.OPlay21Input{}
		if vars, ok := variables["input"].(map[string]interface{}); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		res, err := h.resolver.OPlay21(ctx, input)
		if err != nil {
			errors = append(errors, map[string]interface{}{"message": err.Error()})
		} else {
			data["oPlay21"] = res
		}
	}

	if isMutation && containsString(query, "oPlay22") {
		input := graph.OPlay22Input{}
		if vars, ok := variables["input"].(map[string]interface{}); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		res, err := h.resolver.OPlay22(ctx, input)
		if err != nil {
			errors = append(errors, map[string]interface{}{"message": err.Error()})
		} else {
			data["oPlay22"] = res
		}
	}

	if isMutation && containsString(query, "reset") {
		input := graph.ResetInput{}
		if vars, ok := variables["input"].(map[string]interface{}); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		res, err := h.resolver.Reset(ctx, input)
		if err != nil {
			errors = append(errors, map[string]interface{}{"message": err.Error()})
		} else {
			data["reset"] = res
		}
	}

	if isMutation && containsString(query, "xWinRow0") {
		input := graph.XWinRow0Input{}
		if vars, ok := variables["input"].(map[string]interface{}); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		res, err := h.resolver.XWinRow0(ctx, input)
		if err != nil {
			errors = append(errors, map[string]interface{}{"message": err.Error()})
		} else {
			data["xWinRow0"] = res
		}
	}

	if isMutation && containsString(query, "xWinRow1") {
		input := graph.XWinRow1Input{}
		if vars, ok := variables["input"].(map[string]interface{}); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		res, err := h.resolver.XWinRow1(ctx, input)
		if err != nil {
			errors = append(errors, map[string]interface{}{"message": err.Error()})
		} else {
			data["xWinRow1"] = res
		}
	}

	if isMutation && containsString(query, "xWinRow2") {
		input := graph.XWinRow2Input{}
		if vars, ok := variables["input"].(map[string]interface{}); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		res, err := h.resolver.XWinRow2(ctx, input)
		if err != nil {
			errors = append(errors, map[string]interface{}{"message": err.Error()})
		} else {
			data["xWinRow2"] = res
		}
	}

	if isMutation && containsString(query, "xWinCol0") {
		input := graph.XWinCol0Input{}
		if vars, ok := variables["input"].(map[string]interface{}); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		res, err := h.resolver.XWinCol0(ctx, input)
		if err != nil {
			errors = append(errors, map[string]interface{}{"message": err.Error()})
		} else {
			data["xWinCol0"] = res
		}
	}

	if isMutation && containsString(query, "xWinCol1") {
		input := graph.XWinCol1Input{}
		if vars, ok := variables["input"].(map[string]interface{}); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		res, err := h.resolver.XWinCol1(ctx, input)
		if err != nil {
			errors = append(errors, map[string]interface{}{"message": err.Error()})
		} else {
			data["xWinCol1"] = res
		}
	}

	if isMutation && containsString(query, "xWinCol2") {
		input := graph.XWinCol2Input{}
		if vars, ok := variables["input"].(map[string]interface{}); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		res, err := h.resolver.XWinCol2(ctx, input)
		if err != nil {
			errors = append(errors, map[string]interface{}{"message": err.Error()})
		} else {
			data["xWinCol2"] = res
		}
	}

	if isMutation && containsString(query, "xWinDiag") {
		input := graph.XWinDiagInput{}
		if vars, ok := variables["input"].(map[string]interface{}); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		res, err := h.resolver.XWinDiag(ctx, input)
		if err != nil {
			errors = append(errors, map[string]interface{}{"message": err.Error()})
		} else {
			data["xWinDiag"] = res
		}
	}

	if isMutation && containsString(query, "xWinAnti") {
		input := graph.XWinAntiInput{}
		if vars, ok := variables["input"].(map[string]interface{}); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		res, err := h.resolver.XWinAnti(ctx, input)
		if err != nil {
			errors = append(errors, map[string]interface{}{"message": err.Error()})
		} else {
			data["xWinAnti"] = res
		}
	}

	if isMutation && containsString(query, "oWinRow0") {
		input := graph.OWinRow0Input{}
		if vars, ok := variables["input"].(map[string]interface{}); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		res, err := h.resolver.OWinRow0(ctx, input)
		if err != nil {
			errors = append(errors, map[string]interface{}{"message": err.Error()})
		} else {
			data["oWinRow0"] = res
		}
	}

	if isMutation && containsString(query, "oWinRow1") {
		input := graph.OWinRow1Input{}
		if vars, ok := variables["input"].(map[string]interface{}); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		res, err := h.resolver.OWinRow1(ctx, input)
		if err != nil {
			errors = append(errors, map[string]interface{}{"message": err.Error()})
		} else {
			data["oWinRow1"] = res
		}
	}

	if isMutation && containsString(query, "oWinRow2") {
		input := graph.OWinRow2Input{}
		if vars, ok := variables["input"].(map[string]interface{}); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		res, err := h.resolver.OWinRow2(ctx, input)
		if err != nil {
			errors = append(errors, map[string]interface{}{"message": err.Error()})
		} else {
			data["oWinRow2"] = res
		}
	}

	if isMutation && containsString(query, "oWinCol0") {
		input := graph.OWinCol0Input{}
		if vars, ok := variables["input"].(map[string]interface{}); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		res, err := h.resolver.OWinCol0(ctx, input)
		if err != nil {
			errors = append(errors, map[string]interface{}{"message": err.Error()})
		} else {
			data["oWinCol0"] = res
		}
	}

	if isMutation && containsString(query, "oWinCol1") {
		input := graph.OWinCol1Input{}
		if vars, ok := variables["input"].(map[string]interface{}); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		res, err := h.resolver.OWinCol1(ctx, input)
		if err != nil {
			errors = append(errors, map[string]interface{}{"message": err.Error()})
		} else {
			data["oWinCol1"] = res
		}
	}

	if isMutation && containsString(query, "oWinCol2") {
		input := graph.OWinCol2Input{}
		if vars, ok := variables["input"].(map[string]interface{}); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		res, err := h.resolver.OWinCol2(ctx, input)
		if err != nil {
			errors = append(errors, map[string]interface{}{"message": err.Error()})
		} else {
			data["oWinCol2"] = res
		}
	}

	if isMutation && containsString(query, "oWinDiag") {
		input := graph.OWinDiagInput{}
		if vars, ok := variables["input"].(map[string]interface{}); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		res, err := h.resolver.OWinDiag(ctx, input)
		if err != nil {
			errors = append(errors, map[string]interface{}{"message": err.Error()})
		} else {
			data["oWinDiag"] = res
		}
	}

	if isMutation && containsString(query, "oWinAnti") {
		input := graph.OWinAntiInput{}
		if vars, ok := variables["input"].(map[string]interface{}); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		res, err := h.resolver.OWinAnti(ctx, input)
		if err != nil {
			errors = append(errors, map[string]interface{}{"message": err.Error()})
		} else {
			data["oWinAnti"] = res
		}
	}


	// Handle query for single aggregate
	if !isMutation && containsString(query, "tictactoe(") {
		id := ""
		if idVar, ok := variables["id"].(string); ok {
			id = idVar
		}
		if id != "" {
			state, err := h.resolver.TicTacToe(ctx, id)
			if err != nil {
				errors = append(errors, map[string]interface{}{"message": err.Error()})
			} else {
				data["tictactoe"] = state
			}
		}
	}

	// Handle list query
	if !isMutation && containsString(query, "tictactoeList") {
		var place *string
		var page, perPage *int
		if p, ok := variables["place"].(string); ok {
			place = &p
		}
		if p, ok := variables["page"].(float64); ok {
			pi := int(p)
			page = &pi
		}
		if p, ok := variables["perPage"].(float64); ok {
			pi := int(p)
			perPage = &pi
		}
		list, err := h.resolver.TicTacToeList(ctx, place, page, perPage)
		if err != nil {
			errors = append(errors, map[string]interface{}{"message": err.Error()})
		} else {
			data["tictactoeList"] = list
		}
	}

	// Handle admin stats query
	if !isMutation && containsString(query, "adminStats") {
		stats, err := h.resolver.AdminStats(ctx)
		if err != nil {
			errors = append(errors, map[string]interface{}{"message": err.Error()})
		} else {
			data["adminStats"] = stats
		}
	}


	// Handle events query
	if !isMutation && containsString(query, "events(") {
		aggID := ""
		var from *int
		if id, ok := variables["aggregateId"].(string); ok {
			aggID = id
		}
		if f, ok := variables["from"].(float64); ok {
			fi := int(f)
			from = &fi
		}
		if aggID != "" {
			events, err := h.resolver.Events(ctx, aggID, from)
			if err != nil {
				errors = append(errors, map[string]interface{}{"message": err.Error()})
			} else {
				data["events"] = events
			}
		}
	}


	result["data"] = data
	if len(errors) > 0 {
		result["errors"] = errors
	}

	return result
}

func containsString(s, substr string) bool {
	return len(s) >= len(substr) && (s == substr || len(s) > 0 && containsStringHelper(s, substr))
}

func containsStringHelper(s, substr string) bool {
	for i := 0; i <= len(s)-len(substr); i++ {
		if s[i:i+len(substr)] == substr {
			return true
		}
	}
	return false
}

// GraphQLSchemaString is the GraphQL schema for this service.
// Used by the unified GraphQL endpoint to combine schemas.
var GraphQLSchemaString = `# GraphQL schema for tic-tac-toe

scalar Time

type Query {
  # Get aggregate state by ID
  tictactoe(id: ID!): AggregateState

  # List aggregates with optional filtering
  tictactoeList(place: String, page: Int, perPage: Int): AggregateList!

  # Admin statistics
  adminStats: AdminStats!

  # Event history for an aggregate
  events(aggregateId: ID!, from: Int): [Event!]!

  # Get state at specific version
  stateAtVersion(aggregateId: ID!, version: Int!): AggregateState
}

type Mutation {
  # Create a new tic-tac-toe instance
  createTicTacToe: AggregateState!

  # X plays at (0,0)
  xPlay00(input: XPlay00Input!): TransitionResult!

  # X plays at (0,1)
  xPlay01(input: XPlay01Input!): TransitionResult!

  # X plays at (0,2)
  xPlay02(input: XPlay02Input!): TransitionResult!

  # X plays at (1,0)
  xPlay10(input: XPlay10Input!): TransitionResult!

  # X plays at (1,1) - center
  xPlay11(input: XPlay11Input!): TransitionResult!

  # X plays at (1,2)
  xPlay12(input: XPlay12Input!): TransitionResult!

  # X plays at (2,0)
  xPlay20(input: XPlay20Input!): TransitionResult!

  # X plays at (2,1)
  xPlay21(input: XPlay21Input!): TransitionResult!

  # X plays at (2,2)
  xPlay22(input: XPlay22Input!): TransitionResult!

  # O plays at (0,0)
  oPlay00(input: OPlay00Input!): TransitionResult!

  # O plays at (0,1)
  oPlay01(input: OPlay01Input!): TransitionResult!

  # O plays at (0,2)
  oPlay02(input: OPlay02Input!): TransitionResult!

  # O plays at (1,0)
  oPlay10(input: OPlay10Input!): TransitionResult!

  # O plays at (1,1) - center
  oPlay11(input: OPlay11Input!): TransitionResult!

  # O plays at (1,2)
  oPlay12(input: OPlay12Input!): TransitionResult!

  # O plays at (2,0)
  oPlay20(input: OPlay20Input!): TransitionResult!

  # O plays at (2,1)
  oPlay21(input: OPlay21Input!): TransitionResult!

  # O plays at (2,2)
  oPlay22(input: OPlay22Input!): TransitionResult!

  # Reset game to initial state
  reset(input: ResetInput!): TransitionResult!

  # X wins top row (0,0)-(0,1)-(0,2)
  xWinRow0(input: XWinRow0Input!): TransitionResult!

  # X wins middle row (1,0)-(1,1)-(1,2)
  xWinRow1(input: XWinRow1Input!): TransitionResult!

  # X wins bottom row (2,0)-(2,1)-(2,2)
  xWinRow2(input: XWinRow2Input!): TransitionResult!

  # X wins left column (0,0)-(1,0)-(2,0)
  xWinCol0(input: XWinCol0Input!): TransitionResult!

  # X wins center column (0,1)-(1,1)-(2,1)
  xWinCol1(input: XWinCol1Input!): TransitionResult!

  # X wins right column (0,2)-(1,2)-(2,2)
  xWinCol2(input: XWinCol2Input!): TransitionResult!

  # X wins main diagonal (0,0)-(1,1)-(2,2)
  xWinDiag(input: XWinDiagInput!): TransitionResult!

  # X wins anti-diagonal (0,2)-(1,1)-(2,0)
  xWinAnti(input: XWinAntiInput!): TransitionResult!

  # O wins top row (0,0)-(0,1)-(0,2)
  oWinRow0(input: OWinRow0Input!): TransitionResult!

  # O wins middle row (1,0)-(1,1)-(1,2)
  oWinRow1(input: OWinRow1Input!): TransitionResult!

  # O wins bottom row (2,0)-(2,1)-(2,2)
  oWinRow2(input: OWinRow2Input!): TransitionResult!

  # O wins left column (0,0)-(1,0)-(2,0)
  oWinCol0(input: OWinCol0Input!): TransitionResult!

  # O wins center column (0,1)-(1,1)-(2,1)
  oWinCol1(input: OWinCol1Input!): TransitionResult!

  # O wins right column (0,2)-(1,2)-(2,2)
  oWinCol2(input: OWinCol2Input!): TransitionResult!

  # O wins main diagonal (0,0)-(1,1)-(2,2)
  oWinDiag(input: OWinDiagInput!): TransitionResult!

  # O wins anti-diagonal (0,2)-(1,1)-(2,0)
  oWinAnti(input: OWinAntiInput!): TransitionResult!
}

# Aggregate state representation
type AggregateState {
  id: ID!
  version: Int!
  state: State!
  places: Places!
  enabledTransitions: [String!]!
}

# Workflow state with all places
type State {
  p00: Int!
  p01: Int!
  p02: Int!
  p10: Int!
  p11: Int!
  p12: Int!
  p20: Int!
  p21: Int!
  p22: Int!
  x00: Int!
  x01: Int!
  x02: Int!
  x10: Int!
  x11: Int!
  x12: Int!
  x20: Int!
  x21: Int!
  x22: Int!
  o00: Int!
  o01: Int!
  o02: Int!
  o10: Int!
  o11: Int!
  o12: Int!
  o20: Int!
  o21: Int!
  o22: Int!
  xTurn: Int!
  oTurn: Int!
  winX: Int!
  winO: Int!
  canReset: Int!
  gameActive: Int!
}

# Token counts for each place
type Places {
  p00: Int!
  p01: Int!
  p02: Int!
  p10: Int!
  p11: Int!
  p12: Int!
  p20: Int!
  p21: Int!
  p22: Int!
  x00: Int!
  x01: Int!
  x02: Int!
  x10: Int!
  x11: Int!
  x12: Int!
  x20: Int!
  x21: Int!
  x22: Int!
  o00: Int!
  o01: Int!
  o02: Int!
  o10: Int!
  o11: Int!
  o12: Int!
  o20: Int!
  o21: Int!
  o22: Int!
  xTurn: Int!
  oTurn: Int!
  winX: Int!
  winO: Int!
  canReset: Int!
  gameActive: Int!
}

# Result of a transition execution
type TransitionResult {
  success: Boolean!
  aggregateId: ID
  version: Int
  state: Places
  enabledTransitions: [String!]
  error: String
}

# Paginated list of aggregates
type AggregateList {
  items: [AggregateState!]!
  total: Int!
  page: Int!
  perPage: Int!
}

# Admin statistics
type AdminStats {
  totalInstances: Int!
  byPlace: [PlaceCount!]!
}

type PlaceCount {
  place: String!
  count: Int!
}


# Event record
type Event {
  id: ID!
  streamId: String!
  type: String!
  version: Int!
  timestamp: Time!
  data: String!
}


# Input types for mutations

input XPlay00Input {
  aggregateId: ID!
}


input XPlay01Input {
  aggregateId: ID!
}


input XPlay02Input {
  aggregateId: ID!
}


input XPlay10Input {
  aggregateId: ID!
}


input XPlay11Input {
  aggregateId: ID!
}


input XPlay12Input {
  aggregateId: ID!
}


input XPlay20Input {
  aggregateId: ID!
}


input XPlay21Input {
  aggregateId: ID!
}


input XPlay22Input {
  aggregateId: ID!
}


input OPlay00Input {
  aggregateId: ID!
}


input OPlay01Input {
  aggregateId: ID!
}


input OPlay02Input {
  aggregateId: ID!
}


input OPlay10Input {
  aggregateId: ID!
}


input OPlay11Input {
  aggregateId: ID!
}


input OPlay12Input {
  aggregateId: ID!
}


input OPlay20Input {
  aggregateId: ID!
}


input OPlay21Input {
  aggregateId: ID!
}


input OPlay22Input {
  aggregateId: ID!
}


input ResetInput {
  aggregateId: ID!
}


input XWinRow0Input {
  aggregateId: ID!
}


input XWinRow1Input {
  aggregateId: ID!
}


input XWinRow2Input {
  aggregateId: ID!
}


input XWinCol0Input {
  aggregateId: ID!
}


input XWinCol1Input {
  aggregateId: ID!
}


input XWinCol2Input {
  aggregateId: ID!
}


input XWinDiagInput {
  aggregateId: ID!
}


input XWinAntiInput {
  aggregateId: ID!
}


input OWinRow0Input {
  aggregateId: ID!
}


input OWinRow1Input {
  aggregateId: ID!
}


input OWinRow2Input {
  aggregateId: ID!
}


input OWinCol0Input {
  aggregateId: ID!
}


input OWinCol1Input {
  aggregateId: ID!
}


input OWinCol2Input {
  aggregateId: ID!
}


input OWinDiagInput {
  aggregateId: ID!
}


input OWinAntiInput {
  aggregateId: ID!
}

`

// GraphQLResolversMap returns a map of resolver functions for the unified GraphQL endpoint.
func GraphQLResolversMap(app *Application) map[string]serve.GraphQLResolver {
	gqlApp := &graphQLApp{app: app}
	resolver := graph.NewResolver(gqlApp)

	resolvers := make(map[string]serve.GraphQLResolver)

	// Query resolvers
	resolvers["tictactoe"] = func(ctx context.Context, variables map[string]any) (any, error) {
		id, _ := variables["id"].(string)
		return resolver.TicTacToe(ctx, id)
	}

	resolvers["tictactoeList"] = func(ctx context.Context, variables map[string]any) (any, error) {
		var place *string
		var page, perPage *int
		if p, ok := variables["place"].(string); ok {
			place = &p
		}
		if p, ok := variables["page"].(float64); ok {
			pi := int(p)
			page = &pi
		}
		if p, ok := variables["perPage"].(float64); ok {
			pi := int(p)
			perPage = &pi
		}
		return resolver.TicTacToeList(ctx, place, page, perPage)
	}

	// Mutation resolvers
	resolvers["tictactoe_create"] = func(ctx context.Context, _ map[string]any) (any, error) {
		return resolver.CreateTicTacToe(ctx)
	}


	resolvers["tictactoe_x_play_00"] = func(ctx context.Context, variables map[string]any) (any, error) {
		input := graph.XPlay00Input{}
		if vars, ok := variables["input"].(map[string]any); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		return resolver.XPlay00(ctx, input)
	}


	resolvers["tictactoe_x_play_01"] = func(ctx context.Context, variables map[string]any) (any, error) {
		input := graph.XPlay01Input{}
		if vars, ok := variables["input"].(map[string]any); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		return resolver.XPlay01(ctx, input)
	}


	resolvers["tictactoe_x_play_02"] = func(ctx context.Context, variables map[string]any) (any, error) {
		input := graph.XPlay02Input{}
		if vars, ok := variables["input"].(map[string]any); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		return resolver.XPlay02(ctx, input)
	}


	resolvers["tictactoe_x_play_10"] = func(ctx context.Context, variables map[string]any) (any, error) {
		input := graph.XPlay10Input{}
		if vars, ok := variables["input"].(map[string]any); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		return resolver.XPlay10(ctx, input)
	}


	resolvers["tictactoe_x_play_11"] = func(ctx context.Context, variables map[string]any) (any, error) {
		input := graph.XPlay11Input{}
		if vars, ok := variables["input"].(map[string]any); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		return resolver.XPlay11(ctx, input)
	}


	resolvers["tictactoe_x_play_12"] = func(ctx context.Context, variables map[string]any) (any, error) {
		input := graph.XPlay12Input{}
		if vars, ok := variables["input"].(map[string]any); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		return resolver.XPlay12(ctx, input)
	}


	resolvers["tictactoe_x_play_20"] = func(ctx context.Context, variables map[string]any) (any, error) {
		input := graph.XPlay20Input{}
		if vars, ok := variables["input"].(map[string]any); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		return resolver.XPlay20(ctx, input)
	}


	resolvers["tictactoe_x_play_21"] = func(ctx context.Context, variables map[string]any) (any, error) {
		input := graph.XPlay21Input{}
		if vars, ok := variables["input"].(map[string]any); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		return resolver.XPlay21(ctx, input)
	}


	resolvers["tictactoe_x_play_22"] = func(ctx context.Context, variables map[string]any) (any, error) {
		input := graph.XPlay22Input{}
		if vars, ok := variables["input"].(map[string]any); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		return resolver.XPlay22(ctx, input)
	}


	resolvers["tictactoe_o_play_00"] = func(ctx context.Context, variables map[string]any) (any, error) {
		input := graph.OPlay00Input{}
		if vars, ok := variables["input"].(map[string]any); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		return resolver.OPlay00(ctx, input)
	}


	resolvers["tictactoe_o_play_01"] = func(ctx context.Context, variables map[string]any) (any, error) {
		input := graph.OPlay01Input{}
		if vars, ok := variables["input"].(map[string]any); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		return resolver.OPlay01(ctx, input)
	}


	resolvers["tictactoe_o_play_02"] = func(ctx context.Context, variables map[string]any) (any, error) {
		input := graph.OPlay02Input{}
		if vars, ok := variables["input"].(map[string]any); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		return resolver.OPlay02(ctx, input)
	}


	resolvers["tictactoe_o_play_10"] = func(ctx context.Context, variables map[string]any) (any, error) {
		input := graph.OPlay10Input{}
		if vars, ok := variables["input"].(map[string]any); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		return resolver.OPlay10(ctx, input)
	}


	resolvers["tictactoe_o_play_11"] = func(ctx context.Context, variables map[string]any) (any, error) {
		input := graph.OPlay11Input{}
		if vars, ok := variables["input"].(map[string]any); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		return resolver.OPlay11(ctx, input)
	}


	resolvers["tictactoe_o_play_12"] = func(ctx context.Context, variables map[string]any) (any, error) {
		input := graph.OPlay12Input{}
		if vars, ok := variables["input"].(map[string]any); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		return resolver.OPlay12(ctx, input)
	}


	resolvers["tictactoe_o_play_20"] = func(ctx context.Context, variables map[string]any) (any, error) {
		input := graph.OPlay20Input{}
		if vars, ok := variables["input"].(map[string]any); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		return resolver.OPlay20(ctx, input)
	}


	resolvers["tictactoe_o_play_21"] = func(ctx context.Context, variables map[string]any) (any, error) {
		input := graph.OPlay21Input{}
		if vars, ok := variables["input"].(map[string]any); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		return resolver.OPlay21(ctx, input)
	}


	resolvers["tictactoe_o_play_22"] = func(ctx context.Context, variables map[string]any) (any, error) {
		input := graph.OPlay22Input{}
		if vars, ok := variables["input"].(map[string]any); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		return resolver.OPlay22(ctx, input)
	}


	resolvers["tictactoe_reset"] = func(ctx context.Context, variables map[string]any) (any, error) {
		input := graph.ResetInput{}
		if vars, ok := variables["input"].(map[string]any); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		return resolver.Reset(ctx, input)
	}


	resolvers["tictactoe_x_win_row0"] = func(ctx context.Context, variables map[string]any) (any, error) {
		input := graph.XWinRow0Input{}
		if vars, ok := variables["input"].(map[string]any); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		return resolver.XWinRow0(ctx, input)
	}


	resolvers["tictactoe_x_win_row1"] = func(ctx context.Context, variables map[string]any) (any, error) {
		input := graph.XWinRow1Input{}
		if vars, ok := variables["input"].(map[string]any); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		return resolver.XWinRow1(ctx, input)
	}


	resolvers["tictactoe_x_win_row2"] = func(ctx context.Context, variables map[string]any) (any, error) {
		input := graph.XWinRow2Input{}
		if vars, ok := variables["input"].(map[string]any); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		return resolver.XWinRow2(ctx, input)
	}


	resolvers["tictactoe_x_win_col0"] = func(ctx context.Context, variables map[string]any) (any, error) {
		input := graph.XWinCol0Input{}
		if vars, ok := variables["input"].(map[string]any); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		return resolver.XWinCol0(ctx, input)
	}


	resolvers["tictactoe_x_win_col1"] = func(ctx context.Context, variables map[string]any) (any, error) {
		input := graph.XWinCol1Input{}
		if vars, ok := variables["input"].(map[string]any); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		return resolver.XWinCol1(ctx, input)
	}


	resolvers["tictactoe_x_win_col2"] = func(ctx context.Context, variables map[string]any) (any, error) {
		input := graph.XWinCol2Input{}
		if vars, ok := variables["input"].(map[string]any); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		return resolver.XWinCol2(ctx, input)
	}


	resolvers["tictactoe_x_win_diag"] = func(ctx context.Context, variables map[string]any) (any, error) {
		input := graph.XWinDiagInput{}
		if vars, ok := variables["input"].(map[string]any); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		return resolver.XWinDiag(ctx, input)
	}


	resolvers["tictactoe_x_win_anti"] = func(ctx context.Context, variables map[string]any) (any, error) {
		input := graph.XWinAntiInput{}
		if vars, ok := variables["input"].(map[string]any); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		return resolver.XWinAnti(ctx, input)
	}


	resolvers["tictactoe_o_win_row0"] = func(ctx context.Context, variables map[string]any) (any, error) {
		input := graph.OWinRow0Input{}
		if vars, ok := variables["input"].(map[string]any); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		return resolver.OWinRow0(ctx, input)
	}


	resolvers["tictactoe_o_win_row1"] = func(ctx context.Context, variables map[string]any) (any, error) {
		input := graph.OWinRow1Input{}
		if vars, ok := variables["input"].(map[string]any); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		return resolver.OWinRow1(ctx, input)
	}


	resolvers["tictactoe_o_win_row2"] = func(ctx context.Context, variables map[string]any) (any, error) {
		input := graph.OWinRow2Input{}
		if vars, ok := variables["input"].(map[string]any); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		return resolver.OWinRow2(ctx, input)
	}


	resolvers["tictactoe_o_win_col0"] = func(ctx context.Context, variables map[string]any) (any, error) {
		input := graph.OWinCol0Input{}
		if vars, ok := variables["input"].(map[string]any); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		return resolver.OWinCol0(ctx, input)
	}


	resolvers["tictactoe_o_win_col1"] = func(ctx context.Context, variables map[string]any) (any, error) {
		input := graph.OWinCol1Input{}
		if vars, ok := variables["input"].(map[string]any); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		return resolver.OWinCol1(ctx, input)
	}


	resolvers["tictactoe_o_win_col2"] = func(ctx context.Context, variables map[string]any) (any, error) {
		input := graph.OWinCol2Input{}
		if vars, ok := variables["input"].(map[string]any); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		return resolver.OWinCol2(ctx, input)
	}


	resolvers["tictactoe_o_win_diag"] = func(ctx context.Context, variables map[string]any) (any, error) {
		input := graph.OWinDiagInput{}
		if vars, ok := variables["input"].(map[string]any); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		return resolver.OWinDiag(ctx, input)
	}


	resolvers["tictactoe_o_win_anti"] = func(ctx context.Context, variables map[string]any) (any, error) {
		input := graph.OWinAntiInput{}
		if vars, ok := variables["input"].(map[string]any); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		return resolver.OWinAnti(ctx, input)
	}



	resolvers["adminStats"] = func(ctx context.Context, _ map[string]any) (any, error) {
		return resolver.AdminStats(ctx)
	}


	resolvers["events"] = func(ctx context.Context, variables map[string]any) (any, error) {
		aggID, _ := variables["aggregateId"].(string)
		var from *int
		if f, ok := variables["from"].(float64); ok {
			fi := int(f)
			from = &fi
		}
		return resolver.Events(ctx, aggID, from)
	}


	return resolvers
}
