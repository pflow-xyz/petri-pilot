// Code generated by petri-pilot. DO NOT EDIT.

package tictactoe

import (
	"context"
	"fmt"

	"github.com/google/uuid"
	"github.com/pflow-xyz/petri-pilot/pkg/runtime"
	"github.com/pflow-xyz/petri-pilot/pkg/runtime/aggregate"
	"github.com/pflow-xyz/petri-pilot/pkg/runtime/eventstore"
)

// State holds the aggregate state for tic-tac-toe.
type State struct {
	Board    [3][3]string `json:"board"`     // "X", "O", or ""
	Winner   string       `json:"winner"`    // "X", "O", "draw", or ""
	GameOver bool         `json:"game_over"`
}

// NewState creates a new State with initialized board.
func NewState() State {
	return State{
		Board: [3][3]string{},
	}
}

// Aggregate wraps a StateMachine with the tic-tac-toe state.
type Aggregate struct {
	sm *aggregate.StateMachine[State]
}

// NewAggregate creates a new aggregate with initial state.
func NewAggregate(id string) *Aggregate {
	if id == "" {
		id = uuid.New().String()
	}

	// Simplified initial places - just track empty cells and turns
	initialPlaces := map[string]int{
		PlaceP00: 1, PlaceP01: 1, PlaceP02: 1,
		PlaceP10: 1, PlaceP11: 1, PlaceP12: 1,
		PlaceP20: 1, PlaceP21: 1, PlaceP22: 1,
		PlaceXTurn: 1,
		PlaceOTurn: 0,
	}

	sm := aggregate.NewStateMachine(id, NewState(), initialPlaces)

	// Guard function to check if game is still active
	gameActiveGuard := func(state any) bool {
		s := state.(State)
		return !s.GameOver
	}

	// Register X move transitions
	for row := 0; row < 3; row++ {
		for col := 0; col < 3; col++ {
			transID := fmt.Sprintf("x_play_%d%d", row, col)
			eventType := fmt.Sprintf("XPlayed%d%d", row, col)
			emptyPlace := fmt.Sprintf("p%d%d", row, col)
			xPlace := fmt.Sprintf("x%d%d", row, col)

			sm.AddTransition(aggregate.Transition{
				ID:        transID,
				EventType: eventType,
				Inputs: map[string]int{
					emptyPlace: 1,
					PlaceXTurn: 1,
				},
				Outputs: map[string]int{
					xPlace:     1,
					PlaceOTurn: 1,
				},
				Guard: gameActiveGuard,
			})
		}
	}

	// Register O move transitions
	for row := 0; row < 3; row++ {
		for col := 0; col < 3; col++ {
			transID := fmt.Sprintf("o_play_%d%d", row, col)
			eventType := fmt.Sprintf("OPlayed%d%d", row, col)
			emptyPlace := fmt.Sprintf("p%d%d", row, col)
			oPlace := fmt.Sprintf("o%d%d", row, col)

			sm.AddTransition(aggregate.Transition{
				ID:        transID,
				EventType: eventType,
				Inputs: map[string]int{
					emptyPlace: 1,
					PlaceOTurn: 1,
				},
				Outputs: map[string]int{
					oPlace:     1,
					PlaceXTurn: 1,
				},
				Guard: gameActiveGuard,
			})
		}
	}

	// Reset transition - requires game to be over (checked via guard)
	sm.AddTransition(aggregate.Transition{
		ID:        TransitionReset,
		EventType: EventTypeReset,
		Inputs:    map[string]int{},
		Outputs:   map[string]int{},
		Guard: func(state any) bool {
			s := state.(State)
			return s.GameOver
		},
	})

	// Register event handlers for state updates
	for row := 0; row < 3; row++ {
		for col := 0; col < 3; col++ {
			r, c := row, col // capture for closure
			eventTypeX := fmt.Sprintf("XPlayed%d%d", row, col)
			eventTypeO := fmt.Sprintf("OPlayed%d%d", row, col)

			sm.RegisterHandler(eventTypeX, func(state *State, event *runtime.Event) error {
				state.Board[r][c] = "X"
				checkWinCondition(state)
				return nil
			})
			sm.RegisterHandler(eventTypeO, func(state *State, event *runtime.Event) error {
				state.Board[r][c] = "O"
				checkWinCondition(state)
				return nil
			})
		}
	}

	sm.RegisterHandler(EventTypeReset, func(state *State, event *runtime.Event) error {
		*state = NewState()
		return nil
	})

	return &Aggregate{sm: sm}
}

// checkWinCondition checks if the game is over and updates state accordingly.
func checkWinCondition(state *State) {
	// Check rows
	for row := 0; row < 3; row++ {
		if state.Board[row][0] != "" &&
			state.Board[row][0] == state.Board[row][1] &&
			state.Board[row][1] == state.Board[row][2] {
			state.Winner = state.Board[row][0]
			state.GameOver = true
			return
		}
	}

	// Check columns
	for col := 0; col < 3; col++ {
		if state.Board[0][col] != "" &&
			state.Board[0][col] == state.Board[1][col] &&
			state.Board[1][col] == state.Board[2][col] {
			state.Winner = state.Board[0][col]
			state.GameOver = true
			return
		}
	}

	// Check diagonals
	if state.Board[0][0] != "" &&
		state.Board[0][0] == state.Board[1][1] &&
		state.Board[1][1] == state.Board[2][2] {
		state.Winner = state.Board[0][0]
		state.GameOver = true
		return
	}
	if state.Board[0][2] != "" &&
		state.Board[0][2] == state.Board[1][1] &&
		state.Board[1][1] == state.Board[2][0] {
		state.Winner = state.Board[0][2]
		state.GameOver = true
		return
	}

	// Check for draw (all cells filled, no winner)
	emptyCells := 0
	for row := 0; row < 3; row++ {
		for col := 0; col < 3; col++ {
			if state.Board[row][col] == "" {
				emptyCells++
			}
		}
	}
	if emptyCells == 0 {
		state.Winner = "draw"
		state.GameOver = true
	}
}

// ID returns the aggregate identifier.
func (a *Aggregate) ID() string {
	return a.sm.ID()
}

// Version returns the current event version.
func (a *Aggregate) Version() int {
	return a.sm.Version()
}

// State returns the current state.
func (a *Aggregate) State() any {
	return a.sm.State()
}

// Places returns current token distribution.
func (a *Aggregate) Places() map[string]int {
	return a.sm.Places()
}

// EnabledTransitions returns transitions that can fire.
func (a *Aggregate) EnabledTransitions() []string {
	return a.sm.EnabledTransitions()
}

// CanFire checks if a transition can fire.
func (a *Aggregate) CanFire(transitionID string) bool {
	return a.sm.CanFire(transitionID)
}

// Fire executes a transition and returns the resulting event.
func (a *Aggregate) Fire(transitionID string, data any) (*runtime.Event, error) {
	return a.sm.Fire(transitionID, data)
}

// Apply applies an event to update the aggregate state.
func (a *Aggregate) Apply(event *runtime.Event) error {
	return a.sm.Apply(event)
}

// Application wires together the aggregate and event store.
type Application struct {
	store eventstore.Store
}

// NewApplication creates a new application instance.
func NewApplication(store eventstore.Store) *Application {
	return &Application{store: store}
}

// Create creates a new aggregate and returns its ID.
func (app *Application) Create(ctx context.Context) (string, error) {
	agg := NewAggregate("")
	return agg.ID(), nil
}

// Load loads an aggregate from the event store.
func (app *Application) Load(ctx context.Context, id string) (*Aggregate, error) {
	events, err := app.store.Read(ctx, id, 0)
	if err != nil {
		return nil, fmt.Errorf("reading events: %w", err)
	}

	agg := NewAggregate(id)
	for _, event := range events {
		if err := agg.Apply(event); err != nil {
			return nil, fmt.Errorf("applying event %s: %w", event.ID, err)
		}
	}

	return agg, nil
}

// Execute fires a transition on an aggregate and persists the event.
func (app *Application) Execute(ctx context.Context, id, transitionID string, data any) (*Aggregate, error) {
	agg, err := app.Load(ctx, id)
	if err != nil {
		return nil, err
	}

	if !agg.CanFire(transitionID) {
		return nil, fmt.Errorf("transition %s cannot fire from current state", transitionID)
	}

	event, err := agg.Fire(transitionID, data)
	if err != nil {
		return nil, fmt.Errorf("firing transition: %w", err)
	}

	_, err = app.store.Append(ctx, id, agg.Version(), []*runtime.Event{event})
	if err != nil {
		return nil, fmt.Errorf("persisting event: %w", err)
	}

	if err := agg.Apply(event); err != nil {
		return nil, fmt.Errorf("applying event: %w", err)
	}

	return agg, nil
}

// GetState returns the current state of an aggregate.
func (app *Application) GetState(ctx context.Context, id string) (*Aggregate, error) {
	return app.Load(ctx, id)
}

// HealthCheck verifies the event store is accessible.
func (app *Application) HealthCheck(ctx context.Context) error {
	_, err := app.store.Read(ctx, "__health_check__", 0)
	if err != nil && err.Error() != "stream not found" {
		return err
	}
	return nil
}
