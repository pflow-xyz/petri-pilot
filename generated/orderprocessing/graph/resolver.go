// Code generated by petri-pilot. DO NOT EDIT.

package graph

import (
	"context"
	"encoding/json"
	"fmt"

	"github.com/pflow-xyz/go-pflow/eventsource"
)

// Resolver is the root resolver for GraphQL queries and mutations.
type Resolver struct {
	App interface {
		Create(ctx context.Context) (string, error)
		Load(ctx context.Context, id string) (Aggregate, error)
		GetState(ctx context.Context, id string) (Aggregate, error)
		Execute(ctx context.Context, id, transition string, data map[string]any) (Aggregate, error)
		HealthCheck(ctx context.Context) error
		GetStore() eventsource.Store
	}
}

// Aggregate interface for type safety
type Aggregate interface {
	ID() string
	Version() int
	State() any
	Places() map[string]int
	EnabledTransitions() []string
}

// NewResolver creates a new GraphQL resolver.
func NewResolver(app interface {
	Create(ctx context.Context) (string, error)
	Load(ctx context.Context, id string) (Aggregate, error)
	GetState(ctx context.Context, id string) (Aggregate, error)
	Execute(ctx context.Context, id, transition string, data map[string]any) (Aggregate, error)
	HealthCheck(ctx context.Context) error
	GetStore() eventsource.Store
}) *Resolver {
	return &Resolver{App: app}
}

// Query resolvers

// OrderProcessing returns the aggregate state by ID.
func (r *Resolver) OrderProcessing(ctx context.Context, id string) (*AggregateState, error) {
	agg, err := r.App.GetState(ctx, id)
	if err != nil {
		return nil, err
	}
	return aggregateToState(agg), nil
}

// OrderProcessingList returns a paginated list of aggregates.
func (r *Resolver) OrderProcessingList(ctx context.Context, place *string, page *int, perPage *int) (*AggregateList, error) {
	// Default pagination
	p := 1
	pp := 50
	if page != nil {
		p = *page
	}
	if perPage != nil {
		pp = *perPage
	}

	placeFilter := ""
	if place != nil {
		placeFilter = *place
	}
	store := r.App.GetStore()
	adminStore, ok := store.(interface {
		ListInstances(ctx context.Context, place, from, to string, page, perPage int) ([]eventsource.Instance, int, error)
	})
	if !ok {
		return &AggregateList{
			Items:   []*AggregateState{},
			Total:   0,
			Page:    p,
			PerPage: pp,
		}, nil
	}

	instances, total, err := adminStore.ListInstances(ctx, placeFilter, "", "", p, pp)
	if err != nil {
		return nil, err
	}

	items := make([]*AggregateState, 0, len(instances))
	for _, inst := range instances {
		agg, err := r.App.Load(ctx, inst.ID)
		if err != nil {
			continue
		}
		items = append(items, aggregateToState(agg))
	}

	return &AggregateList{
		Items:   items,
		Total:   total,
		Page:    p,
		PerPage: pp,
	}, nil
}

// AdminStats returns admin statistics.
func (r *Resolver) AdminStats(ctx context.Context) (*AdminStats, error) {
	store := r.App.GetStore()
	adminStore, ok := store.(interface {
		GetStats(ctx context.Context) (*eventsource.Stats, error)
	})
	if !ok {
		return nil, fmt.Errorf("admin operations not supported")
	}

	stats, err := adminStore.GetStats(ctx)
	if err != nil {
		return nil, err
	}

	byPlace := make([]*PlaceCount, 0, len(stats.ByPlace))
	for place, count := range stats.ByPlace {
		byPlace = append(byPlace, &PlaceCount{
			Place: place,
			Count: count,
		})
	}

	return &AdminStats{
		TotalInstances: stats.TotalInstances,
		ByPlace:        byPlace,
	}, nil
}


// Events returns the event history for an aggregate.
func (r *Resolver) Events(ctx context.Context, aggregateID string, from *int) ([]*Event, error) {
	store := r.App.GetStore()
	fromVersion := 0
	if from != nil {
		fromVersion = *from
	}

	events, err := store.Read(ctx, aggregateID, fromVersion)
	if err != nil {
		return nil, err
	}

	result := make([]*Event, len(events))
	for i, evt := range events {
		data, _ := json.Marshal(evt.Data)
		result[i] = &Event{
			ID:        fmt.Sprintf("%s-%d", evt.StreamID, evt.Version),
			StreamID:  evt.StreamID,
			Type:      evt.Type,
			Version:   evt.Version,
			Timestamp: evt.Timestamp,
			Data:      string(data),
		}
	}

	return result, nil
}

// StateAtVersion returns the aggregate state at a specific version.
func (r *Resolver) StateAtVersion(ctx context.Context, aggregateID string, version int) (*AggregateState, error) {
	// This is a simplified implementation - would need aggregate rebuild logic
	agg, err := r.App.GetState(ctx, aggregateID)
	if err != nil {
		return nil, err
	}

	// TODO: Implement proper version replay
	state := aggregateToState(agg)
	state.Version = version
	return state, nil
}


// Mutation resolvers

// CreateOrderProcessing creates a new aggregate instance.
func (r *Resolver) CreateOrderProcessing(ctx context.Context) (*AggregateState, error) {
	id, err := r.App.Create(ctx)
	if err != nil {
		return nil, err
	}

	agg, err := r.App.Load(ctx, id)
	if err != nil {
		return nil, err
	}

	return aggregateToState(agg), nil
}


// Validate executes the validate transition.
func (r *Resolver) Validate(ctx context.Context, input ValidateInput) (*TransitionResult, error) {
	data := make(map[string]any)
	if input.OrderId != nil {
		data["order_id"] = *input.OrderId
	}
	if input.CustomerName != nil {
		data["customer_name"] = *input.CustomerName
	}
	if input.CustomerEmail != nil {
		data["customer_email"] = *input.CustomerEmail
	}
	if input.ShippingAddress != nil {
		data["shipping_address"] = *input.ShippingAddress
	}
	if input.Total != nil {
		data["total"] = *input.Total
	}

	agg, err := r.App.Execute(ctx, input.AggregateID, "validate", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// Reject executes the reject transition.
func (r *Resolver) Reject(ctx context.Context, input RejectInput) (*TransitionResult, error) {
	data := make(map[string]any)
	if input.OrderId != nil {
		data["order_id"] = *input.OrderId
	}
	if input.RejectionReason != nil {
		data["rejection_reason"] = *input.RejectionReason
	}

	agg, err := r.App.Execute(ctx, input.AggregateID, "reject", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// ProcessPayment executes the process_payment transition.
func (r *Resolver) ProcessPayment(ctx context.Context, input ProcessPaymentInput) (*TransitionResult, error) {
	data := make(map[string]any)
	if input.OrderId != nil {
		data["order_id"] = *input.OrderId
	}
	if input.Total != nil {
		data["total"] = *input.Total
	}
	if input.PaymentMethod != nil {
		data["payment_method"] = *input.PaymentMethod
	}

	agg, err := r.App.Execute(ctx, input.AggregateID, "process_payment", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// Ship executes the ship transition.
func (r *Resolver) Ship(ctx context.Context, input ShipInput) (*TransitionResult, error) {
	data := make(map[string]any)
	if input.OrderId != nil {
		data["order_id"] = *input.OrderId
	}
	if input.TrackingNumber != nil {
		data["tracking_number"] = *input.TrackingNumber
	}
	if input.Carrier != nil {
		data["carrier"] = *input.Carrier
	}

	agg, err := r.App.Execute(ctx, input.AggregateID, "ship", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// Confirm executes the confirm transition.
func (r *Resolver) Confirm(ctx context.Context, input ConfirmInput) (*TransitionResult, error) {
	data := make(map[string]any)
	if input.OrderId != nil {
		data["order_id"] = *input.OrderId
	}

	agg, err := r.App.Execute(ctx, input.AggregateID, "confirm", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}



// Helper functions

func aggregateToState(agg Aggregate) *AggregateState {
	places := agg.Places()
	return &AggregateState{
		ID:                 agg.ID(),
		Version:            agg.Version(),
		State:              stateToModel(agg.State()),
		Places:             placesToModel(places),
		EnabledTransitions: agg.EnabledTransitions(),
	}
}

func stateToModel(state any) *State {
	s := &State{}
	// Convert struct to map via JSON roundtrip for uniform field access
	m := stateToMap(state)
	if v, ok := m["received"]; ok {
		s.Received = v
	}
	if v, ok := m["validated"]; ok {
		s.Validated = v
	}
	if v, ok := m["rejected"]; ok {
		s.Rejected = v
	}
	if v, ok := m["paid"]; ok {
		s.Paid = v
	}
	if v, ok := m["shipped"]; ok {
		s.Shipped = v
	}
	if v, ok := m["completed"]; ok {
		s.Completed = v
	}
	return s
}

func stateToMap(state any) map[string]any {
	// Try direct map assertion first
	if m, ok := state.(map[string]any); ok {
		return m
	}
	// Fall back to JSON roundtrip for struct types
	b, err := json.Marshal(state)
	if err != nil {
		return nil
	}
	var m map[string]any
	if err := json.Unmarshal(b, &m); err != nil {
		return nil
	}
	return m
}

func placesToModel(places map[string]int) *Places {
	p := &Places{}
	if v, ok := places["received"]; ok {
		p.Received = v
	}
	if v, ok := places["validated"]; ok {
		p.Validated = v
	}
	if v, ok := places["rejected"]; ok {
		p.Rejected = v
	}
	if v, ok := places["paid"]; ok {
		p.Paid = v
	}
	if v, ok := places["shipped"]; ok {
		p.Shipped = v
	}
	if v, ok := places["completed"]; ok {
		p.Completed = v
	}
	return p
}

// GraphQL model types

type AggregateState struct {
	ID                 string   `json:"id"`
	Version            int      `json:"version"`
	State              *State   `json:"state"`
	Places             *Places  `json:"places"`
	EnabledTransitions []string `json:"enabledTransitions"`
}

type State struct {
	Received any `json:"received"`
	Validated any `json:"validated"`
	Rejected any `json:"rejected"`
	Paid any `json:"paid"`
	Shipped any `json:"shipped"`
	Completed any `json:"completed"`
}

type Places struct {
	Received int `json:"received"`
	Validated int `json:"validated"`
	Rejected int `json:"rejected"`
	Paid int `json:"paid"`
	Shipped int `json:"shipped"`
	Completed int `json:"completed"`
}

type TransitionResult struct {
	Success            bool     `json:"success"`
	AggregateID        *string  `json:"aggregateId"`
	Version            *int     `json:"version"`
	State              *Places  `json:"state"`
	EnabledTransitions []string `json:"enabledTransitions"`
	Error              *string  `json:"error"`
}

type AggregateList struct {
	Items   []*AggregateState `json:"items"`
	Total   int               `json:"total"`
	Page    int               `json:"page"`
	PerPage int               `json:"perPage"`
}

type AdminStats struct {
	TotalInstances int           `json:"totalInstances"`
	ByPlace        []*PlaceCount `json:"byPlace"`
}

type PlaceCount struct {
	Place string `json:"place"`
	Count int    `json:"count"`
}


type Event struct {
	ID        string `json:"id"`
	StreamID  string `json:"streamId"`
	Type      string `json:"type"`
	Version   int    `json:"version"`
	Timestamp any    `json:"timestamp"`
	Data      string `json:"data"`
}


// Input types

type ValidateInput struct {
	AggregateID string
	OrderId *string
	CustomerName *string
	CustomerEmail *string
	ShippingAddress *string
	Total *float64
}


type RejectInput struct {
	AggregateID string
	OrderId *string
	RejectionReason *string
}


type ProcessPaymentInput struct {
	AggregateID string
	OrderId *string
	Total *float64
	PaymentMethod *string
}


type ShipInput struct {
	AggregateID string
	OrderId *string
	TrackingNumber *string
	Carrier *string
}


type ConfirmInput struct {
	AggregateID string
	OrderId *string
}

