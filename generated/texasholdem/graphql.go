// Code generated by petri-pilot. DO NOT EDIT.

package texasholdem

import (
	"context"
	"encoding/json"
	"net/http"

	"github.com/pflow-xyz/petri-pilot/generated/texasholdem/graph"
	"github.com/pflow-xyz/go-pflow/eventsource"
	"github.com/pflow-xyz/petri-pilot/pkg/serve"
)

// GraphQLConfig holds the GraphQL server configuration.
var GraphQLConfig = struct {
	Path       string
	Playground bool
}{
	Path:       "/graphql",
	Playground: true,
}

// GraphQLHandler creates the GraphQL HTTP handler.
func GraphQLHandler(app *Application) http.HandlerFunc {
	resolver := graph.NewResolver(&graphQLApp{app: app})
	h := &graphQLHandler{resolver: resolver}
	return h.ServeHTTP
}

// PlaygroundHandler serves the GraphQL Playground UI.
func PlaygroundHandler() http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "text/html; charset=utf-8")
		w.Write([]byte(playgroundHTML))
	}
}

var playgroundHTML = "<!DOCTYPE html>\n" +
	"<html>\n" +
	"<head>\n" +
	"  <title>texas-holdem GraphQL Playground</title>\n" +
	"  <link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/graphql-playground-react/build/static/css/index.css\" />\n" +
	"  <link rel=\"shortcut icon\" href=\"https://cdn.jsdelivr.net/npm/graphql-playground-react/build/favicon.png\" />\n" +
	"  <script src=\"https://cdn.jsdelivr.net/npm/graphql-playground-react/build/static/js/middleware.js\"></script>\n" +
	"</head>\n" +
	"<body>\n" +
	"  <div id=\"root\"></div>\n" +
	"  <script>\n" +
	"    window.addEventListener('load', function() {\n" +
	"      GraphQLPlayground.init(document.getElementById('root'), {\n" +
	"        endpoint: '/graphql',\n" +
	"        settings: {\n" +
	"          'editor.theme': 'dark',\n" +
	"          'editor.fontFamily': \"'Source Code Pro', 'Consolas', 'Inconsolata', 'Droid Sans Mono', 'Monaco', monospace\",\n" +
	"          'editor.fontSize': 14,\n" +
	"          'request.credentials': 'same-origin'\n" +
	"        }\n" +
	"      })\n" +
	"    })\n" +
	"  </script>\n" +
	"</body>\n" +
	"</html>\n"


// graphQLApp wraps Application to implement the resolver interface.
type graphQLApp struct {
	app *Application
}

func (a *graphQLApp) Create(ctx context.Context) (string, error) {
	return a.app.Create(ctx)
}

func (a *graphQLApp) Load(ctx context.Context, id string) (graph.Aggregate, error) {
	return a.app.Load(ctx, id)
}

func (a *graphQLApp) GetState(ctx context.Context, id string) (graph.Aggregate, error) {
	return a.app.GetState(ctx, id)
}

func (a *graphQLApp) Execute(ctx context.Context, id, transition string, data map[string]any) (graph.Aggregate, error) {
	return a.app.Execute(ctx, id, transition, data)
}

func (a *graphQLApp) HealthCheck(ctx context.Context) error {
	return a.app.HealthCheck(ctx)
}

func (a *graphQLApp) GetStore() eventsource.Store {
	return a.app.store
}


// graphQLHandler implements a simple GraphQL HTTP handler.
type graphQLHandler struct {
	resolver *graph.Resolver
}

func (h *graphQLHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	var req struct {
		Query         string                 `json:"query"`
		OperationName string                 `json:"operationName"`
		Variables     map[string]interface{} `json:"variables"`
	}

	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}

	// Execute the GraphQL operation
	result := h.executeGraphQL(r.Context(), req.Query, req.OperationName, req.Variables)

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(result)
}

func (h *graphQLHandler) executeGraphQL(ctx context.Context, query, operationName string, variables map[string]interface{}) map[string]interface{} {
	// This is a simplified GraphQL executor
	// In production, use github.com/99designs/gqlgen for full spec compliance

	result := make(map[string]interface{})
	data := make(map[string]interface{})
	var errors []map[string]interface{}

	// Detect mutation vs query
	isMutation := containsString(query, "mutation")

	// Handle create mutation (supports both "createPackageName" and "package_create" naming)
	// Use matchField to avoid substring collision (e.g. "blogpost_create" vs "blogpost_create_post")
	if isMutation && (matchField(query, "createTexasholdem") || matchField(query, "texasholdem_create")) {
		state, err := h.resolver.CreateTexasholdem(ctx)
		if err != nil {
			errors = append(errors, map[string]interface{}{"message": err.Error()})
		} else {
			// Return under whichever key the query used
			if matchField(query, "texasholdem_create") {
				data["texasholdem_create"] = state
			} else {
				data["createTexasholdem"] = state
			}
		}
	}

	// Handle transition mutations (supports both "transitionName" and "package_transition" naming)

	if isMutation && (containsString(query, "texasholdem_start_hand") || containsString(query, "startHand")) {
		input := graph.StartHandInput{}
		if vars, ok := variables["input"].(map[string]interface{}); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		res, err := h.resolver.StartHand(ctx, input)
		if err != nil {
			errors = append(errors, map[string]interface{}{"message": err.Error()})
		} else {
			// Return under whichever key the query used
			if containsString(query, "texasholdem_start_hand") {
				data["texasholdem_start_hand"] = res
			} else {
				data["startHand"] = res
			}
		}
	}

	if isMutation && (containsString(query, "texasholdem_deal_flop") || containsString(query, "dealFlop")) {
		input := graph.DealFlopInput{}
		if vars, ok := variables["input"].(map[string]interface{}); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		res, err := h.resolver.DealFlop(ctx, input)
		if err != nil {
			errors = append(errors, map[string]interface{}{"message": err.Error()})
		} else {
			// Return under whichever key the query used
			if containsString(query, "texasholdem_deal_flop") {
				data["texasholdem_deal_flop"] = res
			} else {
				data["dealFlop"] = res
			}
		}
	}

	if isMutation && (containsString(query, "texasholdem_deal_turn") || containsString(query, "dealTurn")) {
		input := graph.DealTurnInput{}
		if vars, ok := variables["input"].(map[string]interface{}); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		res, err := h.resolver.DealTurn(ctx, input)
		if err != nil {
			errors = append(errors, map[string]interface{}{"message": err.Error()})
		} else {
			// Return under whichever key the query used
			if containsString(query, "texasholdem_deal_turn") {
				data["texasholdem_deal_turn"] = res
			} else {
				data["dealTurn"] = res
			}
		}
	}

	if isMutation && (containsString(query, "texasholdem_deal_river") || containsString(query, "dealRiver")) {
		input := graph.DealRiverInput{}
		if vars, ok := variables["input"].(map[string]interface{}); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		res, err := h.resolver.DealRiver(ctx, input)
		if err != nil {
			errors = append(errors, map[string]interface{}{"message": err.Error()})
		} else {
			// Return under whichever key the query used
			if containsString(query, "texasholdem_deal_river") {
				data["texasholdem_deal_river"] = res
			} else {
				data["dealRiver"] = res
			}
		}
	}

	if isMutation && (containsString(query, "texasholdem_go_showdown") || containsString(query, "goShowdown")) {
		input := graph.GoShowdownInput{}
		if vars, ok := variables["input"].(map[string]interface{}); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		res, err := h.resolver.GoShowdown(ctx, input)
		if err != nil {
			errors = append(errors, map[string]interface{}{"message": err.Error()})
		} else {
			// Return under whichever key the query used
			if containsString(query, "texasholdem_go_showdown") {
				data["texasholdem_go_showdown"] = res
			} else {
				data["goShowdown"] = res
			}
		}
	}

	if isMutation && (containsString(query, "texasholdem_determine_winner") || containsString(query, "determineWinner")) {
		input := graph.DetermineWinnerInput{}
		if vars, ok := variables["input"].(map[string]interface{}); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		res, err := h.resolver.DetermineWinner(ctx, input)
		if err != nil {
			errors = append(errors, map[string]interface{}{"message": err.Error()})
		} else {
			// Return under whichever key the query used
			if containsString(query, "texasholdem_determine_winner") {
				data["texasholdem_determine_winner"] = res
			} else {
				data["determineWinner"] = res
			}
		}
	}

	if isMutation && (containsString(query, "texasholdem_end_hand") || containsString(query, "endHand")) {
		input := graph.EndHandInput{}
		if vars, ok := variables["input"].(map[string]interface{}); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		res, err := h.resolver.EndHand(ctx, input)
		if err != nil {
			errors = append(errors, map[string]interface{}{"message": err.Error()})
		} else {
			// Return under whichever key the query used
			if containsString(query, "texasholdem_end_hand") {
				data["texasholdem_end_hand"] = res
			} else {
				data["endHand"] = res
			}
		}
	}

	if isMutation && (containsString(query, "texasholdem_p0_fold") || containsString(query, "p0Fold")) {
		input := graph.P0FoldInput{}
		if vars, ok := variables["input"].(map[string]interface{}); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		res, err := h.resolver.P0Fold(ctx, input)
		if err != nil {
			errors = append(errors, map[string]interface{}{"message": err.Error()})
		} else {
			// Return under whichever key the query used
			if containsString(query, "texasholdem_p0_fold") {
				data["texasholdem_p0_fold"] = res
			} else {
				data["p0Fold"] = res
			}
		}
	}

	if isMutation && (containsString(query, "texasholdem_p0_check") || containsString(query, "p0Check")) {
		input := graph.P0CheckInput{}
		if vars, ok := variables["input"].(map[string]interface{}); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		res, err := h.resolver.P0Check(ctx, input)
		if err != nil {
			errors = append(errors, map[string]interface{}{"message": err.Error()})
		} else {
			// Return under whichever key the query used
			if containsString(query, "texasholdem_p0_check") {
				data["texasholdem_p0_check"] = res
			} else {
				data["p0Check"] = res
			}
		}
	}

	if isMutation && (containsString(query, "texasholdem_p0_call") || containsString(query, "p0Call")) {
		input := graph.P0CallInput{}
		if vars, ok := variables["input"].(map[string]interface{}); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		res, err := h.resolver.P0Call(ctx, input)
		if err != nil {
			errors = append(errors, map[string]interface{}{"message": err.Error()})
		} else {
			// Return under whichever key the query used
			if containsString(query, "texasholdem_p0_call") {
				data["texasholdem_p0_call"] = res
			} else {
				data["p0Call"] = res
			}
		}
	}

	if isMutation && (containsString(query, "texasholdem_p0_raise") || containsString(query, "p0Raise")) {
		input := graph.P0RaiseInput{}
		if vars, ok := variables["input"].(map[string]interface{}); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		res, err := h.resolver.P0Raise(ctx, input)
		if err != nil {
			errors = append(errors, map[string]interface{}{"message": err.Error()})
		} else {
			// Return under whichever key the query used
			if containsString(query, "texasholdem_p0_raise") {
				data["texasholdem_p0_raise"] = res
			} else {
				data["p0Raise"] = res
			}
		}
	}

	if isMutation && (containsString(query, "texasholdem_p1_fold") || containsString(query, "p1Fold")) {
		input := graph.P1FoldInput{}
		if vars, ok := variables["input"].(map[string]interface{}); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		res, err := h.resolver.P1Fold(ctx, input)
		if err != nil {
			errors = append(errors, map[string]interface{}{"message": err.Error()})
		} else {
			// Return under whichever key the query used
			if containsString(query, "texasholdem_p1_fold") {
				data["texasholdem_p1_fold"] = res
			} else {
				data["p1Fold"] = res
			}
		}
	}

	if isMutation && (containsString(query, "texasholdem_p1_check") || containsString(query, "p1Check")) {
		input := graph.P1CheckInput{}
		if vars, ok := variables["input"].(map[string]interface{}); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		res, err := h.resolver.P1Check(ctx, input)
		if err != nil {
			errors = append(errors, map[string]interface{}{"message": err.Error()})
		} else {
			// Return under whichever key the query used
			if containsString(query, "texasholdem_p1_check") {
				data["texasholdem_p1_check"] = res
			} else {
				data["p1Check"] = res
			}
		}
	}

	if isMutation && (containsString(query, "texasholdem_p1_call") || containsString(query, "p1Call")) {
		input := graph.P1CallInput{}
		if vars, ok := variables["input"].(map[string]interface{}); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		res, err := h.resolver.P1Call(ctx, input)
		if err != nil {
			errors = append(errors, map[string]interface{}{"message": err.Error()})
		} else {
			// Return under whichever key the query used
			if containsString(query, "texasholdem_p1_call") {
				data["texasholdem_p1_call"] = res
			} else {
				data["p1Call"] = res
			}
		}
	}

	if isMutation && (containsString(query, "texasholdem_p1_raise") || containsString(query, "p1Raise")) {
		input := graph.P1RaiseInput{}
		if vars, ok := variables["input"].(map[string]interface{}); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		res, err := h.resolver.P1Raise(ctx, input)
		if err != nil {
			errors = append(errors, map[string]interface{}{"message": err.Error()})
		} else {
			// Return under whichever key the query used
			if containsString(query, "texasholdem_p1_raise") {
				data["texasholdem_p1_raise"] = res
			} else {
				data["p1Raise"] = res
			}
		}
	}

	if isMutation && (containsString(query, "texasholdem_p2_fold") || containsString(query, "p2Fold")) {
		input := graph.P2FoldInput{}
		if vars, ok := variables["input"].(map[string]interface{}); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		res, err := h.resolver.P2Fold(ctx, input)
		if err != nil {
			errors = append(errors, map[string]interface{}{"message": err.Error()})
		} else {
			// Return under whichever key the query used
			if containsString(query, "texasholdem_p2_fold") {
				data["texasholdem_p2_fold"] = res
			} else {
				data["p2Fold"] = res
			}
		}
	}

	if isMutation && (containsString(query, "texasholdem_p2_check") || containsString(query, "p2Check")) {
		input := graph.P2CheckInput{}
		if vars, ok := variables["input"].(map[string]interface{}); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		res, err := h.resolver.P2Check(ctx, input)
		if err != nil {
			errors = append(errors, map[string]interface{}{"message": err.Error()})
		} else {
			// Return under whichever key the query used
			if containsString(query, "texasholdem_p2_check") {
				data["texasholdem_p2_check"] = res
			} else {
				data["p2Check"] = res
			}
		}
	}

	if isMutation && (containsString(query, "texasholdem_p2_call") || containsString(query, "p2Call")) {
		input := graph.P2CallInput{}
		if vars, ok := variables["input"].(map[string]interface{}); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		res, err := h.resolver.P2Call(ctx, input)
		if err != nil {
			errors = append(errors, map[string]interface{}{"message": err.Error()})
		} else {
			// Return under whichever key the query used
			if containsString(query, "texasholdem_p2_call") {
				data["texasholdem_p2_call"] = res
			} else {
				data["p2Call"] = res
			}
		}
	}

	if isMutation && (containsString(query, "texasholdem_p2_raise") || containsString(query, "p2Raise")) {
		input := graph.P2RaiseInput{}
		if vars, ok := variables["input"].(map[string]interface{}); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		res, err := h.resolver.P2Raise(ctx, input)
		if err != nil {
			errors = append(errors, map[string]interface{}{"message": err.Error()})
		} else {
			// Return under whichever key the query used
			if containsString(query, "texasholdem_p2_raise") {
				data["texasholdem_p2_raise"] = res
			} else {
				data["p2Raise"] = res
			}
		}
	}

	if isMutation && (containsString(query, "texasholdem_p3_fold") || containsString(query, "p3Fold")) {
		input := graph.P3FoldInput{}
		if vars, ok := variables["input"].(map[string]interface{}); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		res, err := h.resolver.P3Fold(ctx, input)
		if err != nil {
			errors = append(errors, map[string]interface{}{"message": err.Error()})
		} else {
			// Return under whichever key the query used
			if containsString(query, "texasholdem_p3_fold") {
				data["texasholdem_p3_fold"] = res
			} else {
				data["p3Fold"] = res
			}
		}
	}

	if isMutation && (containsString(query, "texasholdem_p3_check") || containsString(query, "p3Check")) {
		input := graph.P3CheckInput{}
		if vars, ok := variables["input"].(map[string]interface{}); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		res, err := h.resolver.P3Check(ctx, input)
		if err != nil {
			errors = append(errors, map[string]interface{}{"message": err.Error()})
		} else {
			// Return under whichever key the query used
			if containsString(query, "texasholdem_p3_check") {
				data["texasholdem_p3_check"] = res
			} else {
				data["p3Check"] = res
			}
		}
	}

	if isMutation && (containsString(query, "texasholdem_p3_call") || containsString(query, "p3Call")) {
		input := graph.P3CallInput{}
		if vars, ok := variables["input"].(map[string]interface{}); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		res, err := h.resolver.P3Call(ctx, input)
		if err != nil {
			errors = append(errors, map[string]interface{}{"message": err.Error()})
		} else {
			// Return under whichever key the query used
			if containsString(query, "texasholdem_p3_call") {
				data["texasholdem_p3_call"] = res
			} else {
				data["p3Call"] = res
			}
		}
	}

	if isMutation && (containsString(query, "texasholdem_p3_raise") || containsString(query, "p3Raise")) {
		input := graph.P3RaiseInput{}
		if vars, ok := variables["input"].(map[string]interface{}); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		res, err := h.resolver.P3Raise(ctx, input)
		if err != nil {
			errors = append(errors, map[string]interface{}{"message": err.Error()})
		} else {
			// Return under whichever key the query used
			if containsString(query, "texasholdem_p3_raise") {
				data["texasholdem_p3_raise"] = res
			} else {
				data["p3Raise"] = res
			}
		}
	}

	if isMutation && (containsString(query, "texasholdem_p4_fold") || containsString(query, "p4Fold")) {
		input := graph.P4FoldInput{}
		if vars, ok := variables["input"].(map[string]interface{}); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		res, err := h.resolver.P4Fold(ctx, input)
		if err != nil {
			errors = append(errors, map[string]interface{}{"message": err.Error()})
		} else {
			// Return under whichever key the query used
			if containsString(query, "texasholdem_p4_fold") {
				data["texasholdem_p4_fold"] = res
			} else {
				data["p4Fold"] = res
			}
		}
	}

	if isMutation && (containsString(query, "texasholdem_p4_check") || containsString(query, "p4Check")) {
		input := graph.P4CheckInput{}
		if vars, ok := variables["input"].(map[string]interface{}); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		res, err := h.resolver.P4Check(ctx, input)
		if err != nil {
			errors = append(errors, map[string]interface{}{"message": err.Error()})
		} else {
			// Return under whichever key the query used
			if containsString(query, "texasholdem_p4_check") {
				data["texasholdem_p4_check"] = res
			} else {
				data["p4Check"] = res
			}
		}
	}

	if isMutation && (containsString(query, "texasholdem_p4_call") || containsString(query, "p4Call")) {
		input := graph.P4CallInput{}
		if vars, ok := variables["input"].(map[string]interface{}); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		res, err := h.resolver.P4Call(ctx, input)
		if err != nil {
			errors = append(errors, map[string]interface{}{"message": err.Error()})
		} else {
			// Return under whichever key the query used
			if containsString(query, "texasholdem_p4_call") {
				data["texasholdem_p4_call"] = res
			} else {
				data["p4Call"] = res
			}
		}
	}

	if isMutation && (containsString(query, "texasholdem_p4_raise") || containsString(query, "p4Raise")) {
		input := graph.P4RaiseInput{}
		if vars, ok := variables["input"].(map[string]interface{}); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		res, err := h.resolver.P4Raise(ctx, input)
		if err != nil {
			errors = append(errors, map[string]interface{}{"message": err.Error()})
		} else {
			// Return under whichever key the query used
			if containsString(query, "texasholdem_p4_raise") {
				data["texasholdem_p4_raise"] = res
			} else {
				data["p4Raise"] = res
			}
		}
	}

	if isMutation && (containsString(query, "texasholdem_p0_skip") || containsString(query, "p0Skip")) {
		input := graph.P0SkipInput{}
		if vars, ok := variables["input"].(map[string]interface{}); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		res, err := h.resolver.P0Skip(ctx, input)
		if err != nil {
			errors = append(errors, map[string]interface{}{"message": err.Error()})
		} else {
			// Return under whichever key the query used
			if containsString(query, "texasholdem_p0_skip") {
				data["texasholdem_p0_skip"] = res
			} else {
				data["p0Skip"] = res
			}
		}
	}

	if isMutation && (containsString(query, "texasholdem_p1_skip") || containsString(query, "p1Skip")) {
		input := graph.P1SkipInput{}
		if vars, ok := variables["input"].(map[string]interface{}); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		res, err := h.resolver.P1Skip(ctx, input)
		if err != nil {
			errors = append(errors, map[string]interface{}{"message": err.Error()})
		} else {
			// Return under whichever key the query used
			if containsString(query, "texasholdem_p1_skip") {
				data["texasholdem_p1_skip"] = res
			} else {
				data["p1Skip"] = res
			}
		}
	}

	if isMutation && (containsString(query, "texasholdem_p2_skip") || containsString(query, "p2Skip")) {
		input := graph.P2SkipInput{}
		if vars, ok := variables["input"].(map[string]interface{}); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		res, err := h.resolver.P2Skip(ctx, input)
		if err != nil {
			errors = append(errors, map[string]interface{}{"message": err.Error()})
		} else {
			// Return under whichever key the query used
			if containsString(query, "texasholdem_p2_skip") {
				data["texasholdem_p2_skip"] = res
			} else {
				data["p2Skip"] = res
			}
		}
	}

	if isMutation && (containsString(query, "texasholdem_p3_skip") || containsString(query, "p3Skip")) {
		input := graph.P3SkipInput{}
		if vars, ok := variables["input"].(map[string]interface{}); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		res, err := h.resolver.P3Skip(ctx, input)
		if err != nil {
			errors = append(errors, map[string]interface{}{"message": err.Error()})
		} else {
			// Return under whichever key the query used
			if containsString(query, "texasholdem_p3_skip") {
				data["texasholdem_p3_skip"] = res
			} else {
				data["p3Skip"] = res
			}
		}
	}

	if isMutation && (containsString(query, "texasholdem_p4_skip") || containsString(query, "p4Skip")) {
		input := graph.P4SkipInput{}
		if vars, ok := variables["input"].(map[string]interface{}); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		res, err := h.resolver.P4Skip(ctx, input)
		if err != nil {
			errors = append(errors, map[string]interface{}{"message": err.Error()})
		} else {
			// Return under whichever key the query used
			if containsString(query, "texasholdem_p4_skip") {
				data["texasholdem_p4_skip"] = res
			} else {
				data["p4Skip"] = res
			}
		}
	}


	// Handle query for single aggregate
	if !isMutation && containsString(query, "texasholdem(") {
		id := ""
		if idVar, ok := variables["id"].(string); ok {
			id = idVar
		}
		if id != "" {
			state, err := h.resolver.TexasHoldem(ctx, id)
			if err != nil {
				errors = append(errors, map[string]interface{}{"message": err.Error()})
			} else {
				data["texasholdem"] = state
			}
		}
	}

	// Handle list query
	if !isMutation && containsString(query, "texasholdemList") {
		var place *string
		var page, perPage *int
		if p, ok := variables["place"].(string); ok {
			place = &p
		}
		if p, ok := variables["page"].(float64); ok {
			pi := int(p)
			page = &pi
		}
		if p, ok := variables["perPage"].(float64); ok {
			pi := int(p)
			perPage = &pi
		}
		list, err := h.resolver.TexasHoldemList(ctx, place, page, perPage)
		if err != nil {
			errors = append(errors, map[string]interface{}{"message": err.Error()})
		} else {
			data["texasholdemList"] = list
		}
	}


	// Handle events query
	if !isMutation && containsString(query, "events(") {
		aggID := ""
		var from *int
		if id, ok := variables["aggregateId"].(string); ok {
			aggID = id
		}
		if f, ok := variables["from"].(float64); ok {
			fi := int(f)
			from = &fi
		}
		if aggID != "" {
			events, err := h.resolver.Events(ctx, aggID, from)
			if err != nil {
				errors = append(errors, map[string]interface{}{"message": err.Error()})
			} else {
				data["events"] = events
			}
		}
	}


	result["data"] = data
	if len(errors) > 0 {
		result["errors"] = errors
	}

	return result
}

func containsString(s, substr string) bool {
	return len(s) >= len(substr) && (s == substr || len(s) > 0 && containsStringHelper(s, substr))
}

func containsStringHelper(s, substr string) bool {
	for i := 0; i <= len(s)-len(substr); i++ {
		if s[i:i+len(substr)] == substr {
			return true
		}
	}
	return false
}

// matchField checks if a GraphQL field name appears in a query as a complete identifier.
// Unlike containsString, it ensures the match is not a prefix of a longer identifier.
// e.g. matchField("blogpost_create_post(...)", "blogpost_create") returns false.
func matchField(s, field string) bool {
	for i := 0; i <= len(s)-len(field); i++ {
		if s[i:i+len(field)] == field {
			// Check that the next character is not an identifier char
			if i+len(field) >= len(s) {
				return true
			}
			next := s[i+len(field)]
			if !isIdentChar(next) {
				return true
			}
		}
	}
	return false
}

func isIdentChar(c byte) bool {
	return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c >= '0' && c <= '9') || c == '_'
}

// GraphQLSchemaString is the GraphQL schema for this service.
// Used by the unified GraphQL endpoint to combine schemas.
var GraphQLSchemaString = `# GraphQL schema for texas-holdem

scalar Time

type Query {
  # Get aggregate state by ID
  texasholdem(id: ID!): AggregateState

  # List aggregates with optional filtering
  texasholdemList(place: String, page: Int, perPage: Int): AggregateList!

  # Event history for an aggregate
  events(aggregateId: ID!, from: Int): [Event!]!

  # Get state at specific version
  stateAtVersion(aggregateId: ID!, version: Int!): AggregateState
}

type Mutation {
  # Create a new texasholdem instance
  createTexasholdem: AggregateState!

  # Start a new hand
  startHand(input: StartHandInput!): TransitionResult!

  # Deal the flop
  dealFlop(input: DealFlopInput!): TransitionResult!

  # Deal the turn
  dealTurn(input: DealTurnInput!): TransitionResult!

  # Deal the river
  dealRiver(input: DealRiverInput!): TransitionResult!

  # Go to showdown
  goShowdown(input: GoShowdownInput!): TransitionResult!

  # Determine winner
  determineWinner(input: DetermineWinnerInput!): TransitionResult!

  # End the hand
  endHand(input: EndHandInput!): TransitionResult!

  # Player 0 folds
  p0Fold(input: P0FoldInput!): TransitionResult!

  # Player 0 checks
  p0Check(input: P0CheckInput!): TransitionResult!

  # Player 0 calls
  p0Call(input: P0CallInput!): TransitionResult!

  # Player 0 raises
  p0Raise(input: P0RaiseInput!): TransitionResult!

  # Player 1 folds
  p1Fold(input: P1FoldInput!): TransitionResult!

  # Player 1 checks
  p1Check(input: P1CheckInput!): TransitionResult!

  # Player 1 calls
  p1Call(input: P1CallInput!): TransitionResult!

  # Player 1 raises
  p1Raise(input: P1RaiseInput!): TransitionResult!

  # Player 2 folds
  p2Fold(input: P2FoldInput!): TransitionResult!

  # Player 2 checks
  p2Check(input: P2CheckInput!): TransitionResult!

  # Player 2 calls
  p2Call(input: P2CallInput!): TransitionResult!

  # Player 2 raises
  p2Raise(input: P2RaiseInput!): TransitionResult!

  # Player 3 folds
  p3Fold(input: P3FoldInput!): TransitionResult!

  # Player 3 checks
  p3Check(input: P3CheckInput!): TransitionResult!

  # Player 3 calls
  p3Call(input: P3CallInput!): TransitionResult!

  # Player 3 raises
  p3Raise(input: P3RaiseInput!): TransitionResult!

  # Player 4 folds
  p4Fold(input: P4FoldInput!): TransitionResult!

  # Player 4 checks
  p4Check(input: P4CheckInput!): TransitionResult!

  # Player 4 calls
  p4Call(input: P4CallInput!): TransitionResult!

  # Player 4 raises
  p4Raise(input: P4RaiseInput!): TransitionResult!

  # Skip player 0 (all-in/eliminated)
  p0Skip(input: P0SkipInput!): TransitionResult!

  # Skip player 1 (all-in/eliminated)
  p1Skip(input: P1SkipInput!): TransitionResult!

  # Skip player 2 (all-in/eliminated)
  p2Skip(input: P2SkipInput!): TransitionResult!

  # Skip player 3 (all-in/eliminated)
  p3Skip(input: P3SkipInput!): TransitionResult!

  # Skip player 4 (all-in/eliminated)
  p4Skip(input: P4SkipInput!): TransitionResult!
}

# Aggregate state representation
type AggregateState {
  id: ID!
  version: Int!
  state: State!
  places: Places!
  enabledTransitions: [String!]!
}

# Workflow state with all places
type State {
  waiting: Int!
  preflop: Int!
  flop: Int!
  turnRound: Int!
  river: Int!
  showdown: Int!
  complete: Int!
  p0Turn: Int!
  p1Turn: Int!
  p2Turn: Int!
  p3Turn: Int!
  p4Turn: Int!
  p0Active: Int!
  p1Active: Int!
  p2Active: Int!
  p3Active: Int!
  p4Active: Int!
  bettingDone: Int!
}

# Token counts for each place
type Places {
  waiting: Int!
  preflop: Int!
  flop: Int!
  turnRound: Int!
  river: Int!
  showdown: Int!
  complete: Int!
  p0Turn: Int!
  p1Turn: Int!
  p2Turn: Int!
  p3Turn: Int!
  p4Turn: Int!
  p0Active: Int!
  p1Active: Int!
  p2Active: Int!
  p3Active: Int!
  p4Active: Int!
  bettingDone: Int!
}

# Result of a transition execution
type TransitionResult {
  success: Boolean!
  aggregateId: ID
  version: Int
  state: Places
  enabledTransitions: [String!]
  error: String
}

# Paginated list of aggregates
type AggregateList {
  items: [AggregateState!]!
  total: Int!
  page: Int!
  perPage: Int!
}


# Event record
type Event {
  id: ID!
  streamId: String!
  type: String!
  version: Int!
  timestamp: Time!
  data: String!
}


# Input types for mutations

input StartHandInput {
  aggregateId: ID!
}


input DealFlopInput {
  aggregateId: ID!
}


input DealTurnInput {
  aggregateId: ID!
}


input DealRiverInput {
  aggregateId: ID!
}


input GoShowdownInput {
  aggregateId: ID!
}


input DetermineWinnerInput {
  aggregateId: ID!
}


input EndHandInput {
  aggregateId: ID!
}


input P0FoldInput {
  aggregateId: ID!
}


input P0CheckInput {
  aggregateId: ID!
}


input P0CallInput {
  aggregateId: ID!
}


input P0RaiseInput {
  aggregateId: ID!
}


input P1FoldInput {
  aggregateId: ID!
}


input P1CheckInput {
  aggregateId: ID!
}


input P1CallInput {
  aggregateId: ID!
}


input P1RaiseInput {
  aggregateId: ID!
}


input P2FoldInput {
  aggregateId: ID!
}


input P2CheckInput {
  aggregateId: ID!
}


input P2CallInput {
  aggregateId: ID!
}


input P2RaiseInput {
  aggregateId: ID!
}


input P3FoldInput {
  aggregateId: ID!
}


input P3CheckInput {
  aggregateId: ID!
}


input P3CallInput {
  aggregateId: ID!
}


input P3RaiseInput {
  aggregateId: ID!
}


input P4FoldInput {
  aggregateId: ID!
}


input P4CheckInput {
  aggregateId: ID!
}


input P4CallInput {
  aggregateId: ID!
}


input P4RaiseInput {
  aggregateId: ID!
}


input P0SkipInput {
  aggregateId: ID!
}


input P1SkipInput {
  aggregateId: ID!
}


input P2SkipInput {
  aggregateId: ID!
}


input P3SkipInput {
  aggregateId: ID!
}


input P4SkipInput {
  aggregateId: ID!
}

`

// GraphQLResolversMap returns a map of resolver functions for the unified GraphQL endpoint.
func GraphQLResolversMap(app *Application) map[string]serve.GraphQLResolver {
	gqlApp := &graphQLApp{app: app}
	resolver := graph.NewResolver(gqlApp)

	resolvers := make(map[string]serve.GraphQLResolver)

	// Query resolvers
	resolvers["texasholdem"] = func(ctx context.Context, variables map[string]any) (any, error) {
		id, _ := variables["id"].(string)
		return resolver.TexasHoldem(ctx, id)
	}

	resolvers["texasholdemList"] = func(ctx context.Context, variables map[string]any) (any, error) {
		var place *string
		var page, perPage *int
		if p, ok := variables["place"].(string); ok {
			place = &p
		}
		if p, ok := variables["page"].(float64); ok {
			pi := int(p)
			page = &pi
		}
		if p, ok := variables["perPage"].(float64); ok {
			pi := int(p)
			perPage = &pi
		}
		return resolver.TexasHoldemList(ctx, place, page, perPage)
	}

	// Mutation resolvers (register both underscore and camelCase names for compatibility)
	resolvers["texasholdem_create"] = func(ctx context.Context, _ map[string]any) (any, error) {
		return resolver.CreateTexasholdem(ctx)
	}
	resolvers["createTexasholdem"] = resolvers["texasholdem_create"]


	resolvers["texasholdem_start_hand"] = func(ctx context.Context, variables map[string]any) (any, error) {
		input := graph.StartHandInput{}
		if vars, ok := variables["input"].(map[string]any); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		return resolver.StartHand(ctx, input)
	}
	resolvers["startHand"] = resolvers["texasholdem_start_hand"]


	resolvers["texasholdem_deal_flop"] = func(ctx context.Context, variables map[string]any) (any, error) {
		input := graph.DealFlopInput{}
		if vars, ok := variables["input"].(map[string]any); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		return resolver.DealFlop(ctx, input)
	}
	resolvers["dealFlop"] = resolvers["texasholdem_deal_flop"]


	resolvers["texasholdem_deal_turn"] = func(ctx context.Context, variables map[string]any) (any, error) {
		input := graph.DealTurnInput{}
		if vars, ok := variables["input"].(map[string]any); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		return resolver.DealTurn(ctx, input)
	}
	resolvers["dealTurn"] = resolvers["texasholdem_deal_turn"]


	resolvers["texasholdem_deal_river"] = func(ctx context.Context, variables map[string]any) (any, error) {
		input := graph.DealRiverInput{}
		if vars, ok := variables["input"].(map[string]any); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		return resolver.DealRiver(ctx, input)
	}
	resolvers["dealRiver"] = resolvers["texasholdem_deal_river"]


	resolvers["texasholdem_go_showdown"] = func(ctx context.Context, variables map[string]any) (any, error) {
		input := graph.GoShowdownInput{}
		if vars, ok := variables["input"].(map[string]any); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		return resolver.GoShowdown(ctx, input)
	}
	resolvers["goShowdown"] = resolvers["texasholdem_go_showdown"]


	resolvers["texasholdem_determine_winner"] = func(ctx context.Context, variables map[string]any) (any, error) {
		input := graph.DetermineWinnerInput{}
		if vars, ok := variables["input"].(map[string]any); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		return resolver.DetermineWinner(ctx, input)
	}
	resolvers["determineWinner"] = resolvers["texasholdem_determine_winner"]


	resolvers["texasholdem_end_hand"] = func(ctx context.Context, variables map[string]any) (any, error) {
		input := graph.EndHandInput{}
		if vars, ok := variables["input"].(map[string]any); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		return resolver.EndHand(ctx, input)
	}
	resolvers["endHand"] = resolvers["texasholdem_end_hand"]


	resolvers["texasholdem_p0_fold"] = func(ctx context.Context, variables map[string]any) (any, error) {
		input := graph.P0FoldInput{}
		if vars, ok := variables["input"].(map[string]any); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		return resolver.P0Fold(ctx, input)
	}
	resolvers["p0Fold"] = resolvers["texasholdem_p0_fold"]


	resolvers["texasholdem_p0_check"] = func(ctx context.Context, variables map[string]any) (any, error) {
		input := graph.P0CheckInput{}
		if vars, ok := variables["input"].(map[string]any); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		return resolver.P0Check(ctx, input)
	}
	resolvers["p0Check"] = resolvers["texasholdem_p0_check"]


	resolvers["texasholdem_p0_call"] = func(ctx context.Context, variables map[string]any) (any, error) {
		input := graph.P0CallInput{}
		if vars, ok := variables["input"].(map[string]any); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		return resolver.P0Call(ctx, input)
	}
	resolvers["p0Call"] = resolvers["texasholdem_p0_call"]


	resolvers["texasholdem_p0_raise"] = func(ctx context.Context, variables map[string]any) (any, error) {
		input := graph.P0RaiseInput{}
		if vars, ok := variables["input"].(map[string]any); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		return resolver.P0Raise(ctx, input)
	}
	resolvers["p0Raise"] = resolvers["texasholdem_p0_raise"]


	resolvers["texasholdem_p1_fold"] = func(ctx context.Context, variables map[string]any) (any, error) {
		input := graph.P1FoldInput{}
		if vars, ok := variables["input"].(map[string]any); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		return resolver.P1Fold(ctx, input)
	}
	resolvers["p1Fold"] = resolvers["texasholdem_p1_fold"]


	resolvers["texasholdem_p1_check"] = func(ctx context.Context, variables map[string]any) (any, error) {
		input := graph.P1CheckInput{}
		if vars, ok := variables["input"].(map[string]any); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		return resolver.P1Check(ctx, input)
	}
	resolvers["p1Check"] = resolvers["texasholdem_p1_check"]


	resolvers["texasholdem_p1_call"] = func(ctx context.Context, variables map[string]any) (any, error) {
		input := graph.P1CallInput{}
		if vars, ok := variables["input"].(map[string]any); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		return resolver.P1Call(ctx, input)
	}
	resolvers["p1Call"] = resolvers["texasholdem_p1_call"]


	resolvers["texasholdem_p1_raise"] = func(ctx context.Context, variables map[string]any) (any, error) {
		input := graph.P1RaiseInput{}
		if vars, ok := variables["input"].(map[string]any); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		return resolver.P1Raise(ctx, input)
	}
	resolvers["p1Raise"] = resolvers["texasholdem_p1_raise"]


	resolvers["texasholdem_p2_fold"] = func(ctx context.Context, variables map[string]any) (any, error) {
		input := graph.P2FoldInput{}
		if vars, ok := variables["input"].(map[string]any); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		return resolver.P2Fold(ctx, input)
	}
	resolvers["p2Fold"] = resolvers["texasholdem_p2_fold"]


	resolvers["texasholdem_p2_check"] = func(ctx context.Context, variables map[string]any) (any, error) {
		input := graph.P2CheckInput{}
		if vars, ok := variables["input"].(map[string]any); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		return resolver.P2Check(ctx, input)
	}
	resolvers["p2Check"] = resolvers["texasholdem_p2_check"]


	resolvers["texasholdem_p2_call"] = func(ctx context.Context, variables map[string]any) (any, error) {
		input := graph.P2CallInput{}
		if vars, ok := variables["input"].(map[string]any); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		return resolver.P2Call(ctx, input)
	}
	resolvers["p2Call"] = resolvers["texasholdem_p2_call"]


	resolvers["texasholdem_p2_raise"] = func(ctx context.Context, variables map[string]any) (any, error) {
		input := graph.P2RaiseInput{}
		if vars, ok := variables["input"].(map[string]any); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		return resolver.P2Raise(ctx, input)
	}
	resolvers["p2Raise"] = resolvers["texasholdem_p2_raise"]


	resolvers["texasholdem_p3_fold"] = func(ctx context.Context, variables map[string]any) (any, error) {
		input := graph.P3FoldInput{}
		if vars, ok := variables["input"].(map[string]any); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		return resolver.P3Fold(ctx, input)
	}
	resolvers["p3Fold"] = resolvers["texasholdem_p3_fold"]


	resolvers["texasholdem_p3_check"] = func(ctx context.Context, variables map[string]any) (any, error) {
		input := graph.P3CheckInput{}
		if vars, ok := variables["input"].(map[string]any); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		return resolver.P3Check(ctx, input)
	}
	resolvers["p3Check"] = resolvers["texasholdem_p3_check"]


	resolvers["texasholdem_p3_call"] = func(ctx context.Context, variables map[string]any) (any, error) {
		input := graph.P3CallInput{}
		if vars, ok := variables["input"].(map[string]any); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		return resolver.P3Call(ctx, input)
	}
	resolvers["p3Call"] = resolvers["texasholdem_p3_call"]


	resolvers["texasholdem_p3_raise"] = func(ctx context.Context, variables map[string]any) (any, error) {
		input := graph.P3RaiseInput{}
		if vars, ok := variables["input"].(map[string]any); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		return resolver.P3Raise(ctx, input)
	}
	resolvers["p3Raise"] = resolvers["texasholdem_p3_raise"]


	resolvers["texasholdem_p4_fold"] = func(ctx context.Context, variables map[string]any) (any, error) {
		input := graph.P4FoldInput{}
		if vars, ok := variables["input"].(map[string]any); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		return resolver.P4Fold(ctx, input)
	}
	resolvers["p4Fold"] = resolvers["texasholdem_p4_fold"]


	resolvers["texasholdem_p4_check"] = func(ctx context.Context, variables map[string]any) (any, error) {
		input := graph.P4CheckInput{}
		if vars, ok := variables["input"].(map[string]any); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		return resolver.P4Check(ctx, input)
	}
	resolvers["p4Check"] = resolvers["texasholdem_p4_check"]


	resolvers["texasholdem_p4_call"] = func(ctx context.Context, variables map[string]any) (any, error) {
		input := graph.P4CallInput{}
		if vars, ok := variables["input"].(map[string]any); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		return resolver.P4Call(ctx, input)
	}
	resolvers["p4Call"] = resolvers["texasholdem_p4_call"]


	resolvers["texasholdem_p4_raise"] = func(ctx context.Context, variables map[string]any) (any, error) {
		input := graph.P4RaiseInput{}
		if vars, ok := variables["input"].(map[string]any); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		return resolver.P4Raise(ctx, input)
	}
	resolvers["p4Raise"] = resolvers["texasholdem_p4_raise"]


	resolvers["texasholdem_p0_skip"] = func(ctx context.Context, variables map[string]any) (any, error) {
		input := graph.P0SkipInput{}
		if vars, ok := variables["input"].(map[string]any); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		return resolver.P0Skip(ctx, input)
	}
	resolvers["p0Skip"] = resolvers["texasholdem_p0_skip"]


	resolvers["texasholdem_p1_skip"] = func(ctx context.Context, variables map[string]any) (any, error) {
		input := graph.P1SkipInput{}
		if vars, ok := variables["input"].(map[string]any); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		return resolver.P1Skip(ctx, input)
	}
	resolvers["p1Skip"] = resolvers["texasholdem_p1_skip"]


	resolvers["texasholdem_p2_skip"] = func(ctx context.Context, variables map[string]any) (any, error) {
		input := graph.P2SkipInput{}
		if vars, ok := variables["input"].(map[string]any); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		return resolver.P2Skip(ctx, input)
	}
	resolvers["p2Skip"] = resolvers["texasholdem_p2_skip"]


	resolvers["texasholdem_p3_skip"] = func(ctx context.Context, variables map[string]any) (any, error) {
		input := graph.P3SkipInput{}
		if vars, ok := variables["input"].(map[string]any); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		return resolver.P3Skip(ctx, input)
	}
	resolvers["p3Skip"] = resolvers["texasholdem_p3_skip"]


	resolvers["texasholdem_p4_skip"] = func(ctx context.Context, variables map[string]any) (any, error) {
		input := graph.P4SkipInput{}
		if vars, ok := variables["input"].(map[string]any); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
		}
		return resolver.P4Skip(ctx, input)
	}
	resolvers["p4Skip"] = resolvers["texasholdem_p4_skip"]




	// Events resolver (namespace for unified endpoint)
	resolvers["texasholdem_events"] = func(ctx context.Context, variables map[string]any) (any, error) {
		aggID, _ := variables["aggregateId"].(string)
		var from *int
		if f, ok := variables["from"].(float64); ok {
			fi := int(f)
			from = &fi
		}
		return resolver.Events(ctx, aggID, from)
	}
	resolvers["events"] = resolvers["texasholdem_events"]
	resolvers["texasholdemEvents"] = resolvers["texasholdem_events"]


	return resolvers
}
