# Code generated by petri-pilot. DO NOT EDIT.
# GraphQL schema for texas-holdem

scalar Time

type Query {
  # Get aggregate state by ID
  texasholdem(id: ID!): AggregateState

  # List aggregates with optional filtering
  texasholdemList(place: String, page: Int, perPage: Int): AggregateList!

  # Event history for an aggregate
  events(aggregateId: ID!, from: Int): [Event!]!

  # Get state at specific version
  stateAtVersion(aggregateId: ID!, version: Int!): AggregateState
}

type Mutation {
  # Create a new texas-holdem instance
  createTexasholdem: AggregateState!

  # Start a new hand
  startHand(input: StartHandInput!): TransitionResult!

  # Deal the flop
  dealFlop(input: DealFlopInput!): TransitionResult!

  # Deal the turn
  dealTurn(input: DealTurnInput!): TransitionResult!

  # Deal the river
  dealRiver(input: DealRiverInput!): TransitionResult!

  # Go to showdown
  goShowdown(input: GoShowdownInput!): TransitionResult!

  # Determine winner
  determineWinner(input: DetermineWinnerInput!): TransitionResult!

  # End the hand
  endHand(input: EndHandInput!): TransitionResult!

  # Player 0 folds
  p0Fold(input: P0FoldInput!): TransitionResult!

  # Player 0 checks
  p0Check(input: P0CheckInput!): TransitionResult!

  # Player 0 calls
  p0Call(input: P0CallInput!): TransitionResult!

  # Player 0 raises
  p0Raise(input: P0RaiseInput!): TransitionResult!

  # Player 1 folds
  p1Fold(input: P1FoldInput!): TransitionResult!

  # Player 1 checks
  p1Check(input: P1CheckInput!): TransitionResult!

  # Player 1 calls
  p1Call(input: P1CallInput!): TransitionResult!

  # Player 1 raises
  p1Raise(input: P1RaiseInput!): TransitionResult!

  # Player 2 folds
  p2Fold(input: P2FoldInput!): TransitionResult!

  # Player 2 checks
  p2Check(input: P2CheckInput!): TransitionResult!

  # Player 2 calls
  p2Call(input: P2CallInput!): TransitionResult!

  # Player 2 raises
  p2Raise(input: P2RaiseInput!): TransitionResult!

  # Player 3 folds
  p3Fold(input: P3FoldInput!): TransitionResult!

  # Player 3 checks
  p3Check(input: P3CheckInput!): TransitionResult!

  # Player 3 calls
  p3Call(input: P3CallInput!): TransitionResult!

  # Player 3 raises
  p3Raise(input: P3RaiseInput!): TransitionResult!

  # Player 4 folds
  p4Fold(input: P4FoldInput!): TransitionResult!

  # Player 4 checks
  p4Check(input: P4CheckInput!): TransitionResult!

  # Player 4 calls
  p4Call(input: P4CallInput!): TransitionResult!

  # Player 4 raises
  p4Raise(input: P4RaiseInput!): TransitionResult!

  # Skip player 0 (all-in/eliminated)
  p0Skip(input: P0SkipInput!): TransitionResult!

  # Skip player 1 (all-in/eliminated)
  p1Skip(input: P1SkipInput!): TransitionResult!

  # Skip player 2 (all-in/eliminated)
  p2Skip(input: P2SkipInput!): TransitionResult!

  # Skip player 3 (all-in/eliminated)
  p3Skip(input: P3SkipInput!): TransitionResult!

  # Skip player 4 (all-in/eliminated)
  p4Skip(input: P4SkipInput!): TransitionResult!
}

# Aggregate state representation
type AggregateState {
  id: ID!
  version: Int!
  state: State!
  places: Places!
  enabledTransitions: [String!]!
}

# Workflow state with all places
type State {
  waiting: Int!
  preflop: Int!
  flop: Int!
  turnRound: Int!
  river: Int!
  showdown: Int!
  complete: Int!
  p0Turn: Int!
  p1Turn: Int!
  p2Turn: Int!
  p3Turn: Int!
  p4Turn: Int!
  p0Active: Int!
  p1Active: Int!
  p2Active: Int!
  p3Active: Int!
  p4Active: Int!
  bettingDone: Int!
}

# Token counts for each place
type Places {
  waiting: Int!
  preflop: Int!
  flop: Int!
  turnRound: Int!
  river: Int!
  showdown: Int!
  complete: Int!
  p0Turn: Int!
  p1Turn: Int!
  p2Turn: Int!
  p3Turn: Int!
  p4Turn: Int!
  p0Active: Int!
  p1Active: Int!
  p2Active: Int!
  p3Active: Int!
  p4Active: Int!
  bettingDone: Int!
}

# Result of a transition execution
type TransitionResult {
  success: Boolean!
  aggregateId: ID
  version: Int
  state: Places
  enabledTransitions: [String!]
  error: String
}

# Paginated list of aggregates
type AggregateList {
  items: [AggregateState!]!
  total: Int!
  page: Int!
  perPage: Int!
}


# Event record
type Event {
  id: ID!
  streamId: String!
  type: String!
  version: Int!
  timestamp: Time!
  data: String!
}


# Input types for mutations

input StartHandInput {
  aggregateId: ID!
}


input DealFlopInput {
  aggregateId: ID!
}


input DealTurnInput {
  aggregateId: ID!
}


input DealRiverInput {
  aggregateId: ID!
}


input GoShowdownInput {
  aggregateId: ID!
}


input DetermineWinnerInput {
  aggregateId: ID!
}


input EndHandInput {
  aggregateId: ID!
}


input P0FoldInput {
  aggregateId: ID!
}


input P0CheckInput {
  aggregateId: ID!
}


input P0CallInput {
  aggregateId: ID!
}


input P0RaiseInput {
  aggregateId: ID!
}


input P1FoldInput {
  aggregateId: ID!
}


input P1CheckInput {
  aggregateId: ID!
}


input P1CallInput {
  aggregateId: ID!
}


input P1RaiseInput {
  aggregateId: ID!
}


input P2FoldInput {
  aggregateId: ID!
}


input P2CheckInput {
  aggregateId: ID!
}


input P2CallInput {
  aggregateId: ID!
}


input P2RaiseInput {
  aggregateId: ID!
}


input P3FoldInput {
  aggregateId: ID!
}


input P3CheckInput {
  aggregateId: ID!
}


input P3CallInput {
  aggregateId: ID!
}


input P3RaiseInput {
  aggregateId: ID!
}


input P4FoldInput {
  aggregateId: ID!
}


input P4CheckInput {
  aggregateId: ID!
}


input P4CallInput {
  aggregateId: ID!
}


input P4RaiseInput {
  aggregateId: ID!
}


input P0SkipInput {
  aggregateId: ID!
}


input P1SkipInput {
  aggregateId: ID!
}


input P2SkipInput {
  aggregateId: ID!
}


input P3SkipInput {
  aggregateId: ID!
}


input P4SkipInput {
  aggregateId: ID!
}

