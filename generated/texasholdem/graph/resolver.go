// Code generated by petri-pilot. DO NOT EDIT.

package graph

import (
	"context"
	"encoding/json"
	"fmt"

	"github.com/pflow-xyz/go-pflow/eventsource"
)

// Resolver is the root resolver for GraphQL queries and mutations.
type Resolver struct {
	App interface {
		Create(ctx context.Context) (string, error)
		Load(ctx context.Context, id string) (Aggregate, error)
		GetState(ctx context.Context, id string) (Aggregate, error)
		Execute(ctx context.Context, id, transition string, data map[string]any) (Aggregate, error)
		HealthCheck(ctx context.Context) error
		GetStore() eventsource.Store
	}
}

// Aggregate interface for type safety
type Aggregate interface {
	ID() string
	Version() int
	State() any
	Places() map[string]int
	EnabledTransitions() []string
}

// NewResolver creates a new GraphQL resolver.
func NewResolver(app interface {
	Create(ctx context.Context) (string, error)
	Load(ctx context.Context, id string) (Aggregate, error)
	GetState(ctx context.Context, id string) (Aggregate, error)
	Execute(ctx context.Context, id, transition string, data map[string]any) (Aggregate, error)
	HealthCheck(ctx context.Context) error
	GetStore() eventsource.Store
}) *Resolver {
	return &Resolver{App: app}
}

// Query resolvers

// TexasHoldem returns the aggregate state by ID.
func (r *Resolver) TexasHoldem(ctx context.Context, id string) (*AggregateState, error) {
	agg, err := r.App.GetState(ctx, id)
	if err != nil {
		return nil, err
	}
	return aggregateToState(agg), nil
}

// TexasHoldemList returns a paginated list of aggregates.
func (r *Resolver) TexasHoldemList(ctx context.Context, place *string, page *int, perPage *int) (*AggregateList, error) {
	// Default pagination
	p := 1
	pp := 50
	if page != nil {
		p = *page
	}
	if perPage != nil {
		pp = *perPage
	}

	placeFilter := ""
	if place != nil {
		placeFilter = *place
	}
	// Admin features not enabled - return empty list
	_ = placeFilter
	return &AggregateList{
		Items:   []*AggregateState{},
		Total:   0,
		Page:    p,
		PerPage: pp,
	}, nil
}


// Events returns the event history for an aggregate.
func (r *Resolver) Events(ctx context.Context, aggregateID string, from *int) ([]*Event, error) {
	store := r.App.GetStore()
	fromVersion := 0
	if from != nil {
		fromVersion = *from
	}

	events, err := store.Read(ctx, aggregateID, fromVersion)
	if err != nil {
		return nil, err
	}

	result := make([]*Event, len(events))
	for i, evt := range events {
		data, _ := json.Marshal(evt.Data)
		result[i] = &Event{
			ID:        fmt.Sprintf("%s-%d", evt.StreamID, evt.Version),
			StreamID:  evt.StreamID,
			Type:      evt.Type,
			Version:   evt.Version,
			Timestamp: evt.Timestamp,
			Data:      string(data),
		}
	}

	return result, nil
}

// StateAtVersion returns the aggregate state at a specific version.
func (r *Resolver) StateAtVersion(ctx context.Context, aggregateID string, version int) (*AggregateState, error) {
	// This is a simplified implementation - would need aggregate rebuild logic
	agg, err := r.App.GetState(ctx, aggregateID)
	if err != nil {
		return nil, err
	}

	// TODO: Implement proper version replay
	state := aggregateToState(agg)
	state.Version = version
	return state, nil
}


// Mutation resolvers

// CreateTexasholdem creates a new aggregate instance.
func (r *Resolver) CreateTexasholdem(ctx context.Context) (*AggregateState, error) {
	id, err := r.App.Create(ctx)
	if err != nil {
		return nil, err
	}

	agg, err := r.App.Load(ctx, id)
	if err != nil {
		return nil, err
	}

	return aggregateToState(agg), nil
}


// StartHand executes the start_hand transition.
func (r *Resolver) StartHand(ctx context.Context, input StartHandInput) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "start_hand", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// DealFlop executes the deal_flop transition.
func (r *Resolver) DealFlop(ctx context.Context, input DealFlopInput) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "deal_flop", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// DealTurn executes the deal_turn transition.
func (r *Resolver) DealTurn(ctx context.Context, input DealTurnInput) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "deal_turn", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// DealRiver executes the deal_river transition.
func (r *Resolver) DealRiver(ctx context.Context, input DealRiverInput) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "deal_river", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// GoShowdown executes the go_showdown transition.
func (r *Resolver) GoShowdown(ctx context.Context, input GoShowdownInput) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "go_showdown", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// DetermineWinner executes the determine_winner transition.
func (r *Resolver) DetermineWinner(ctx context.Context, input DetermineWinnerInput) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "determine_winner", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// EndHand executes the end_hand transition.
func (r *Resolver) EndHand(ctx context.Context, input EndHandInput) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "end_hand", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// P0Fold executes the p0_fold transition.
func (r *Resolver) P0Fold(ctx context.Context, input P0FoldInput) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "p0_fold", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// P0Check executes the p0_check transition.
func (r *Resolver) P0Check(ctx context.Context, input P0CheckInput) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "p0_check", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// P0Call executes the p0_call transition.
func (r *Resolver) P0Call(ctx context.Context, input P0CallInput) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "p0_call", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// P0Raise executes the p0_raise transition.
func (r *Resolver) P0Raise(ctx context.Context, input P0RaiseInput) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "p0_raise", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// P1Fold executes the p1_fold transition.
func (r *Resolver) P1Fold(ctx context.Context, input P1FoldInput) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "p1_fold", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// P1Check executes the p1_check transition.
func (r *Resolver) P1Check(ctx context.Context, input P1CheckInput) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "p1_check", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// P1Call executes the p1_call transition.
func (r *Resolver) P1Call(ctx context.Context, input P1CallInput) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "p1_call", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// P1Raise executes the p1_raise transition.
func (r *Resolver) P1Raise(ctx context.Context, input P1RaiseInput) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "p1_raise", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// P2Fold executes the p2_fold transition.
func (r *Resolver) P2Fold(ctx context.Context, input P2FoldInput) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "p2_fold", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// P2Check executes the p2_check transition.
func (r *Resolver) P2Check(ctx context.Context, input P2CheckInput) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "p2_check", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// P2Call executes the p2_call transition.
func (r *Resolver) P2Call(ctx context.Context, input P2CallInput) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "p2_call", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// P2Raise executes the p2_raise transition.
func (r *Resolver) P2Raise(ctx context.Context, input P2RaiseInput) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "p2_raise", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// P3Fold executes the p3_fold transition.
func (r *Resolver) P3Fold(ctx context.Context, input P3FoldInput) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "p3_fold", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// P3Check executes the p3_check transition.
func (r *Resolver) P3Check(ctx context.Context, input P3CheckInput) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "p3_check", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// P3Call executes the p3_call transition.
func (r *Resolver) P3Call(ctx context.Context, input P3CallInput) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "p3_call", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// P3Raise executes the p3_raise transition.
func (r *Resolver) P3Raise(ctx context.Context, input P3RaiseInput) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "p3_raise", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// P4Fold executes the p4_fold transition.
func (r *Resolver) P4Fold(ctx context.Context, input P4FoldInput) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "p4_fold", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// P4Check executes the p4_check transition.
func (r *Resolver) P4Check(ctx context.Context, input P4CheckInput) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "p4_check", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// P4Call executes the p4_call transition.
func (r *Resolver) P4Call(ctx context.Context, input P4CallInput) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "p4_call", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// P4Raise executes the p4_raise transition.
func (r *Resolver) P4Raise(ctx context.Context, input P4RaiseInput) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "p4_raise", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// P0Skip executes the p0_skip transition.
func (r *Resolver) P0Skip(ctx context.Context, input P0SkipInput) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "p0_skip", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// P1Skip executes the p1_skip transition.
func (r *Resolver) P1Skip(ctx context.Context, input P1SkipInput) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "p1_skip", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// P2Skip executes the p2_skip transition.
func (r *Resolver) P2Skip(ctx context.Context, input P2SkipInput) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "p2_skip", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// P3Skip executes the p3_skip transition.
func (r *Resolver) P3Skip(ctx context.Context, input P3SkipInput) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "p3_skip", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// P4Skip executes the p4_skip transition.
func (r *Resolver) P4Skip(ctx context.Context, input P4SkipInput) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "p4_skip", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}



// Helper functions

func aggregateToState(agg Aggregate) *AggregateState {
	places := agg.Places()
	return &AggregateState{
		ID:                 agg.ID(),
		Version:            agg.Version(),
		State:              stateToModel(agg.State()),
		Places:             placesToModel(places),
		EnabledTransitions: agg.EnabledTransitions(),
	}
}

func stateToModel(state any) *State {
	s := &State{}
	// Convert struct to map via JSON roundtrip for uniform field access
	m := stateToMap(state)
	if v, ok := m["waiting"]; ok {
		s.Waiting = v
	}
	if v, ok := m["preflop"]; ok {
		s.Preflop = v
	}
	if v, ok := m["flop"]; ok {
		s.Flop = v
	}
	if v, ok := m["turn_round"]; ok {
		s.TurnRound = v
	}
	if v, ok := m["river"]; ok {
		s.River = v
	}
	if v, ok := m["showdown"]; ok {
		s.Showdown = v
	}
	if v, ok := m["complete"]; ok {
		s.Complete = v
	}
	if v, ok := m["p0_turn"]; ok {
		s.P0Turn = v
	}
	if v, ok := m["p1_turn"]; ok {
		s.P1Turn = v
	}
	if v, ok := m["p2_turn"]; ok {
		s.P2Turn = v
	}
	if v, ok := m["p3_turn"]; ok {
		s.P3Turn = v
	}
	if v, ok := m["p4_turn"]; ok {
		s.P4Turn = v
	}
	if v, ok := m["p0_active"]; ok {
		s.P0Active = v
	}
	if v, ok := m["p1_active"]; ok {
		s.P1Active = v
	}
	if v, ok := m["p2_active"]; ok {
		s.P2Active = v
	}
	if v, ok := m["p3_active"]; ok {
		s.P3Active = v
	}
	if v, ok := m["p4_active"]; ok {
		s.P4Active = v
	}
	if v, ok := m["betting_done"]; ok {
		s.BettingDone = v
	}
	return s
}

func stateToMap(state any) map[string]any {
	// Try direct map assertion first
	if m, ok := state.(map[string]any); ok {
		return m
	}
	// Fall back to JSON roundtrip for struct types
	b, err := json.Marshal(state)
	if err != nil {
		return nil
	}
	var m map[string]any
	if err := json.Unmarshal(b, &m); err != nil {
		return nil
	}
	return m
}

func placesToModel(places map[string]int) *Places {
	p := &Places{}
	if v, ok := places["waiting"]; ok {
		p.Waiting = v
	}
	if v, ok := places["preflop"]; ok {
		p.Preflop = v
	}
	if v, ok := places["flop"]; ok {
		p.Flop = v
	}
	if v, ok := places["turn_round"]; ok {
		p.TurnRound = v
	}
	if v, ok := places["river"]; ok {
		p.River = v
	}
	if v, ok := places["showdown"]; ok {
		p.Showdown = v
	}
	if v, ok := places["complete"]; ok {
		p.Complete = v
	}
	if v, ok := places["p0_turn"]; ok {
		p.P0Turn = v
	}
	if v, ok := places["p1_turn"]; ok {
		p.P1Turn = v
	}
	if v, ok := places["p2_turn"]; ok {
		p.P2Turn = v
	}
	if v, ok := places["p3_turn"]; ok {
		p.P3Turn = v
	}
	if v, ok := places["p4_turn"]; ok {
		p.P4Turn = v
	}
	if v, ok := places["p0_active"]; ok {
		p.P0Active = v
	}
	if v, ok := places["p1_active"]; ok {
		p.P1Active = v
	}
	if v, ok := places["p2_active"]; ok {
		p.P2Active = v
	}
	if v, ok := places["p3_active"]; ok {
		p.P3Active = v
	}
	if v, ok := places["p4_active"]; ok {
		p.P4Active = v
	}
	if v, ok := places["betting_done"]; ok {
		p.BettingDone = v
	}
	return p
}

// GraphQL model types

type AggregateState struct {
	ID                 string   `json:"id"`
	Version            int      `json:"version"`
	State              *State   `json:"state"`
	Places             *Places  `json:"places"`
	EnabledTransitions []string `json:"enabledTransitions"`
}

type State struct {
	Waiting any `json:"waiting"`
	Preflop any `json:"preflop"`
	Flop any `json:"flop"`
	TurnRound any `json:"turnRound"`
	River any `json:"river"`
	Showdown any `json:"showdown"`
	Complete any `json:"complete"`
	P0Turn any `json:"p0Turn"`
	P1Turn any `json:"p1Turn"`
	P2Turn any `json:"p2Turn"`
	P3Turn any `json:"p3Turn"`
	P4Turn any `json:"p4Turn"`
	P0Active any `json:"p0Active"`
	P1Active any `json:"p1Active"`
	P2Active any `json:"p2Active"`
	P3Active any `json:"p3Active"`
	P4Active any `json:"p4Active"`
	BettingDone any `json:"bettingDone"`
}

type Places struct {
	Waiting int `json:"waiting"`
	Preflop int `json:"preflop"`
	Flop int `json:"flop"`
	TurnRound int `json:"turnRound"`
	River int `json:"river"`
	Showdown int `json:"showdown"`
	Complete int `json:"complete"`
	P0Turn int `json:"p0Turn"`
	P1Turn int `json:"p1Turn"`
	P2Turn int `json:"p2Turn"`
	P3Turn int `json:"p3Turn"`
	P4Turn int `json:"p4Turn"`
	P0Active int `json:"p0Active"`
	P1Active int `json:"p1Active"`
	P2Active int `json:"p2Active"`
	P3Active int `json:"p3Active"`
	P4Active int `json:"p4Active"`
	BettingDone int `json:"bettingDone"`
}

type TransitionResult struct {
	Success            bool     `json:"success"`
	AggregateID        *string  `json:"aggregateId"`
	Version            *int     `json:"version"`
	State              *Places  `json:"state"`
	EnabledTransitions []string `json:"enabledTransitions"`
	Error              *string  `json:"error"`
}

type AggregateList struct {
	Items   []*AggregateState `json:"items"`
	Total   int               `json:"total"`
	Page    int               `json:"page"`
	PerPage int               `json:"perPage"`
}


type Event struct {
	ID        string `json:"id"`
	StreamID  string `json:"streamId"`
	Type      string `json:"type"`
	Version   int    `json:"version"`
	Timestamp any    `json:"timestamp"`
	Data      string `json:"data"`
}


// Input types

type StartHandInput struct {
	AggregateID string
}


type DealFlopInput struct {
	AggregateID string
}


type DealTurnInput struct {
	AggregateID string
}


type DealRiverInput struct {
	AggregateID string
}


type GoShowdownInput struct {
	AggregateID string
}


type DetermineWinnerInput struct {
	AggregateID string
}


type EndHandInput struct {
	AggregateID string
}


type P0FoldInput struct {
	AggregateID string
}


type P0CheckInput struct {
	AggregateID string
}


type P0CallInput struct {
	AggregateID string
}


type P0RaiseInput struct {
	AggregateID string
}


type P1FoldInput struct {
	AggregateID string
}


type P1CheckInput struct {
	AggregateID string
}


type P1CallInput struct {
	AggregateID string
}


type P1RaiseInput struct {
	AggregateID string
}


type P2FoldInput struct {
	AggregateID string
}


type P2CheckInput struct {
	AggregateID string
}


type P2CallInput struct {
	AggregateID string
}


type P2RaiseInput struct {
	AggregateID string
}


type P3FoldInput struct {
	AggregateID string
}


type P3CheckInput struct {
	AggregateID string
}


type P3CallInput struct {
	AggregateID string
}


type P3RaiseInput struct {
	AggregateID string
}


type P4FoldInput struct {
	AggregateID string
}


type P4CheckInput struct {
	AggregateID string
}


type P4CallInput struct {
	AggregateID string
}


type P4RaiseInput struct {
	AggregateID string
}


type P0SkipInput struct {
	AggregateID string
}


type P1SkipInput struct {
	AggregateID string
}


type P2SkipInput struct {
	AggregateID string
}


type P3SkipInput struct {
	AggregateID string
}


type P4SkipInput struct {
	AggregateID string
}

