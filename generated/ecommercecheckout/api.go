// Code generated by petri-pilot. DO NOT EDIT.

package ecommercecheckout

import (
	"encoding/base64"
	"encoding/json"
	"io/fs"
	"net/http"
	"os"
	"path/filepath"
	"strconv"
	"strings"

	"github.com/pflow-xyz/petri-pilot/pkg/runtime/api"
)

// BuildRouter creates an HTTP router for the ecommerce-checkout workflow.
func BuildRouter(app *Application) http.Handler {
	r := api.NewRouter()

	// Health check - always returns ok if server is running
	r.GET("/health", "Health check", func(w http.ResponseWriter, r *http.Request) {
		api.JSON(w, http.StatusOK, map[string]string{"status": "ok"})
	})

	// Readiness check - verifies dependencies (database, etc.)
	r.GET("/ready", "Readiness check", HandleReady(app))

	// Create new aggregate
	r.POST("/api/ecommercecheckout", "Create new ecommerce-checkout", HandleCreate(app))

	// Get aggregate state
	r.GET("/api/ecommercecheckout/{id}", "Get ecommerce-checkout state", HandleGetState(app))


	// Schema viewer endpoint
	r.GET("/api/schema", "Get model schema", HandleGetSchema())



	// Event replay endpoints
	r.GET("/api/ecommercecheckout/{id}/events", "Get event history", HandleGetEvents(app))
	r.GET("/api/ecommercecheckout/{id}/at/{version}", "Get state at version", HandleGetStateAtVersion(app))
	r.POST("/api/ecommercecheckout/{id}/truncate", "Truncate event history to version", HandleTruncate(app))






















	// Transition endpoints
	r.Transition("start_checkout", "/api/start_checkout", "Begin checkout process", HandleStartCheckout(app))
	r.Transition("enter_payment", "/api/enter_payment", "Enter payment details", HandleEnterPayment(app))
	r.Transition("process_payment", "/api/process_payment", "Process the payment", HandleProcessPayment(app))
	r.Transition("payment_success", "/api/payment_success", "Payment processed successfully", HandlePaymentSuccess(app))
	r.Transition("payment_fail_1", "/api/payment_fail_1", "First payment attempt failed", HandlePaymentFail1(app))
	r.Transition("retry_payment_1", "/api/retry_payment_1", "Retry payment (attempt 2)", HandleRetryPayment1(app))
	r.Transition("payment_fail_2", "/api/payment_fail_2", "Second payment attempt failed", HandlePaymentFail2(app))
	r.Transition("retry_payment_2", "/api/retry_payment_2", "Retry payment (attempt 3)", HandleRetryPayment2(app))
	r.Transition("payment_fail_3", "/api/payment_fail_3", "Third payment attempt failed", HandlePaymentFail3(app))
	r.Transition("cancel_order", "/api/cancel_order", "Cancel order after max retries", HandleCancelOrder(app))
	r.Transition("fulfill", "/api/fulfill", "Fulfill the order", HandleFulfill(app))

	// Serve frontend static files
	r.StaticFiles("/", StaticFileHandler())

	return r.Build()
}

// StaticFileHandler returns an http.Handler that serves static files from frontend/.
// It supports SPA routing by returning index.html for paths that don't match static files.
func StaticFileHandler() http.HandlerFunc {
	// Find frontend directory - try custom frontends first, then generated
	frontendPath := ""
	candidates := []string{
		"frontends/ecommerce-checkout",                    // Custom frontend (top priority)
		"frontend",                                    // Running from service directory
		"generated/ecommercecheckout/frontend",         // Generated frontend from repo root
		filepath.Join("generated", "ecommercecheckout", "frontend"), // Platform-safe
	}

	// Also try relative to executable
	if exe, err := os.Executable(); err == nil {
		exeDir := filepath.Dir(exe)
		candidates = append(candidates,
			filepath.Join(exeDir, "frontends", "ecommerce-checkout"),
			filepath.Join(exeDir, "frontend"),
			filepath.Join(exeDir, "generated", "ecommercecheckout", "frontend"),
		)
	}

	for _, candidate := range candidates {
		if _, err := os.Stat(candidate); err == nil {
			frontendPath = candidate
			break
		}
	}

	return func(w http.ResponseWriter, r *http.Request) {
		// No frontend found
		if frontendPath == "" {
			http.Error(w, "Frontend not found", http.StatusNotFound)
			return
		}

		// Clean the path
		path := strings.TrimPrefix(r.URL.Path, "/")
		if path == "" {
			path = "index.html"
		}

		// Try to serve the file
		fullPath := filepath.Join(frontendPath, path)

		// Check if file exists
		info, err := os.Stat(fullPath)
		if err != nil || info.IsDir() {
			// File doesn't exist, serve index.html for SPA routing
			http.ServeFile(w, r, filepath.Join(frontendPath, "index.html"))
			return
		}

		http.ServeFile(w, r, fullPath)
	}
}

// StaticFS is a helper interface for embedding static files (optional).
type StaticFS interface {
	fs.FS
}

// HandleCreate creates a new aggregate instance.
func HandleCreate(app *Application) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()

		id, err := app.Create(ctx)
		if err != nil {
			api.Error(w, http.StatusInternalServerError, "CREATE_FAILED", err.Error())
			return
		}

		// Load the new aggregate to get initial state
		agg, err := app.Load(ctx, id)
		if err != nil {
			api.Error(w, http.StatusInternalServerError, "LOAD_FAILED", err.Error())
			return
		}

		api.JSON(w, http.StatusCreated, api.StateResponse{
			AggregateID:        agg.ID(),
			Version:            agg.Version(),
			State:              agg.State(),
			Places:             agg.Places(),
			EnabledTransitions: agg.EnabledTransitions(),
		})
	}
}

// HandleGetState returns the current state of an aggregate.
func HandleGetState(app *Application) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()
		id := r.PathValue("id")
		if id == "" {
			api.Error(w, http.StatusBadRequest, "MISSING_ID", "aggregate ID is required")
			return
		}

		agg, err := app.GetState(ctx, id)
		if err != nil {
			api.Error(w, http.StatusNotFound, "NOT_FOUND", err.Error())
			return
		}

		api.JSON(w, http.StatusOK, api.StateResponse{
			AggregateID:        agg.ID(),
			Version:            agg.Version(),
			State:              agg.State(),
			Places:             agg.Places(),
			EnabledTransitions: agg.EnabledTransitions(),
		})
	}
}

// HandleReady checks if the application is ready to serve requests.
// Returns 200 if all dependencies are available, 503 otherwise.
func HandleReady(app *Application) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		checks := make(map[string]string)
		ready := true

		// Check event store connectivity
		if err := app.HealthCheck(r.Context()); err != nil {
			checks["eventstore"] = err.Error()
			ready = false
		} else {
			checks["eventstore"] = "ok"
		}

		status := http.StatusOK
		statusText := "ready"
		if !ready {
			status = http.StatusServiceUnavailable
			statusText = "not ready"
		}

		api.JSON(w, status, map[string]any{
			"status": statusText,
			"checks": checks,
		})
	}
}


// HandleStartCheckout handles the start_checkout transition.
func HandleStartCheckout(app *Application) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()

		var req api.TransitionRequest
		if err := api.DecodeJSON(r, &req); err != nil {
			api.Error(w, http.StatusBadRequest, "INVALID_REQUEST", err.Error())
			return
		}

		if req.AggregateID == "" {
			api.Error(w, http.StatusBadRequest, "MISSING_ID", "aggregate_id is required")
			return
		}

		agg, err := app.Execute(ctx, req.AggregateID, TransitionStartCheckout, req.Data)
		if err != nil {
			api.Error(w, http.StatusConflict, "TRANSITION_FAILED", err.Error())
			return
		}

		api.JSON(w, http.StatusOK, api.TransitionResult{
			Success:            true,
			AggregateID:        agg.ID(),
			Version:            agg.Version(),
			State:              agg.Places(),
			EnabledTransitions: agg.EnabledTransitions(),
		})
	}
}


// HandleEnterPayment handles the enter_payment transition.
func HandleEnterPayment(app *Application) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()

		var req api.TransitionRequest
		if err := api.DecodeJSON(r, &req); err != nil {
			api.Error(w, http.StatusBadRequest, "INVALID_REQUEST", err.Error())
			return
		}

		if req.AggregateID == "" {
			api.Error(w, http.StatusBadRequest, "MISSING_ID", "aggregate_id is required")
			return
		}

		agg, err := app.Execute(ctx, req.AggregateID, TransitionEnterPayment, req.Data)
		if err != nil {
			api.Error(w, http.StatusConflict, "TRANSITION_FAILED", err.Error())
			return
		}

		api.JSON(w, http.StatusOK, api.TransitionResult{
			Success:            true,
			AggregateID:        agg.ID(),
			Version:            agg.Version(),
			State:              agg.Places(),
			EnabledTransitions: agg.EnabledTransitions(),
		})
	}
}


// HandleProcessPayment handles the process_payment transition.
func HandleProcessPayment(app *Application) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()

		var req api.TransitionRequest
		if err := api.DecodeJSON(r, &req); err != nil {
			api.Error(w, http.StatusBadRequest, "INVALID_REQUEST", err.Error())
			return
		}

		if req.AggregateID == "" {
			api.Error(w, http.StatusBadRequest, "MISSING_ID", "aggregate_id is required")
			return
		}

		agg, err := app.Execute(ctx, req.AggregateID, TransitionProcessPayment, req.Data)
		if err != nil {
			api.Error(w, http.StatusConflict, "TRANSITION_FAILED", err.Error())
			return
		}

		api.JSON(w, http.StatusOK, api.TransitionResult{
			Success:            true,
			AggregateID:        agg.ID(),
			Version:            agg.Version(),
			State:              agg.Places(),
			EnabledTransitions: agg.EnabledTransitions(),
		})
	}
}


// HandlePaymentSuccess handles the payment_success transition.
func HandlePaymentSuccess(app *Application) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()

		var req api.TransitionRequest
		if err := api.DecodeJSON(r, &req); err != nil {
			api.Error(w, http.StatusBadRequest, "INVALID_REQUEST", err.Error())
			return
		}

		if req.AggregateID == "" {
			api.Error(w, http.StatusBadRequest, "MISSING_ID", "aggregate_id is required")
			return
		}

		agg, err := app.Execute(ctx, req.AggregateID, TransitionPaymentSuccess, req.Data)
		if err != nil {
			api.Error(w, http.StatusConflict, "TRANSITION_FAILED", err.Error())
			return
		}

		api.JSON(w, http.StatusOK, api.TransitionResult{
			Success:            true,
			AggregateID:        agg.ID(),
			Version:            agg.Version(),
			State:              agg.Places(),
			EnabledTransitions: agg.EnabledTransitions(),
		})
	}
}


// HandlePaymentFail1 handles the payment_fail_1 transition.
func HandlePaymentFail1(app *Application) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()

		var req api.TransitionRequest
		if err := api.DecodeJSON(r, &req); err != nil {
			api.Error(w, http.StatusBadRequest, "INVALID_REQUEST", err.Error())
			return
		}

		if req.AggregateID == "" {
			api.Error(w, http.StatusBadRequest, "MISSING_ID", "aggregate_id is required")
			return
		}

		agg, err := app.Execute(ctx, req.AggregateID, TransitionPaymentFail1, req.Data)
		if err != nil {
			api.Error(w, http.StatusConflict, "TRANSITION_FAILED", err.Error())
			return
		}

		api.JSON(w, http.StatusOK, api.TransitionResult{
			Success:            true,
			AggregateID:        agg.ID(),
			Version:            agg.Version(),
			State:              agg.Places(),
			EnabledTransitions: agg.EnabledTransitions(),
		})
	}
}


// HandleRetryPayment1 handles the retry_payment_1 transition.
func HandleRetryPayment1(app *Application) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()

		var req api.TransitionRequest
		if err := api.DecodeJSON(r, &req); err != nil {
			api.Error(w, http.StatusBadRequest, "INVALID_REQUEST", err.Error())
			return
		}

		if req.AggregateID == "" {
			api.Error(w, http.StatusBadRequest, "MISSING_ID", "aggregate_id is required")
			return
		}

		agg, err := app.Execute(ctx, req.AggregateID, TransitionRetryPayment1, req.Data)
		if err != nil {
			api.Error(w, http.StatusConflict, "TRANSITION_FAILED", err.Error())
			return
		}

		api.JSON(w, http.StatusOK, api.TransitionResult{
			Success:            true,
			AggregateID:        agg.ID(),
			Version:            agg.Version(),
			State:              agg.Places(),
			EnabledTransitions: agg.EnabledTransitions(),
		})
	}
}


// HandlePaymentFail2 handles the payment_fail_2 transition.
func HandlePaymentFail2(app *Application) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()

		var req api.TransitionRequest
		if err := api.DecodeJSON(r, &req); err != nil {
			api.Error(w, http.StatusBadRequest, "INVALID_REQUEST", err.Error())
			return
		}

		if req.AggregateID == "" {
			api.Error(w, http.StatusBadRequest, "MISSING_ID", "aggregate_id is required")
			return
		}

		agg, err := app.Execute(ctx, req.AggregateID, TransitionPaymentFail2, req.Data)
		if err != nil {
			api.Error(w, http.StatusConflict, "TRANSITION_FAILED", err.Error())
			return
		}

		api.JSON(w, http.StatusOK, api.TransitionResult{
			Success:            true,
			AggregateID:        agg.ID(),
			Version:            agg.Version(),
			State:              agg.Places(),
			EnabledTransitions: agg.EnabledTransitions(),
		})
	}
}


// HandleRetryPayment2 handles the retry_payment_2 transition.
func HandleRetryPayment2(app *Application) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()

		var req api.TransitionRequest
		if err := api.DecodeJSON(r, &req); err != nil {
			api.Error(w, http.StatusBadRequest, "INVALID_REQUEST", err.Error())
			return
		}

		if req.AggregateID == "" {
			api.Error(w, http.StatusBadRequest, "MISSING_ID", "aggregate_id is required")
			return
		}

		agg, err := app.Execute(ctx, req.AggregateID, TransitionRetryPayment2, req.Data)
		if err != nil {
			api.Error(w, http.StatusConflict, "TRANSITION_FAILED", err.Error())
			return
		}

		api.JSON(w, http.StatusOK, api.TransitionResult{
			Success:            true,
			AggregateID:        agg.ID(),
			Version:            agg.Version(),
			State:              agg.Places(),
			EnabledTransitions: agg.EnabledTransitions(),
		})
	}
}


// HandlePaymentFail3 handles the payment_fail_3 transition.
func HandlePaymentFail3(app *Application) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()

		var req api.TransitionRequest
		if err := api.DecodeJSON(r, &req); err != nil {
			api.Error(w, http.StatusBadRequest, "INVALID_REQUEST", err.Error())
			return
		}

		if req.AggregateID == "" {
			api.Error(w, http.StatusBadRequest, "MISSING_ID", "aggregate_id is required")
			return
		}

		agg, err := app.Execute(ctx, req.AggregateID, TransitionPaymentFail3, req.Data)
		if err != nil {
			api.Error(w, http.StatusConflict, "TRANSITION_FAILED", err.Error())
			return
		}

		api.JSON(w, http.StatusOK, api.TransitionResult{
			Success:            true,
			AggregateID:        agg.ID(),
			Version:            agg.Version(),
			State:              agg.Places(),
			EnabledTransitions: agg.EnabledTransitions(),
		})
	}
}


// HandleCancelOrder handles the cancel_order transition.
func HandleCancelOrder(app *Application) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()

		var req api.TransitionRequest
		if err := api.DecodeJSON(r, &req); err != nil {
			api.Error(w, http.StatusBadRequest, "INVALID_REQUEST", err.Error())
			return
		}

		if req.AggregateID == "" {
			api.Error(w, http.StatusBadRequest, "MISSING_ID", "aggregate_id is required")
			return
		}

		agg, err := app.Execute(ctx, req.AggregateID, TransitionCancelOrder, req.Data)
		if err != nil {
			api.Error(w, http.StatusConflict, "TRANSITION_FAILED", err.Error())
			return
		}

		api.JSON(w, http.StatusOK, api.TransitionResult{
			Success:            true,
			AggregateID:        agg.ID(),
			Version:            agg.Version(),
			State:              agg.Places(),
			EnabledTransitions: agg.EnabledTransitions(),
		})
	}
}


// HandleFulfill handles the fulfill transition.
func HandleFulfill(app *Application) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()

		var req api.TransitionRequest
		if err := api.DecodeJSON(r, &req); err != nil {
			api.Error(w, http.StatusBadRequest, "INVALID_REQUEST", err.Error())
			return
		}

		if req.AggregateID == "" {
			api.Error(w, http.StatusBadRequest, "MISSING_ID", "aggregate_id is required")
			return
		}

		agg, err := app.Execute(ctx, req.AggregateID, TransitionFulfill, req.Data)
		if err != nil {
			api.Error(w, http.StatusConflict, "TRANSITION_FAILED", err.Error())
			return
		}

		api.JSON(w, http.StatusOK, api.TransitionResult{
			Success:            true,
			AggregateID:        agg.ID(),
			Version:            agg.Version(),
			State:              agg.Places(),
			EnabledTransitions: agg.EnabledTransitions(),
		})
	}
}








// HandleGetEvents returns the event history for an aggregate.
func HandleGetEvents(app *Application) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()
		id := r.PathValue("id")
		from := getIntQueryParam(r, "from", 0)

		events, err := app.store.Read(ctx, id, from)
		if err != nil {
			api.Error(w, http.StatusInternalServerError, "READ_FAILED", err.Error())
			return
		}

		api.JSON(w, http.StatusOK, map[string]interface{}{
			"events": events,
		})
	}
}

// HandleGetStateAtVersion returns the aggregate state at a specific version.
func HandleGetStateAtVersion(app *Application) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()
		id := r.PathValue("id")
		versionStr := r.PathValue("version")

		version := getInt(versionStr, 0)
		if version <= 0 {
			api.Error(w, http.StatusBadRequest, "INVALID_VERSION", "version must be a positive integer")
			return
		}

		events, err := app.store.Read(ctx, id, 0)
		if err != nil {
			api.Error(w, http.StatusInternalServerError, "READ_FAILED", err.Error())
			return
		}

		// Create temporary aggregate and replay up to version
		agg := NewAggregate(id)
		for _, evt := range events {
			if evt.Version > version {
				break
			}
			if err := agg.Apply(evt); err != nil {
				api.Error(w, http.StatusInternalServerError, "APPLY_FAILED", err.Error())
				return
			}
		}

		api.JSON(w, http.StatusOK, map[string]interface{}{
			"id":      agg.ID(),
			"version": version,
			"state":   agg.State(),
		})
	}
}

// HandleTruncate truncates the event stream to a specific version.
// This enables "undo and redo differently" workflows by discarding events after the target version.
func HandleTruncate(app *Application) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()
		id := r.PathValue("id")

		var req struct {
			Version int `json:"version"`
		}
		if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
			api.Error(w, http.StatusBadRequest, "INVALID_REQUEST", "request body must contain version field")
			return
		}

		if req.Version < 0 {
			api.Error(w, http.StatusBadRequest, "INVALID_VERSION", "version must be non-negative")
			return
		}

		agg, err := app.TruncateTo(ctx, id, req.Version)
		if err != nil {
			api.Error(w, http.StatusInternalServerError, "TRUNCATE_FAILED", err.Error())
			return
		}

		api.JSON(w, http.StatusOK, map[string]interface{}{
			"id":                    agg.ID(),
			"version":               agg.Version(),
			"state":                 agg.State(),
			"enabled_transitions":   agg.EnabledTransitions(),
		})
	}
}





// Helper functions

func getIntQueryParam(r *http.Request, name string, defaultVal int) int {
	val := r.URL.Query().Get(name)
	return getInt(val, defaultVal)
}

func getInt(s string, defaultVal int) int {
	if s == "" {
		return defaultVal
	}

	intVal, err := strconv.Atoi(s)
	if err != nil {
		return defaultVal
	}

	return intVal
}


// HandleGetSchema returns the model schema JSON for the schema viewer.
func HandleGetSchema() http.HandlerFunc {
	// Schema JSON is embedded at generation time (base64 encoded)
	schemaBase64 := "ewogICJuYW1lIjogImVjb21tZXJjZS1jaGVja291dCIsCiAgImRlc2NyaXB0aW9uIjogIkFuIGUtY29tbWVyY2UgY2hlY2tvdXQgd29ya2Zsb3c6IGNhcnQg4oaSIHBheW1lbnQgcHJvY2Vzc2luZyDihpIgcGFpZC4gUGF5bWVudCBjYW4gZmFpbCBhbmQgcmV0cnkgdXAgdG8gMyB0aW1lcyBiZWZvcmUgY2FuY2VsbGF0aW9uLiIsCiAgInBsYWNlcyI6IFsKICAgIHsKICAgICAgImlkIjogImNhcnQiLAogICAgICAiZGVzY3JpcHRpb24iOiAiSXRlbXMgaW4gc2hvcHBpbmcgY2FydCIsCiAgICAgICJpbml0aWFsIjogMSwKICAgICAgImtpbmQiOiAidG9rZW4iCiAgICB9LAogICAgewogICAgICAiaWQiOiAiY2hlY2tvdXRfc3RhcnRlZCIsCiAgICAgICJkZXNjcmlwdGlvbiI6ICJDaGVja291dCBwcm9jZXNzIGluaXRpYXRlZCIsCiAgICAgICJpbml0aWFsIjogMCwKICAgICAgImtpbmQiOiAidG9rZW4iCiAgICB9LAogICAgewogICAgICAiaWQiOiAicGF5bWVudF9wZW5kaW5nIiwKICAgICAgImRlc2NyaXB0aW9uIjogIkF3YWl0aW5nIHBheW1lbnQgcHJvY2Vzc2luZyIsCiAgICAgICJpbml0aWFsIjogMCwKICAgICAgImtpbmQiOiAidG9rZW4iCiAgICB9LAogICAgewogICAgICAiaWQiOiAicGF5bWVudF9wcm9jZXNzaW5nIiwKICAgICAgImRlc2NyaXB0aW9uIjogIlBheW1lbnQgaXMgYmVpbmcgcHJvY2Vzc2VkIiwKICAgICAgImluaXRpYWwiOiAwLAogICAgICAia2luZCI6ICJ0b2tlbiIKICAgIH0sCiAgICB7CiAgICAgICJpZCI6ICJyZXRyeV8xIiwKICAgICAgImRlc2NyaXB0aW9uIjogIkZpcnN0IHBheW1lbnQgcmV0cnkgYXZhaWxhYmxlIiwKICAgICAgImluaXRpYWwiOiAwLAogICAgICAia2luZCI6ICJ0b2tlbiIKICAgIH0sCiAgICB7CiAgICAgICJpZCI6ICJyZXRyeV8yIiwKICAgICAgImRlc2NyaXB0aW9uIjogIlNlY29uZCBwYXltZW50IHJldHJ5IGF2YWlsYWJsZSIsCiAgICAgICJpbml0aWFsIjogMCwKICAgICAgImtpbmQiOiAidG9rZW4iCiAgICB9LAogICAgewogICAgICAiaWQiOiAicmV0cnlfMyIsCiAgICAgICJkZXNjcmlwdGlvbiI6ICJGaW5hbCBwYXltZW50IHJldHJ5IGF2YWlsYWJsZSIsCiAgICAgICJpbml0aWFsIjogMCwKICAgICAgImtpbmQiOiAidG9rZW4iCiAgICB9LAogICAgewogICAgICAiaWQiOiAicGFpZCIsCiAgICAgICJkZXNjcmlwdGlvbiI6ICJQYXltZW50IHN1Y2Nlc3NmdWwiLAogICAgICAiaW5pdGlhbCI6IDAsCiAgICAgICJraW5kIjogInRva2VuIgogICAgfSwKICAgIHsKICAgICAgImlkIjogImNhbmNlbGxlZCIsCiAgICAgICJkZXNjcmlwdGlvbiI6ICJPcmRlciBjYW5jZWxsZWQgZHVlIHRvIHBheW1lbnQgZmFpbHVyZSIsCiAgICAgICJpbml0aWFsIjogMCwKICAgICAgImtpbmQiOiAidG9rZW4iCiAgICB9LAogICAgewogICAgICAiaWQiOiAiZnVsZmlsbGVkIiwKICAgICAgImRlc2NyaXB0aW9uIjogIk9yZGVyIGhhcyBiZWVuIGZ1bGZpbGxlZCIsCiAgICAgICJpbml0aWFsIjogMCwKICAgICAgImtpbmQiOiAidG9rZW4iCiAgICB9CiAgXSwKICAidHJhbnNpdGlvbnMiOiBbCiAgICB7CiAgICAgICJpZCI6ICJzdGFydF9jaGVja291dCIsCiAgICAgICJkZXNjcmlwdGlvbiI6ICJCZWdpbiBjaGVja291dCBwcm9jZXNzIiwKICAgICAgImh0dHBfbWV0aG9kIjogIlBPU1QiLAogICAgICAiaHR0cF9wYXRoIjogIi9hcGkvc3RhcnRfY2hlY2tvdXQiLAogICAgICAiZXZlbnRfdHlwZSI6ICJTdGFydENoZWNrb3V0ZWQiCiAgICB9LAogICAgewogICAgICAiaWQiOiAiZW50ZXJfcGF5bWVudCIsCiAgICAgICJkZXNjcmlwdGlvbiI6ICJFbnRlciBwYXltZW50IGRldGFpbHMiLAogICAgICAiaHR0cF9tZXRob2QiOiAiUE9TVCIsCiAgICAgICJodHRwX3BhdGgiOiAiL2FwaS9lbnRlcl9wYXltZW50IiwKICAgICAgImV2ZW50X3R5cGUiOiAiRW50ZXJQYXltZW50ZWQiCiAgICB9LAogICAgewogICAgICAiaWQiOiAicHJvY2Vzc19wYXltZW50IiwKICAgICAgImRlc2NyaXB0aW9uIjogIlByb2Nlc3MgdGhlIHBheW1lbnQiLAogICAgICAiaHR0cF9tZXRob2QiOiAiUE9TVCIsCiAgICAgICJodHRwX3BhdGgiOiAiL2FwaS9wcm9jZXNzX3BheW1lbnQiLAogICAgICAiZXZlbnRfdHlwZSI6ICJQcm9jZXNzUGF5bWVudGVkIgogICAgfSwKICAgIHsKICAgICAgImlkIjogInBheW1lbnRfc3VjY2VzcyIsCiAgICAgICJkZXNjcmlwdGlvbiI6ICJQYXltZW50IHByb2Nlc3NlZCBzdWNjZXNzZnVsbHkiLAogICAgICAiaHR0cF9tZXRob2QiOiAiUE9TVCIsCiAgICAgICJodHRwX3BhdGgiOiAiL2FwaS9wYXltZW50X3N1Y2Nlc3MiLAogICAgICAiZXZlbnRfdHlwZSI6ICJQYXltZW50U3VjY2Vzc2VkIgogICAgfSwKICAgIHsKICAgICAgImlkIjogInBheW1lbnRfZmFpbF8xIiwKICAgICAgImRlc2NyaXB0aW9uIjogIkZpcnN0IHBheW1lbnQgYXR0ZW1wdCBmYWlsZWQiLAogICAgICAiaHR0cF9tZXRob2QiOiAiUE9TVCIsCiAgICAgICJodHRwX3BhdGgiOiAiL2FwaS9wYXltZW50X2ZhaWxfMSIsCiAgICAgICJldmVudF90eXBlIjogIlBheW1lbnRGYWlsMWVkIgogICAgfSwKICAgIHsKICAgICAgImlkIjogInJldHJ5X3BheW1lbnRfMSIsCiAgICAgICJkZXNjcmlwdGlvbiI6ICJSZXRyeSBwYXltZW50IChhdHRlbXB0IDIpIiwKICAgICAgImh0dHBfbWV0aG9kIjogIlBPU1QiLAogICAgICAiaHR0cF9wYXRoIjogIi9hcGkvcmV0cnlfcGF5bWVudF8xIiwKICAgICAgImV2ZW50X3R5cGUiOiAiUmV0cnlQYXltZW50MWVkIgogICAgfSwKICAgIHsKICAgICAgImlkIjogInBheW1lbnRfZmFpbF8yIiwKICAgICAgImRlc2NyaXB0aW9uIjogIlNlY29uZCBwYXltZW50IGF0dGVtcHQgZmFpbGVkIiwKICAgICAgImh0dHBfbWV0aG9kIjogIlBPU1QiLAogICAgICAiaHR0cF9wYXRoIjogIi9hcGkvcGF5bWVudF9mYWlsXzIiLAogICAgICAiZXZlbnRfdHlwZSI6ICJQYXltZW50RmFpbDJlZCIKICAgIH0sCiAgICB7CiAgICAgICJpZCI6ICJyZXRyeV9wYXltZW50XzIiLAogICAgICAiZGVzY3JpcHRpb24iOiAiUmV0cnkgcGF5bWVudCAoYXR0ZW1wdCAzKSIsCiAgICAgICJodHRwX21ldGhvZCI6ICJQT1NUIiwKICAgICAgImh0dHBfcGF0aCI6ICIvYXBpL3JldHJ5X3BheW1lbnRfMiIsCiAgICAgICJldmVudF90eXBlIjogIlJldHJ5UGF5bWVudDJlZCIKICAgIH0sCiAgICB7CiAgICAgICJpZCI6ICJwYXltZW50X2ZhaWxfMyIsCiAgICAgICJkZXNjcmlwdGlvbiI6ICJUaGlyZCBwYXltZW50IGF0dGVtcHQgZmFpbGVkIiwKICAgICAgImh0dHBfbWV0aG9kIjogIlBPU1QiLAogICAgICAiaHR0cF9wYXRoIjogIi9hcGkvcGF5bWVudF9mYWlsXzMiLAogICAgICAiZXZlbnRfdHlwZSI6ICJQYXltZW50RmFpbDNlZCIKICAgIH0sCiAgICB7CiAgICAgICJpZCI6ICJjYW5jZWxfb3JkZXIiLAogICAgICAiZGVzY3JpcHRpb24iOiAiQ2FuY2VsIG9yZGVyIGFmdGVyIG1heCByZXRyaWVzIiwKICAgICAgImh0dHBfbWV0aG9kIjogIlBPU1QiLAogICAgICAiaHR0cF9wYXRoIjogIi9hcGkvY2FuY2VsX29yZGVyIiwKICAgICAgImV2ZW50X3R5cGUiOiAiQ2FuY2VsT3JkZXJlZCIKICAgIH0sCiAgICB7CiAgICAgICJpZCI6ICJmdWxmaWxsIiwKICAgICAgImRlc2NyaXB0aW9uIjogIkZ1bGZpbGwgdGhlIG9yZGVyIiwKICAgICAgImh0dHBfbWV0aG9kIjogIlBPU1QiLAogICAgICAiaHR0cF9wYXRoIjogIi9hcGkvZnVsZmlsbCIsCiAgICAgICJldmVudF90eXBlIjogIkZ1bGZpbGxlZCIKICAgIH0KICBdLAogICJhcmNzIjogWwogICAgewogICAgICAiZnJvbSI6ICJjYXJ0IiwKICAgICAgInRvIjogInN0YXJ0X2NoZWNrb3V0IgogICAgfSwKICAgIHsKICAgICAgImZyb20iOiAic3RhcnRfY2hlY2tvdXQiLAogICAgICAidG8iOiAiY2hlY2tvdXRfc3RhcnRlZCIKICAgIH0sCiAgICB7CiAgICAgICJmcm9tIjogImNoZWNrb3V0X3N0YXJ0ZWQiLAogICAgICAidG8iOiAiZW50ZXJfcGF5bWVudCIKICAgIH0sCiAgICB7CiAgICAgICJmcm9tIjogImVudGVyX3BheW1lbnQiLAogICAgICAidG8iOiAicGF5bWVudF9wZW5kaW5nIgogICAgfSwKICAgIHsKICAgICAgImZyb20iOiAicGF5bWVudF9wZW5kaW5nIiwKICAgICAgInRvIjogInByb2Nlc3NfcGF5bWVudCIKICAgIH0sCiAgICB7CiAgICAgICJmcm9tIjogInByb2Nlc3NfcGF5bWVudCIsCiAgICAgICJ0byI6ICJwYXltZW50X3Byb2Nlc3NpbmciCiAgICB9LAogICAgewogICAgICAiZnJvbSI6ICJwYXltZW50X3Byb2Nlc3NpbmciLAogICAgICAidG8iOiAicGF5bWVudF9zdWNjZXNzIgogICAgfSwKICAgIHsKICAgICAgImZyb20iOiAicGF5bWVudF9zdWNjZXNzIiwKICAgICAgInRvIjogInBhaWQiCiAgICB9LAogICAgewogICAgICAiZnJvbSI6ICJwYXltZW50X3Byb2Nlc3NpbmciLAogICAgICAidG8iOiAicGF5bWVudF9mYWlsXzEiCiAgICB9LAogICAgewogICAgICAiZnJvbSI6ICJwYXltZW50X2ZhaWxfMSIsCiAgICAgICJ0byI6ICJyZXRyeV8xIgogICAgfSwKICAgIHsKICAgICAgImZyb20iOiAicmV0cnlfMSIsCiAgICAgICJ0byI6ICJyZXRyeV9wYXltZW50XzEiCiAgICB9LAogICAgewogICAgICAiZnJvbSI6ICJyZXRyeV9wYXltZW50XzEiLAogICAgICAidG8iOiAicGF5bWVudF9wcm9jZXNzaW5nIgogICAgfSwKICAgIHsKICAgICAgImZyb20iOiAicGF5bWVudF9wcm9jZXNzaW5nIiwKICAgICAgInRvIjogInBheW1lbnRfZmFpbF8yIgogICAgfSwKICAgIHsKICAgICAgImZyb20iOiAicGF5bWVudF9mYWlsXzIiLAogICAgICAidG8iOiAicmV0cnlfMiIKICAgIH0sCiAgICB7CiAgICAgICJmcm9tIjogInJldHJ5XzIiLAogICAgICAidG8iOiAicmV0cnlfcGF5bWVudF8yIgogICAgfSwKICAgIHsKICAgICAgImZyb20iOiAicmV0cnlfcGF5bWVudF8yIiwKICAgICAgInRvIjogInBheW1lbnRfcHJvY2Vzc2luZyIKICAgIH0sCiAgICB7CiAgICAgICJmcm9tIjogInBheW1lbnRfcHJvY2Vzc2luZyIsCiAgICAgICJ0byI6ICJwYXltZW50X2ZhaWxfMyIKICAgIH0sCiAgICB7CiAgICAgICJmcm9tIjogInBheW1lbnRfZmFpbF8zIiwKICAgICAgInRvIjogInJldHJ5XzMiCiAgICB9LAogICAgewogICAgICAiZnJvbSI6ICJyZXRyeV8zIiwKICAgICAgInRvIjogImNhbmNlbF9vcmRlciIKICAgIH0sCiAgICB7CiAgICAgICJmcm9tIjogImNhbmNlbF9vcmRlciIsCiAgICAgICJ0byI6ICJjYW5jZWxsZWQiCiAgICB9LAogICAgewogICAgICAiZnJvbSI6ICJwYWlkIiwKICAgICAgInRvIjogImZ1bGZpbGwiCiAgICB9LAogICAgewogICAgICAiZnJvbSI6ICJmdWxmaWxsIiwKICAgICAgInRvIjogImZ1bGZpbGxlZCIKICAgIH0KICBdCn0="

	return func(w http.ResponseWriter, r *http.Request) {
		schemaJSON, err := base64.StdEncoding.DecodeString(schemaBase64)
		if err != nil {
			api.Error(w, http.StatusInternalServerError, "schema_decode_error", "Failed to decode schema")
			return
		}
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusOK)
		w.Write(schemaJSON)
	}
}

