// Code generated by petri-pilot. DO NOT EDIT.

package main

import (
	"database/sql"
	"encoding/json"
	"fmt"
	"net/http"
	"time"

	"github.com/pflow-xyz/petri-pilot/pkg/runtime/api"
)






// ============================================================================
// COMMENTS
// ============================================================================

// Comment represents a comment on an aggregate.
type Comment struct {
	ID          string    `json:"id"`
	AggregateID string    `json:"aggregateId"`
	UserID      string    `json:"userId"`
	UserName    string    `json:"userName,omitempty"`
	Content     string    `json:"content"`
	CreatedAt   time.Time `json:"createdAt"`
	UpdatedAt   time.Time `json:"updatedAt"`
}

// CommentStore manages comments.
type CommentStore struct {
	db        *sql.DB
	maxLength int
}

// NewCommentStore creates a new CommentStore.
func NewCommentStore(db *sql.DB) *CommentStore {
	return &CommentStore{db: db, maxLength: 2000}
}

// InitSchema creates the comments table.
func (cs *CommentStore) InitSchema() error {
	_, err := cs.db.Exec(`
		CREATE TABLE IF NOT EXISTS comments (
			id TEXT PRIMARY KEY,
			aggregate_id TEXT NOT NULL,
			user_id TEXT NOT NULL,
			user_name TEXT,
			content TEXT NOT NULL,
			created_at TEXT NOT NULL,
			updated_at TEXT NOT NULL
		);
		CREATE INDEX IF NOT EXISTS idx_comments_aggregate ON comments(aggregate_id);
	`)
	return err
}

// Add adds a comment.
func (cs *CommentStore) Add(aggregateID, userID, userName, content string) (*Comment, error) {
	if len(content) > cs.maxLength {
		return nil, fmt.Errorf("comment exceeds maximum length of %d", cs.maxLength)
	}

	id := fmt.Sprintf("comment_%d", time.Now().UnixNano())
	now := time.Now().UTC()

	_, err := cs.db.Exec(`
		INSERT INTO comments (id, aggregate_id, user_id, user_name, content, created_at, updated_at)
		VALUES (?, ?, ?, ?, ?, ?, ?)
	`, id, aggregateID, userID, userName, content, now.Format(time.RFC3339), now.Format(time.RFC3339))
	if err != nil {
		return nil, err
	}

	return &Comment{
		ID:          id,
		AggregateID: aggregateID,
		UserID:      userID,
		UserName:    userName,
		Content:     content,
		CreatedAt:   now,
		UpdatedAt:   now,
	}, nil
}

// List lists comments for an aggregate.
func (cs *CommentStore) List(aggregateID string) ([]Comment, error) {
	rows, err := cs.db.Query(`
		SELECT id, aggregate_id, user_id, user_name, content, created_at, updated_at
		FROM comments WHERE aggregate_id = ? ORDER BY created_at ASC
	`, aggregateID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var comments []Comment
	for rows.Next() {
		var c Comment
		var createdAt, updatedAt string
		if err := rows.Scan(&c.ID, &c.AggregateID, &c.UserID, &c.UserName, &c.Content, &createdAt, &updatedAt); err != nil {
			continue
		}
		c.CreatedAt, _ = time.Parse(time.RFC3339, createdAt)
		c.UpdatedAt, _ = time.Parse(time.RFC3339, updatedAt)
		comments = append(comments, c)
	}
	return comments, nil
}

// Delete deletes a comment.
func (cs *CommentStore) Delete(id, userID string, isAdmin bool) error {
	if !isAdmin {
		var ownerID string
		err := cs.db.QueryRow(`SELECT user_id FROM comments WHERE id = ?`, id).Scan(&ownerID)
		if err != nil {
			return err
		}
		if ownerID != userID {
			return fmt.Errorf("not authorized to delete this comment")
		}
	}
	_, err := cs.db.Exec(`DELETE FROM comments WHERE id = ?`, id)
	return err
}

// HandleAddComment handles adding a comment.
func (cs *CommentStore) HandleAddComment(w http.ResponseWriter, r *http.Request) {
	aggregateID := r.PathValue("id")
	if aggregateID == "" {
		api.Error(w, http.StatusBadRequest, "MISSING_ID", "aggregate ID required")
		return
	}

	userID, userName := getCommentUser(r)
	if userID == "" {
		api.Error(w, http.StatusUnauthorized, "UNAUTHORIZED", "authentication required")
		return
	}

	var req struct {
		Content string `json:"content"`
	}
	if err := api.DecodeJSON(r, &req); err != nil {
		api.Error(w, http.StatusBadRequest, "INVALID_REQUEST", err.Error())
		return
	}

	comment, err := cs.Add(aggregateID, userID, userName, req.Content)
	if err != nil {
		api.Error(w, http.StatusBadRequest, "ADD_FAILED", err.Error())
		return
	}

	api.JSON(w, http.StatusCreated, comment)
}

// HandleListComments handles listing comments.
func (cs *CommentStore) HandleListComments(w http.ResponseWriter, r *http.Request) {
	aggregateID := r.PathValue("id")
	if aggregateID == "" {
		api.Error(w, http.StatusBadRequest, "MISSING_ID", "aggregate ID required")
		return
	}

	comments, err := cs.List(aggregateID)
	if err != nil {
		api.Error(w, http.StatusInternalServerError, "LIST_FAILED", err.Error())
		return
	}

	api.JSON(w, http.StatusOK, map[string]interface{}{"comments": comments})
}

// HandleDeleteComment handles deleting a comment.
func (cs *CommentStore) HandleDeleteComment(w http.ResponseWriter, r *http.Request) {
	id := r.PathValue("commentId")
	if id == "" {
		api.Error(w, http.StatusBadRequest, "MISSING_ID", "comment ID required")
		return
	}

	userID, _ := getCommentUser(r)
	if userID == "" {
		api.Error(w, http.StatusUnauthorized, "UNAUTHORIZED", "authentication required")
		return
	}

	if err := cs.Delete(id, userID, isCommentAdmin(r)); err != nil {
		api.Error(w, http.StatusForbidden, "DELETE_FAILED", err.Error())
		return
	}

	api.JSON(w, http.StatusOK, map[string]interface{}{"success": true})
}

func getCommentUser(r *http.Request) (string, string) {
	user, ok := r.Context().Value("user").(*User)
	if !ok || user == nil {
		return "", ""
	}
	return fmt.Sprintf("%d", user.ID), user.Name
}

func isCommentAdmin(r *http.Request) bool {
	user, ok := r.Context().Value("user").(*User)
	if !ok || user == nil {
		return false
	}
	for _, role := range user.Roles {
		if role == "admin" {
			return true
		}
	}
	return false
}



// ============================================================================
// TAGS
// ============================================================================

// Tag represents a tag on an aggregate.
type Tag struct {
	ID          string `json:"id"`
	AggregateID string `json:"aggregateId"`
	Name        string `json:"name"`
	Color       string `json:"color,omitempty"`
}

// TagStore manages tags.
type TagStore struct {
	db         *sql.DB
	predefined []string
	freeForm   bool
	maxTags    int
	colors     bool
}

// NewTagStore creates a new TagStore.
func NewTagStore(db *sql.DB) *TagStore {
	return &TagStore{
		db:         db,
		predefined: []string{"urgent", "high-value", "first-time", "returning", "flagged",  },
		freeForm:   false,
		maxTags:    10,
		colors:     false,
	}
}

// InitSchema creates the tags table.
func (ts *TagStore) InitSchema() error {
	_, err := ts.db.Exec(`
		CREATE TABLE IF NOT EXISTS tags (
			id TEXT PRIMARY KEY,
			aggregate_id TEXT NOT NULL,
			name TEXT NOT NULL,
			color TEXT,
			UNIQUE(aggregate_id, name)
		);
		CREATE INDEX IF NOT EXISTS idx_tags_aggregate ON tags(aggregate_id);
		CREATE INDEX IF NOT EXISTS idx_tags_name ON tags(name);
	`)
	return err
}

// Add adds a tag to an aggregate.
func (ts *TagStore) Add(aggregateID, name, color string) (*Tag, error) {
	// Check if tag is allowed
	if !ts.freeForm && len(ts.predefined) > 0 {
		allowed := false
		for _, p := range ts.predefined {
			if p == name {
				allowed = true
				break
			}
		}
		if !allowed {
			return nil, fmt.Errorf("tag '%s' is not in predefined list", name)
		}
	}

	// Check max tags
	var count int
	ts.db.QueryRow(`SELECT COUNT(*) FROM tags WHERE aggregate_id = ?`, aggregateID).Scan(&count)
	if count >= ts.maxTags {
		return nil, fmt.Errorf("maximum of %d tags reached", ts.maxTags)
	}

	id := fmt.Sprintf("tag_%d", time.Now().UnixNano())
	if !ts.colors {
		color = ""
	}

	_, err := ts.db.Exec(`
		INSERT OR IGNORE INTO tags (id, aggregate_id, name, color) VALUES (?, ?, ?, ?)
	`, id, aggregateID, name, color)
	if err != nil {
		return nil, err
	}

	return &Tag{ID: id, AggregateID: aggregateID, Name: name, Color: color}, nil
}

// Remove removes a tag from an aggregate.
func (ts *TagStore) Remove(aggregateID, name string) error {
	_, err := ts.db.Exec(`DELETE FROM tags WHERE aggregate_id = ? AND name = ?`, aggregateID, name)
	return err
}

// List lists tags for an aggregate.
func (ts *TagStore) List(aggregateID string) ([]Tag, error) {
	rows, err := ts.db.Query(`SELECT id, aggregate_id, name, color FROM tags WHERE aggregate_id = ?`, aggregateID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var tags []Tag
	for rows.Next() {
		var t Tag
		var color sql.NullString
		if err := rows.Scan(&t.ID, &t.AggregateID, &t.Name, &color); err != nil {
			continue
		}
		if color.Valid {
			t.Color = color.String
		}
		tags = append(tags, t)
	}
	return tags, nil
}

// HandleAddTag handles adding a tag.
func (ts *TagStore) HandleAddTag(w http.ResponseWriter, r *http.Request) {
	aggregateID := r.PathValue("id")
	var req struct {
		Name  string `json:"name"`
		Color string `json:"color,omitempty"`
	}
	if err := api.DecodeJSON(r, &req); err != nil {
		api.Error(w, http.StatusBadRequest, "INVALID_REQUEST", err.Error())
		return
	}

	tag, err := ts.Add(aggregateID, req.Name, req.Color)
	if err != nil {
		api.Error(w, http.StatusBadRequest, "ADD_FAILED", err.Error())
		return
	}

	api.JSON(w, http.StatusCreated, tag)
}

// HandleRemoveTag handles removing a tag.
func (ts *TagStore) HandleRemoveTag(w http.ResponseWriter, r *http.Request) {
	aggregateID := r.PathValue("id")
	name := r.PathValue("name")

	if err := ts.Remove(aggregateID, name); err != nil {
		api.Error(w, http.StatusInternalServerError, "REMOVE_FAILED", err.Error())
		return
	}

	api.JSON(w, http.StatusOK, map[string]interface{}{"success": true})
}

// HandleListTags handles listing tags.
func (ts *TagStore) HandleListTags(w http.ResponseWriter, r *http.Request) {
	aggregateID := r.PathValue("id")
	tags, err := ts.List(aggregateID)
	if err != nil {
		api.Error(w, http.StatusInternalServerError, "LIST_FAILED", err.Error())
		return
	}

	api.JSON(w, http.StatusOK, map[string]interface{}{
		"tags":       tags,
		"predefined": ts.predefined,
		"freeForm":   ts.freeForm,
	})
}





// ============================================================================
// ACTIVITY FEED
// ============================================================================

// ActivityItem represents an activity feed item.
type ActivityItem struct {
	ID          string    `json:"id"`
	AggregateID string    `json:"aggregateId"`
	EventType   string    `json:"eventType"`
	UserID      string    `json:"userId,omitempty"`
	UserName    string    `json:"userName,omitempty"`
	Summary     string    `json:"summary"`
	Data        any       `json:"data,omitempty"`
	CreatedAt   time.Time `json:"createdAt"`
}

// ActivityStore manages activity feed.
type ActivityStore struct {
	db       *sql.DB
	maxItems int
}

// NewActivityStore creates a new ActivityStore.
func NewActivityStore(db *sql.DB) *ActivityStore {
	return &ActivityStore{db: db, maxItems: 100}
}

// InitSchema creates the activity table.
func (as *ActivityStore) InitSchema() error {
	_, err := as.db.Exec(`
		CREATE TABLE IF NOT EXISTS activity (
			id TEXT PRIMARY KEY,
			aggregate_id TEXT NOT NULL,
			event_type TEXT NOT NULL,
			user_id TEXT,
			user_name TEXT,
			summary TEXT NOT NULL,
			data TEXT,
			created_at TEXT NOT NULL
		);
		CREATE INDEX IF NOT EXISTS idx_activity_aggregate ON activity(aggregate_id);
		CREATE INDEX IF NOT EXISTS idx_activity_created ON activity(created_at DESC);
	`)
	return err
}

// Record records an activity.
func (as *ActivityStore) Record(aggregateID, eventType, userID, userName, summary string, data any) error {
	id := fmt.Sprintf("activity_%d", time.Now().UnixNano())
	now := time.Now().UTC()

	var dataJSON []byte
	if data != nil {
		dataJSON, _ = json.Marshal(data)
	}

	_, err := as.db.Exec(`
		INSERT INTO activity (id, aggregate_id, event_type, user_id, user_name, summary, data, created_at)
		VALUES (?, ?, ?, ?, ?, ?, ?, ?)
	`, id, aggregateID, eventType, userID, userName, summary, string(dataJSON), now.Format(time.RFC3339))
	return err
}

// List lists activity for an aggregate.
func (as *ActivityStore) List(aggregateID string, limit int) ([]ActivityItem, error) {
	if limit <= 0 || limit > as.maxItems {
		limit = as.maxItems
	}

	rows, err := as.db.Query(`
		SELECT id, aggregate_id, event_type, user_id, user_name, summary, data, created_at
		FROM activity WHERE aggregate_id = ? ORDER BY created_at DESC LIMIT ?
	`, aggregateID, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var items []ActivityItem
	for rows.Next() {
		var item ActivityItem
		var userID, userName, dataStr sql.NullString
		var createdAt string
		if err := rows.Scan(&item.ID, &item.AggregateID, &item.EventType, &userID, &userName, &item.Summary, &dataStr, &createdAt); err != nil {
			continue
		}
		if userID.Valid {
			item.UserID = userID.String
		}
		if userName.Valid {
			item.UserName = userName.String
		}
		if dataStr.Valid {
			json.Unmarshal([]byte(dataStr.String), &item.Data)
		}
		item.CreatedAt, _ = time.Parse(time.RFC3339, createdAt)
		items = append(items, item)
	}
	return items, nil
}

// HandleGetActivity handles getting activity.
func (as *ActivityStore) HandleGetActivity(w http.ResponseWriter, r *http.Request) {
	aggregateID := r.PathValue("id")
	items, err := as.List(aggregateID, as.maxItems)
	if err != nil {
		api.Error(w, http.StatusInternalServerError, "LIST_FAILED", err.Error())
		return
	}

	api.JSON(w, http.StatusOK, map[string]interface{}{"activity": items})
}





// ============================================================================
// SOFT DELETE
// ============================================================================

// SoftDeleteStore manages soft deletion.
type SoftDeleteStore struct {
	db            *sql.DB
	retentionDays int
}

// NewSoftDeleteStore creates a new SoftDeleteStore.
func NewSoftDeleteStore(db *sql.DB, retentionDays int) *SoftDeleteStore {
	return &SoftDeleteStore{db: db, retentionDays: retentionDays}
}

// InitSchema creates the soft_deletes table.
func (sds *SoftDeleteStore) InitSchema() error {
	_, err := sds.db.Exec(`
		CREATE TABLE IF NOT EXISTS soft_deletes (
			aggregate_id TEXT PRIMARY KEY,
			deleted_by TEXT,
			deleted_at TEXT NOT NULL,
			expires_at TEXT
		);
	`)
	return err
}

// SoftDelete marks an aggregate as deleted.
func (sds *SoftDeleteStore) SoftDelete(aggregateID, deletedBy string) error {
	now := time.Now().UTC()
	var expiresAt *time.Time
	if sds.retentionDays > 0 {
		exp := now.AddDate(0, 0, sds.retentionDays)
		expiresAt = &exp
	}

	var expiresAtStr interface{}
	if expiresAt != nil {
		expiresAtStr = expiresAt.Format(time.RFC3339)
	}

	_, err := sds.db.Exec(`
		INSERT OR REPLACE INTO soft_deletes (aggregate_id, deleted_by, deleted_at, expires_at)
		VALUES (?, ?, ?, ?)
	`, aggregateID, deletedBy, now.Format(time.RFC3339), expiresAtStr)
	return err
}

// Restore restores a soft-deleted aggregate.
func (sds *SoftDeleteStore) Restore(aggregateID string) error {
	_, err := sds.db.Exec(`DELETE FROM soft_deletes WHERE aggregate_id = ?`, aggregateID)
	return err
}

// IsDeleted checks if an aggregate is soft-deleted.
func (sds *SoftDeleteStore) IsDeleted(aggregateID string) bool {
	var count int
	sds.db.QueryRow(`SELECT COUNT(*) FROM soft_deletes WHERE aggregate_id = ?`, aggregateID).Scan(&count)
	return count > 0
}

// HandleSoftDelete handles soft delete requests.
func (sds *SoftDeleteStore) HandleSoftDelete(w http.ResponseWriter, r *http.Request) {
	aggregateID := r.PathValue("id")
	userID := getSoftDeleteUserID(r)

	if err := sds.SoftDelete(aggregateID, userID); err != nil {
		api.Error(w, http.StatusInternalServerError, "DELETE_FAILED", err.Error())
		return
	}

	api.JSON(w, http.StatusOK, map[string]interface{}{"success": true, "deleted": true})
}

// HandleRestore handles restore requests.
func (sds *SoftDeleteStore) HandleRestore(w http.ResponseWriter, r *http.Request) {
	aggregateID := r.PathValue("id")

	if err := sds.Restore(aggregateID); err != nil {
		api.Error(w, http.StatusInternalServerError, "RESTORE_FAILED", err.Error())
		return
	}

	api.JSON(w, http.StatusOK, map[string]interface{}{"success": true, "restored": true})
}

func getSoftDeleteUserID(r *http.Request) string {
	user, ok := r.Context().Value("user").(*User)
	if !ok || user == nil {
		return ""
	}
	return fmt.Sprintf("%d", user.ID)
}

















