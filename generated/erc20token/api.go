// Code generated by petri-pilot. DO NOT EDIT.

package erc20token

import (
	"context"
	"encoding/base64"
	"encoding/json"
	"io/fs"
	"net/http"
	"os"
	"path/filepath"
	"strconv"
	"strings"

	"github.com/pflow-xyz/petri-pilot/pkg/runtime/api"
	"github.com/pflow-xyz/petri-pilot/pkg/runtime/eventstore"
)

// BuildRouter creates an HTTP router for the erc20-token workflow.
func BuildRouter(app *Application, middleware *Middleware, sessions SessionStore, navigation *Navigation, debugBroker *DebugBroker) http.Handler {
	r := api.NewRouter()

	// Apply auth middleware to extract user from token (optional, doesn't require auth)
	r.Use(OptionalAuthMiddleware(sessions))

	// Health check - always returns ok if server is running
	r.GET("/health", "Health check", func(w http.ResponseWriter, r *http.Request) {
		api.JSON(w, http.StatusOK, map[string]string{"status": "ok"})
	})

	// Readiness check - verifies dependencies (database, etc.)
	r.GET("/ready", "Readiness check", HandleReady(app))

	// Create new aggregate
	r.POST("/api/erc20token", "Create new erc20-token", HandleCreate(app))

	// Get aggregate state
	r.GET("/api/erc20token/{id}", "Get erc20-token state", HandleGetState(app))

	// View definitions
	r.GET("/api/views", "Get view definitions", HandleGetViews())


	// Navigation endpoint
	r.GET("/api/navigation", "Get navigation menu", HandleNavigation(navigation))

	// Schema viewer endpoint
	r.GET("/api/schema", "Get model schema", HandleGetSchema())


	// Admin endpoints
	r.GET("/admin/stats", "Admin statistics", HandleAdminStats(app))
	r.GET("/admin/instances", "List instances", HandleAdminListInstances(app))
	r.GET("/admin/instances/{id}", "Get instance detail", HandleAdminGetInstance(app))
	r.GET("/admin/instances/{id}/events", "Get instance events", HandleAdminGetEvents(app))


	// Event replay endpoints
	r.GET("/api/erc20token/{id}/events", "Get event history", HandleGetEvents(app))
	r.GET("/api/erc20token/{id}/at/{version}", "Get state at version", HandleGetStateAtVersion(app))




	r.POST("/api/erc20token/{id}/snapshot", "Create snapshot", HandleCreateSnapshot(app))
	r.POST("/api/erc20token/{id}/replay", "Replay from snapshot", HandleReplay(app))


	// GraphQL API
	r.Handle("POST", "/graphql", "GraphQL API endpoint", GraphQLHandler(app))
	r.GET("/playground", "GraphQL Playground", PlaygroundHandler())


	// Debug WebSocket and eval endpoints
	r.GET("/ws", "Debug WebSocket connection", HandleDebugWebSocket(debugBroker))
	r.GET("/api/debug/sessions", "List debug sessions", HandleListSessions(debugBroker))
	r.POST("/api/debug/sessions/{id}/eval", "Evaluate code in browser session", HandleSessionEval(debugBroker))
	// Test login endpoint (only available in debug mode)
	r.POST("/api/debug/login", "Create test session with roles", HandleTestLogin(sessions))

















	// Transition endpoints
	r.Transition("transfer", "/api/transfer", "Transfer tokens from sender to recipient", middleware.RequirePermission("transfer")(HandleTransfer(app)))
	r.Transition("approve", "/api/approve", "Approve spender to transfer tokens on owner's behalf", middleware.RequirePermission("approve")(HandleApprove(app)))
	r.Transition("transfer_from", "/api/transfer_from", "Transfer tokens using allowance (delegated transfer)", middleware.RequirePermission("transfer_from")(HandleTransferFrom(app)))
	r.Transition("mint", "/api/mint", "Create new tokens and add to recipient balance", middleware.RequirePermission("mint")(HandleMint(app)))
	r.Transition("burn", "/api/burn", "Destroy tokens from holder's balance", middleware.RequirePermission("burn")(HandleBurn(app)))

	// Serve frontend static files
	r.StaticFiles("/", StaticFileHandler())

	return r.Build()
}

// StaticFileHandler returns an http.Handler that serves static files from frontend/.
// It supports SPA routing by returning index.html for paths that don't match static files.
func StaticFileHandler() http.HandlerFunc {
	// Find frontend directory
	frontendPath := "frontend"
	if _, err := os.Stat(frontendPath); os.IsNotExist(err) {
		// Try relative to executable
		exe, _ := os.Executable()
		frontendPath = filepath.Join(filepath.Dir(exe), "frontend")
	}

	return func(w http.ResponseWriter, r *http.Request) {
		// Clean the path
		path := strings.TrimPrefix(r.URL.Path, "/")
		if path == "" {
			path = "index.html"
		}

		// Try to serve the file
		fullPath := filepath.Join(frontendPath, path)

		// Check if file exists
		info, err := os.Stat(fullPath)
		if err != nil || info.IsDir() {
			// File doesn't exist, serve index.html for SPA routing
			http.ServeFile(w, r, filepath.Join(frontendPath, "index.html"))
			return
		}

		http.ServeFile(w, r, fullPath)
	}
}

// StaticFS is a helper interface for embedding static files (optional).
type StaticFS interface {
	fs.FS
}

// HandleCreate creates a new aggregate instance.
func HandleCreate(app *Application) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()

		id, err := app.Create(ctx)
		if err != nil {
			api.Error(w, http.StatusInternalServerError, "CREATE_FAILED", err.Error())
			return
		}

		// Load the new aggregate to get initial state
		agg, err := app.Load(ctx, id)
		if err != nil {
			api.Error(w, http.StatusInternalServerError, "LOAD_FAILED", err.Error())
			return
		}

		api.JSON(w, http.StatusCreated, api.StateResponse{
			AggregateID:        agg.ID(),
			Version:            agg.Version(),
			State:              agg.State(),
			Places:             agg.Places(),
			EnabledTransitions: agg.EnabledTransitions(),
		})
	}
}

// HandleGetState returns the current state of an aggregate.
func HandleGetState(app *Application) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()
		id := r.PathValue("id")
		if id == "" {
			api.Error(w, http.StatusBadRequest, "MISSING_ID", "aggregate ID is required")
			return
		}

		agg, err := app.GetState(ctx, id)
		if err != nil {
			api.Error(w, http.StatusNotFound, "NOT_FOUND", err.Error())
			return
		}

		api.JSON(w, http.StatusOK, api.StateResponse{
			AggregateID:        agg.ID(),
			Version:            agg.Version(),
			State:              agg.State(),
			Places:             agg.Places(),
			EnabledTransitions: agg.EnabledTransitions(),
		})
	}
}

// HandleReady checks if the application is ready to serve requests.
// Returns 200 if all dependencies are available, 503 otherwise.
func HandleReady(app *Application) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		checks := make(map[string]string)
		ready := true

		// Check event store connectivity
		if err := app.HealthCheck(r.Context()); err != nil {
			checks["eventstore"] = err.Error()
			ready = false
		} else {
			checks["eventstore"] = "ok"
		}

		status := http.StatusOK
		statusText := "ready"
		if !ready {
			status = http.StatusServiceUnavailable
			statusText = "not ready"
		}

		api.JSON(w, status, map[string]any{
			"status": statusText,
			"checks": checks,
		})
	}
}


// HandleTransfer handles the transfer transition.
func HandleTransfer(app *Application) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()

		var req api.TransitionRequest
		if err := api.DecodeJSON(r, &req); err != nil {
			api.Error(w, http.StatusBadRequest, "INVALID_REQUEST", err.Error())
			return
		}

		if req.AggregateID == "" {
			api.Error(w, http.StatusBadRequest, "MISSING_ID", "aggregate_id is required")
			return
		}

		// Check dynamic role grants based on current state
		user := UserFromContext(ctx)
		currentAgg, loadErr := app.Load(ctx, req.AggregateID)
		if loadErr == nil && currentAgg != nil {
			state := make(map[string]any)
			for k, v := range currentAgg.Places() {
				state[k] = v
			}
			// Include full state for dynamic role evaluation
			if typedState, ok := currentAgg.State().(State); ok {
				state["total_supply"] = typedState.TotalSupply
				state["balances"] = typedState.Balances
				state["allowances"] = typedState.Allowances
			}
			if accessErr := CheckAccessTransfer(user, state); accessErr != nil {
				api.Error(w, http.StatusForbidden, "FORBIDDEN", accessErr.Error())
				return
			}
		}

		agg, err := app.Execute(ctx, req.AggregateID, TransitionTransfer, req.Data)
		if err != nil {
			api.Error(w, http.StatusConflict, "TRANSITION_FAILED", err.Error())
			return
		}

		api.JSON(w, http.StatusOK, api.TransitionResult{
			Success:            true,
			AggregateID:        agg.ID(),
			Version:            agg.Version(),
			State:              agg.Places(),
			EnabledTransitions: agg.EnabledTransitions(),
		})
	}
}


// HandleApprove handles the approve transition.
func HandleApprove(app *Application) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()

		var req api.TransitionRequest
		if err := api.DecodeJSON(r, &req); err != nil {
			api.Error(w, http.StatusBadRequest, "INVALID_REQUEST", err.Error())
			return
		}

		if req.AggregateID == "" {
			api.Error(w, http.StatusBadRequest, "MISSING_ID", "aggregate_id is required")
			return
		}

		// Check dynamic role grants based on current state
		user := UserFromContext(ctx)
		currentAgg, loadErr := app.Load(ctx, req.AggregateID)
		if loadErr == nil && currentAgg != nil {
			state := make(map[string]any)
			for k, v := range currentAgg.Places() {
				state[k] = v
			}
			// Include full state for dynamic role evaluation
			if typedState, ok := currentAgg.State().(State); ok {
				state["total_supply"] = typedState.TotalSupply
				state["balances"] = typedState.Balances
				state["allowances"] = typedState.Allowances
			}
			if accessErr := CheckAccessApprove(user, state); accessErr != nil {
				api.Error(w, http.StatusForbidden, "FORBIDDEN", accessErr.Error())
				return
			}
		}

		agg, err := app.Execute(ctx, req.AggregateID, TransitionApprove, req.Data)
		if err != nil {
			api.Error(w, http.StatusConflict, "TRANSITION_FAILED", err.Error())
			return
		}

		api.JSON(w, http.StatusOK, api.TransitionResult{
			Success:            true,
			AggregateID:        agg.ID(),
			Version:            agg.Version(),
			State:              agg.Places(),
			EnabledTransitions: agg.EnabledTransitions(),
		})
	}
}


// HandleTransferFrom handles the transfer_from transition.
func HandleTransferFrom(app *Application) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()

		var req api.TransitionRequest
		if err := api.DecodeJSON(r, &req); err != nil {
			api.Error(w, http.StatusBadRequest, "INVALID_REQUEST", err.Error())
			return
		}

		if req.AggregateID == "" {
			api.Error(w, http.StatusBadRequest, "MISSING_ID", "aggregate_id is required")
			return
		}

		// Check dynamic role grants based on current state
		user := UserFromContext(ctx)
		currentAgg, loadErr := app.Load(ctx, req.AggregateID)
		if loadErr == nil && currentAgg != nil {
			state := make(map[string]any)
			for k, v := range currentAgg.Places() {
				state[k] = v
			}
			// Include full state for dynamic role evaluation
			if typedState, ok := currentAgg.State().(State); ok {
				state["total_supply"] = typedState.TotalSupply
				state["balances"] = typedState.Balances
				state["allowances"] = typedState.Allowances
			}
			if accessErr := CheckAccessTransferFrom(user, state); accessErr != nil {
				api.Error(w, http.StatusForbidden, "FORBIDDEN", accessErr.Error())
				return
			}
		}

		agg, err := app.Execute(ctx, req.AggregateID, TransitionTransferFrom, req.Data)
		if err != nil {
			api.Error(w, http.StatusConflict, "TRANSITION_FAILED", err.Error())
			return
		}

		api.JSON(w, http.StatusOK, api.TransitionResult{
			Success:            true,
			AggregateID:        agg.ID(),
			Version:            agg.Version(),
			State:              agg.Places(),
			EnabledTransitions: agg.EnabledTransitions(),
		})
	}
}


// HandleMint handles the mint transition.
func HandleMint(app *Application) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()

		var req api.TransitionRequest
		if err := api.DecodeJSON(r, &req); err != nil {
			api.Error(w, http.StatusBadRequest, "INVALID_REQUEST", err.Error())
			return
		}

		if req.AggregateID == "" {
			api.Error(w, http.StatusBadRequest, "MISSING_ID", "aggregate_id is required")
			return
		}

		agg, err := app.Execute(ctx, req.AggregateID, TransitionMint, req.Data)
		if err != nil {
			api.Error(w, http.StatusConflict, "TRANSITION_FAILED", err.Error())
			return
		}

		api.JSON(w, http.StatusOK, api.TransitionResult{
			Success:            true,
			AggregateID:        agg.ID(),
			Version:            agg.Version(),
			State:              agg.Places(),
			EnabledTransitions: agg.EnabledTransitions(),
		})
	}
}


// HandleBurn handles the burn transition.
func HandleBurn(app *Application) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()

		var req api.TransitionRequest
		if err := api.DecodeJSON(r, &req); err != nil {
			api.Error(w, http.StatusBadRequest, "INVALID_REQUEST", err.Error())
			return
		}

		if req.AggregateID == "" {
			api.Error(w, http.StatusBadRequest, "MISSING_ID", "aggregate_id is required")
			return
		}

		agg, err := app.Execute(ctx, req.AggregateID, TransitionBurn, req.Data)
		if err != nil {
			api.Error(w, http.StatusConflict, "TRANSITION_FAILED", err.Error())
			return
		}

		api.JSON(w, http.StatusOK, api.TransitionResult{
			Success:            true,
			AggregateID:        agg.ID(),
			Version:            agg.Version(),
			State:              agg.Places(),
			EnabledTransitions: agg.EnabledTransitions(),
		})
	}
}


// HandleGetViews returns the view definitions for the workflow.
func HandleGetViews() http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		data, err := ViewsJSON()
		if err != nil {
			api.Error(w, http.StatusInternalServerError, "VIEWS_ERROR", err.Error())
			return
		}
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusOK)
		w.Write(data)
	}
}


// HandleNavigation returns the navigation menu, filtered by user roles.
func HandleNavigation(nav *Navigation) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		userRoles := getNavUserRoles(r)

		items := []NavigationItem{}
		for _, item := range nav.Items {
			if len(item.Roles) == 0 {
				items = append(items, item)
				continue
			}

			if navHasAnyRole(userRoles, item.Roles) {
				items = append(items, item)
			}
		}

		api.JSON(w, http.StatusOK, map[string]interface{}{
			"brand": nav.Brand,
			"items": items,
		})
	}
}

// getNavUserRoles extracts user roles from the request context.
func getNavUserRoles(r *http.Request) []string {
	user, ok := r.Context().Value("user").(*User)
	if !ok || user == nil {
		return nil
	}
	return user.Roles
}

// navHasAnyRole checks if user has at least one of the required roles.
func navHasAnyRole(userRoles []string, requiredRoles []string) bool {
	for _, required := range requiredRoles {
		for _, userRole := range userRoles {
			if userRole == required {
				return true
			}
		}
	}
	return false
}



// HandleAdminStats wraps the admin stats handler.
func HandleAdminStats(app *Application) http.HandlerFunc {
return func(w http.ResponseWriter, r *http.Request) {
ctx := r.Context()

adminStore, ok := app.store.(interface {
GetStats(ctx context.Context) (*eventstore.Stats, error)
})
if !ok {
api.Error(w, http.StatusInternalServerError, "UNSUPPORTED", "Admin operations not supported")
return
}

stats, err := adminStore.GetStats(ctx)
if err != nil {
api.Error(w, http.StatusInternalServerError, "STATS_FAILED", err.Error())
return
}

api.JSON(w, http.StatusOK, stats)
}
}

// HandleAdminListInstances wraps the admin list instances handler.
func HandleAdminListInstances(app *Application) http.HandlerFunc {
return func(w http.ResponseWriter, r *http.Request) {
ctx := r.Context()

place := r.URL.Query().Get("place")
from := r.URL.Query().Get("from")
to := r.URL.Query().Get("to")
page := getIntQueryParam(r, "page", 1)
perPage := getIntQueryParam(r, "per_page", 50)

adminStore, ok := app.store.(interface {
ListInstances(ctx context.Context, place, from, to string, page, perPage int) ([]eventstore.Instance, int, error)
})
if !ok {
api.Error(w, http.StatusInternalServerError, "UNSUPPORTED", "Admin operations not supported")
return
}

instances, total, err := adminStore.ListInstances(ctx, place, from, to, page, perPage)
if err != nil {
api.Error(w, http.StatusInternalServerError, "LIST_FAILED", err.Error())
return
}

// Load state for each instance by replaying events
// Note: This loads aggregates individually which may be slow for large lists.
// The perPage parameter limits the number of instances processed.
for i := range instances {
agg, err := app.Load(ctx, instances[i].ID)
if err != nil {
// Log error but continue processing other instances
// The state will remain as initialized by ListInstances
continue
}
// Get the Petri net places (token distribution)
instances[i].State = agg.Places()
}

api.JSON(w, http.StatusOK, map[string]interface{}{
"instances": instances,
"total":     total,
"page":      page,
"per_page":  perPage,
})
}
}

// HandleAdminGetInstance wraps the admin get instance handler.
func HandleAdminGetInstance(app *Application) http.HandlerFunc {
return func(w http.ResponseWriter, r *http.Request) {
ctx := r.Context()
id := r.PathValue("id")

agg, err := app.Load(ctx, id)
if err != nil {
api.Error(w, http.StatusNotFound, "NOT_FOUND", err.Error())
return
}

api.JSON(w, http.StatusOK, map[string]interface{}{
"id":      agg.ID(),
"version": agg.Version(),
"state":   agg.State(),
})
}
}

// HandleAdminGetEvents wraps the admin get events handler.
func HandleAdminGetEvents(app *Application) http.HandlerFunc {
return func(w http.ResponseWriter, r *http.Request) {
ctx := r.Context()
id := r.PathValue("id")
from := getIntQueryParam(r, "from", 0)

events, err := app.store.Read(ctx, id, from)
if err != nil {
api.Error(w, http.StatusInternalServerError, "READ_FAILED", err.Error())
return
}

api.JSON(w, http.StatusOK, map[string]interface{}{
"events": events,
})
}
}



// HandleGetEvents returns the event history for an aggregate.
func HandleGetEvents(app *Application) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()
		id := r.PathValue("id")
		from := getIntQueryParam(r, "from", 0)

		events, err := app.store.Read(ctx, id, from)
		if err != nil {
			api.Error(w, http.StatusInternalServerError, "READ_FAILED", err.Error())
			return
		}

		api.JSON(w, http.StatusOK, map[string]interface{}{
			"events": events,
		})
	}
}

// HandleGetStateAtVersion returns the aggregate state at a specific version.
func HandleGetStateAtVersion(app *Application) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()
		id := r.PathValue("id")
		versionStr := r.PathValue("version")

		version := getInt(versionStr, 0)
		if version <= 0 {
			api.Error(w, http.StatusBadRequest, "INVALID_VERSION", "version must be a positive integer")
			return
		}

		events, err := app.store.Read(ctx, id, 0)
		if err != nil {
			api.Error(w, http.StatusInternalServerError, "READ_FAILED", err.Error())
			return
		}

		// Create temporary aggregate and replay up to version
		agg := NewAggregate(id)
		for _, evt := range events {
			if evt.Version > version {
				break
			}
			if err := agg.Apply(evt); err != nil {
				api.Error(w, http.StatusInternalServerError, "APPLY_FAILED", err.Error())
				return
			}
		}

		api.JSON(w, http.StatusOK, map[string]interface{}{
			"id":      agg.ID(),
			"version": version,
			"state":   agg.State(),
		})
	}
}



// HandleCreateSnapshot creates a snapshot of the current aggregate state.
func HandleCreateSnapshot(app *Application) http.HandlerFunc {
return func(w http.ResponseWriter, r *http.Request) {
ctx := r.Context()
id := r.PathValue("id")

agg, err := app.Load(ctx, id)
if err != nil {
api.Error(w, http.StatusNotFound, "NOT_FOUND", err.Error())
return
}

snapshotStore, ok := app.store.(eventstore.SnapshotStore)
if !ok {
api.Error(w, http.StatusInternalServerError, "UNSUPPORTED", "Snapshots not supported")
return
}

stateBytes, err := json.Marshal(agg.State())
if err != nil {
api.Error(w, http.StatusInternalServerError, "MARSHAL_FAILED", err.Error())
return
}

snapshot := &eventstore.Snapshot{
StreamID: id,
Version:  agg.Version(),
State:    stateBytes,
}

if err := snapshotStore.Save(ctx, snapshot); err != nil {
api.Error(w, http.StatusInternalServerError, "SAVE_FAILED", err.Error())
return
}

api.JSON(w, http.StatusCreated, map[string]interface{}{
"message": "Snapshot created",
"version": agg.Version(),
})
}
}

// HandleReplay replays events from the latest snapshot.
func HandleReplay(app *Application) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()
		id := r.PathValue("id")

		snapshotStore, ok := app.store.(eventstore.SnapshotStore)
		if !ok {
			api.Error(w, http.StatusInternalServerError, "UNSUPPORTED", "Snapshots not supported")
			return
		}

		// Load latest snapshot
		snap, err := snapshotStore.Load(ctx, id)
		if err != nil {
			api.Error(w, http.StatusInternalServerError, "LOAD_FAILED", err.Error())
			return
		}
		fromVersion := 0

		agg := NewAggregate(id)

		if snap != nil {
			// Restore from snapshot
			var state map[string]int
			if err := json.Unmarshal(snap.State, &state); err != nil {
				api.Error(w, http.StatusInternalServerError, "UNMARSHAL_FAILED", err.Error())
				return
			}

			// This is a simplified restore - actual implementation depends on aggregate structure
			fromVersion = snap.Version
		}

		// Load events after snapshot
		events, err := app.store.Read(ctx, id, fromVersion)
		if err != nil {
			api.Error(w, http.StatusInternalServerError, "READ_FAILED", err.Error())
			return
		}

		// Replay events
		eventsApplied := 0
		for _, evt := range events {
			if evt.Version <= fromVersion {
				continue
			}
			if err := agg.Apply(evt); err != nil {
				api.Error(w, http.StatusInternalServerError, "APPLY_FAILED", err.Error())
				return
			}
			eventsApplied++
		}

		api.JSON(w, http.StatusOK, map[string]interface{}{
			"id":                     agg.ID(),
			"version":                agg.Version(),
			"state":                  agg.State(),
			"replayed_from_snapshot": fromVersion,
			"events_applied":         eventsApplied,
		})
	}
}



// Helper functions

func getIntQueryParam(r *http.Request, name string, defaultVal int) int {
	val := r.URL.Query().Get(name)
	return getInt(val, defaultVal)
}

func getInt(s string, defaultVal int) int {
	if s == "" {
		return defaultVal
	}

	intVal, err := strconv.Atoi(s)
	if err != nil {
		return defaultVal
	}

	return intVal
}


// HandleGetSchema returns the model schema JSON for the schema viewer.
func HandleGetSchema() http.HandlerFunc {
	// Schema JSON is embedded at generation time (base64 encoded)
	schemaBase64 := "ewogICJuYW1lIjogImVyYzIwLXRva2VuIiwKICAidmVyc2lvbiI6ICIxLjAuMCIsCiAgImRlc2NyaXB0aW9uIjogIkVSQy0yMCBmdW5naWJsZSB0b2tlbiBpbXBsZW1lbnRhdGlvbiB1c2luZyBQZXRyaSBuZXQgc2VtYW50aWNzIiwKICAicGxhY2VzIjogWwogICAgewogICAgICAiaWQiOiAidG90YWxfc3VwcGx5IiwKICAgICAgImRlc2NyaXB0aW9uIjogIlRvdGFsIHRva2VucyBpbiBjaXJjdWxhdGlvbiIsCiAgICAgICJpbml0aWFsIjogMCwKICAgICAgImtpbmQiOiAiZGF0YSIsCiAgICAgICJ0eXBlIjogImludDY0IiwKICAgICAgInBlcnNpc3RlZCI6IHRydWUsCiAgICAgICJpbml0aWFsX3ZhbHVlIjogMAogICAgfSwKICAgIHsKICAgICAgImlkIjogImJhbGFuY2VzIiwKICAgICAgImRlc2NyaXB0aW9uIjogIlRva2VuIGJhbGFuY2UgcGVyIGFkZHJlc3MiLAogICAgICAiaW5pdGlhbCI6IDAsCiAgICAgICJraW5kIjogImRhdGEiLAogICAgICAidHlwZSI6ICJtYXBbc3RyaW5nXWludDY0IiwKICAgICAgImV4cG9ydGVkIjogdHJ1ZSwKICAgICAgInBlcnNpc3RlZCI6IHRydWUKICAgIH0sCiAgICB7CiAgICAgICJpZCI6ICJhbGxvd2FuY2VzIiwKICAgICAgImRlc2NyaXB0aW9uIjogIlNwZW5kaW5nIGFsbG93YW5jZXM6IG93bmVyIC1cdTAwM2Ugc3BlbmRlciAtXHUwMDNlIGFtb3VudCAobmVzdGVkIG1hcCkiLAogICAgICAiaW5pdGlhbCI6IDAsCiAgICAgICJraW5kIjogImRhdGEiLAogICAgICAidHlwZSI6ICJtYXBbc3RyaW5nXW1hcFtzdHJpbmddaW50NjQiLAogICAgICAiZXhwb3J0ZWQiOiB0cnVlLAogICAgICAicGVyc2lzdGVkIjogdHJ1ZQogICAgfQogIF0sCiAgInRyYW5zaXRpb25zIjogWwogICAgewogICAgICAiaWQiOiAidHJhbnNmZXIiLAogICAgICAiZGVzY3JpcHRpb24iOiAiVHJhbnNmZXIgdG9rZW5zIGZyb20gc2VuZGVyIHRvIHJlY2lwaWVudCIsCiAgICAgICJndWFyZCI6ICJiYWxhbmNlc1tmcm9tXSBcdTAwM2U9IGFtb3VudCIsCiAgICAgICJldmVudCI6ICJ0cmFuc2Zlcl9ldmVudCIsCiAgICAgICJiaW5kaW5ncyI6IFsKICAgICAgICB7CiAgICAgICAgICAibmFtZSI6ICJmcm9tIiwKICAgICAgICAgICJ0eXBlIjogInN0cmluZyIsCiAgICAgICAgICAia2V5cyI6IFsKICAgICAgICAgICAgImZyb20iCiAgICAgICAgICBdLAogICAgICAgICAgInBsYWNlIjogImJhbGFuY2VzIgogICAgICAgIH0sCiAgICAgICAgewogICAgICAgICAgIm5hbWUiOiAidG8iLAogICAgICAgICAgInR5cGUiOiAic3RyaW5nIiwKICAgICAgICAgICJrZXlzIjogWwogICAgICAgICAgICAidG8iCiAgICAgICAgICBdLAogICAgICAgICAgInBsYWNlIjogImJhbGFuY2VzIgogICAgICAgIH0sCiAgICAgICAgewogICAgICAgICAgIm5hbWUiOiAiYW1vdW50IiwKICAgICAgICAgICJ0eXBlIjogImludDY0IiwKICAgICAgICAgICJ2YWx1ZSI6IHRydWUKICAgICAgICB9CiAgICAgIF0sCiAgICAgICJmaWVsZHMiOiBbCiAgICAgICAgewogICAgICAgICAgIm5hbWUiOiAiZnJvbSIsCiAgICAgICAgICAibGFiZWwiOiAiRnJvbSBBZGRyZXNzIiwKICAgICAgICAgICJ0eXBlIjogImFkZHJlc3MiLAogICAgICAgICAgInJlcXVpcmVkIjogdHJ1ZSwKICAgICAgICAgICJhdXRvRmlsbCI6ICJ3YWxsZXQiLAogICAgICAgICAgInBsYWNlaG9sZGVyIjogIlNlbmRlciBhZGRyZXNzIgogICAgICAgIH0sCiAgICAgICAgewogICAgICAgICAgIm5hbWUiOiAidG8iLAogICAgICAgICAgImxhYmVsIjogIlRvIEFkZHJlc3MiLAogICAgICAgICAgInR5cGUiOiAiYWRkcmVzcyIsCiAgICAgICAgICAicmVxdWlyZWQiOiB0cnVlLAogICAgICAgICAgInBsYWNlaG9sZGVyIjogIlJlY2lwaWVudCBhZGRyZXNzIgogICAgICAgIH0sCiAgICAgICAgewogICAgICAgICAgIm5hbWUiOiAiYW1vdW50IiwKICAgICAgICAgICJsYWJlbCI6ICJBbW91bnQiLAogICAgICAgICAgInR5cGUiOiAiYW1vdW50IiwKICAgICAgICAgICJyZXF1aXJlZCI6IHRydWUsCiAgICAgICAgICAicGxhY2Vob2xkZXIiOiAiQW1vdW50IHRvIHRyYW5zZmVyIgogICAgICAgIH0KICAgICAgXSwKICAgICAgImh0dHBfbWV0aG9kIjogIlBPU1QiLAogICAgICAiaHR0cF9wYXRoIjogIi9hcGkvdHJhbnNmZXIiLAogICAgICAiZXZlbnRfdHlwZSI6ICJUcmFuc2ZlcmVkIgogICAgfSwKICAgIHsKICAgICAgImlkIjogImFwcHJvdmUiLAogICAgICAiZGVzY3JpcHRpb24iOiAiQXBwcm92ZSBzcGVuZGVyIHRvIHRyYW5zZmVyIHRva2VucyBvbiBvd25lcidzIGJlaGFsZiIsCiAgICAgICJldmVudCI6ICJhcHByb3ZhbF9ldmVudCIsCiAgICAgICJiaW5kaW5ncyI6IFsKICAgICAgICB7CiAgICAgICAgICAibmFtZSI6ICJvd25lciIsCiAgICAgICAgICAidHlwZSI6ICJzdHJpbmciLAogICAgICAgICAgImtleXMiOiBbCiAgICAgICAgICAgICJvd25lciIKICAgICAgICAgIF0sCiAgICAgICAgICAicGxhY2UiOiAiYWxsb3dhbmNlcyIKICAgICAgICB9LAogICAgICAgIHsKICAgICAgICAgICJuYW1lIjogInNwZW5kZXIiLAogICAgICAgICAgInR5cGUiOiAic3RyaW5nIiwKICAgICAgICAgICJrZXlzIjogWwogICAgICAgICAgICAic3BlbmRlciIKICAgICAgICAgIF0sCiAgICAgICAgICAicGxhY2UiOiAiYWxsb3dhbmNlcyIKICAgICAgICB9LAogICAgICAgIHsKICAgICAgICAgICJuYW1lIjogImFtb3VudCIsCiAgICAgICAgICAidHlwZSI6ICJpbnQ2NCIsCiAgICAgICAgICAidmFsdWUiOiB0cnVlCiAgICAgICAgfQogICAgICBdLAogICAgICAiZmllbGRzIjogWwogICAgICAgIHsKICAgICAgICAgICJuYW1lIjogIm93bmVyIiwKICAgICAgICAgICJsYWJlbCI6ICJPd25lciBBZGRyZXNzIiwKICAgICAgICAgICJ0eXBlIjogImFkZHJlc3MiLAogICAgICAgICAgInJlcXVpcmVkIjogdHJ1ZSwKICAgICAgICAgICJhdXRvRmlsbCI6ICJ3YWxsZXQiLAogICAgICAgICAgInBsYWNlaG9sZGVyIjogIlRva2VuIG93bmVyIgogICAgICAgIH0sCiAgICAgICAgewogICAgICAgICAgIm5hbWUiOiAic3BlbmRlciIsCiAgICAgICAgICAibGFiZWwiOiAiU3BlbmRlciBBZGRyZXNzIiwKICAgICAgICAgICJ0eXBlIjogImFkZHJlc3MiLAogICAgICAgICAgInJlcXVpcmVkIjogdHJ1ZSwKICAgICAgICAgICJwbGFjZWhvbGRlciI6ICJBZGRyZXNzIHRvIGFwcHJvdmUiCiAgICAgICAgfSwKICAgICAgICB7CiAgICAgICAgICAibmFtZSI6ICJhbW91bnQiLAogICAgICAgICAgImxhYmVsIjogIkFsbG93YW5jZSBBbW91bnQiLAogICAgICAgICAgInR5cGUiOiAiYW1vdW50IiwKICAgICAgICAgICJyZXF1aXJlZCI6IHRydWUsCiAgICAgICAgICAicGxhY2Vob2xkZXIiOiAiQW1vdW50IHRvIGFwcHJvdmUiCiAgICAgICAgfQogICAgICBdLAogICAgICAiaHR0cF9tZXRob2QiOiAiUE9TVCIsCiAgICAgICJodHRwX3BhdGgiOiAiL2FwaS9hcHByb3ZlIiwKICAgICAgImV2ZW50X3R5cGUiOiAiQXBwcm92ZWVkIgogICAgfSwKICAgIHsKICAgICAgImlkIjogInRyYW5zZmVyX2Zyb20iLAogICAgICAiZGVzY3JpcHRpb24iOiAiVHJhbnNmZXIgdG9rZW5zIHVzaW5nIGFsbG93YW5jZSAoZGVsZWdhdGVkIHRyYW5zZmVyKSIsCiAgICAgICJndWFyZCI6ICJiYWxhbmNlc1tmcm9tXSBcdTAwM2U9IGFtb3VudCBcdTAwMjZcdTAwMjYgYWxsb3dhbmNlc1tmcm9tXVtjYWxsZXJdIFx1MDAzZT0gYW1vdW50IiwKICAgICAgImV2ZW50IjogInRyYW5zZmVyX2Zyb21fZXZlbnQiLAogICAgICAiYmluZGluZ3MiOiBbCiAgICAgICAgewogICAgICAgICAgIm5hbWUiOiAiZnJvbSIsCiAgICAgICAgICAidHlwZSI6ICJzdHJpbmciLAogICAgICAgICAgImtleXMiOiBbCiAgICAgICAgICAgICJmcm9tIgogICAgICAgICAgXSwKICAgICAgICAgICJwbGFjZSI6ICJiYWxhbmNlcyIKICAgICAgICB9LAogICAgICAgIHsKICAgICAgICAgICJuYW1lIjogInRvIiwKICAgICAgICAgICJ0eXBlIjogInN0cmluZyIsCiAgICAgICAgICAia2V5cyI6IFsKICAgICAgICAgICAgInRvIgogICAgICAgICAgXSwKICAgICAgICAgICJwbGFjZSI6ICJiYWxhbmNlcyIKICAgICAgICB9LAogICAgICAgIHsKICAgICAgICAgICJuYW1lIjogImNhbGxlciIsCiAgICAgICAgICAidHlwZSI6ICJzdHJpbmciLAogICAgICAgICAgImtleXMiOiBbCiAgICAgICAgICAgICJjYWxsZXIiCiAgICAgICAgICBdLAogICAgICAgICAgInBsYWNlIjogImFsbG93YW5jZXMiCiAgICAgICAgfSwKICAgICAgICB7CiAgICAgICAgICAibmFtZSI6ICJhbW91bnQiLAogICAgICAgICAgInR5cGUiOiAiaW50NjQiLAogICAgICAgICAgInZhbHVlIjogdHJ1ZQogICAgICAgIH0KICAgICAgXSwKICAgICAgImZpZWxkcyI6IFsKICAgICAgICB7CiAgICAgICAgICAibmFtZSI6ICJmcm9tIiwKICAgICAgICAgICJsYWJlbCI6ICJGcm9tIEFkZHJlc3MiLAogICAgICAgICAgInR5cGUiOiAiYWRkcmVzcyIsCiAgICAgICAgICAicmVxdWlyZWQiOiB0cnVlLAogICAgICAgICAgInBsYWNlaG9sZGVyIjogIk93bmVyIGFkZHJlc3MiCiAgICAgICAgfSwKICAgICAgICB7CiAgICAgICAgICAibmFtZSI6ICJ0byIsCiAgICAgICAgICAibGFiZWwiOiAiVG8gQWRkcmVzcyIsCiAgICAgICAgICAidHlwZSI6ICJhZGRyZXNzIiwKICAgICAgICAgICJyZXF1aXJlZCI6IHRydWUsCiAgICAgICAgICAicGxhY2Vob2xkZXIiOiAiUmVjaXBpZW50IGFkZHJlc3MiCiAgICAgICAgfSwKICAgICAgICB7CiAgICAgICAgICAibmFtZSI6ICJjYWxsZXIiLAogICAgICAgICAgImxhYmVsIjogIkNhbGxlciBBZGRyZXNzIiwKICAgICAgICAgICJ0eXBlIjogImFkZHJlc3MiLAogICAgICAgICAgInJlcXVpcmVkIjogdHJ1ZSwKICAgICAgICAgICJhdXRvRmlsbCI6ICJ3YWxsZXQiLAogICAgICAgICAgInBsYWNlaG9sZGVyIjogIllvdXIgYWRkcmVzcyAobXVzdCBoYXZlIGFsbG93YW5jZSkiCiAgICAgICAgfSwKICAgICAgICB7CiAgICAgICAgICAibmFtZSI6ICJhbW91bnQiLAogICAgICAgICAgImxhYmVsIjogIkFtb3VudCIsCiAgICAgICAgICAidHlwZSI6ICJhbW91bnQiLAogICAgICAgICAgInJlcXVpcmVkIjogdHJ1ZSwKICAgICAgICAgICJwbGFjZWhvbGRlciI6ICJBbW91bnQgdG8gdHJhbnNmZXIiCiAgICAgICAgfQogICAgICBdLAogICAgICAiaHR0cF9tZXRob2QiOiAiUE9TVCIsCiAgICAgICJodHRwX3BhdGgiOiAiL2FwaS90cmFuc2Zlcl9mcm9tIiwKICAgICAgImV2ZW50X3R5cGUiOiAiVHJhbnNmZXJGcm9tZWQiCiAgICB9LAogICAgewogICAgICAiaWQiOiAibWludCIsCiAgICAgICJkZXNjcmlwdGlvbiI6ICJDcmVhdGUgbmV3IHRva2VucyBhbmQgYWRkIHRvIHJlY2lwaWVudCBiYWxhbmNlIiwKICAgICAgImV2ZW50IjogIm1pbnRfZXZlbnQiLAogICAgICAiYmluZGluZ3MiOiBbCiAgICAgICAgewogICAgICAgICAgIm5hbWUiOiAidG8iLAogICAgICAgICAgInR5cGUiOiAic3RyaW5nIiwKICAgICAgICAgICJrZXlzIjogWwogICAgICAgICAgICAidG8iCiAgICAgICAgICBdLAogICAgICAgICAgInBsYWNlIjogImJhbGFuY2VzIgogICAgICAgIH0sCiAgICAgICAgewogICAgICAgICAgIm5hbWUiOiAiYW1vdW50IiwKICAgICAgICAgICJ0eXBlIjogImludDY0IiwKICAgICAgICAgICJ2YWx1ZSI6IHRydWUKICAgICAgICB9CiAgICAgIF0sCiAgICAgICJmaWVsZHMiOiBbCiAgICAgICAgewogICAgICAgICAgIm5hbWUiOiAidG8iLAogICAgICAgICAgImxhYmVsIjogIlJlY2lwaWVudCBBZGRyZXNzIiwKICAgICAgICAgICJ0eXBlIjogImFkZHJlc3MiLAogICAgICAgICAgInJlcXVpcmVkIjogdHJ1ZSwKICAgICAgICAgICJwbGFjZWhvbGRlciI6ICJBZGRyZXNzIHRvIG1pbnQgdG8iCiAgICAgICAgfSwKICAgICAgICB7CiAgICAgICAgICAibmFtZSI6ICJhbW91bnQiLAogICAgICAgICAgImxhYmVsIjogIkFtb3VudCIsCiAgICAgICAgICAidHlwZSI6ICJhbW91bnQiLAogICAgICAgICAgInJlcXVpcmVkIjogdHJ1ZSwKICAgICAgICAgICJwbGFjZWhvbGRlciI6ICJBbW91bnQgdG8gbWludCIKICAgICAgICB9CiAgICAgIF0sCiAgICAgICJodHRwX21ldGhvZCI6ICJQT1NUIiwKICAgICAgImh0dHBfcGF0aCI6ICIvYXBpL21pbnQiLAogICAgICAiZXZlbnRfdHlwZSI6ICJNaW50ZWQiCiAgICB9LAogICAgewogICAgICAiaWQiOiAiYnVybiIsCiAgICAgICJkZXNjcmlwdGlvbiI6ICJEZXN0cm95IHRva2VucyBmcm9tIGhvbGRlcidzIGJhbGFuY2UiLAogICAgICAiZ3VhcmQiOiAiYmFsYW5jZXNbZnJvbV0gXHUwMDNlPSBhbW91bnQiLAogICAgICAiZXZlbnQiOiAiYnVybl9ldmVudCIsCiAgICAgICJiaW5kaW5ncyI6IFsKICAgICAgICB7CiAgICAgICAgICAibmFtZSI6ICJmcm9tIiwKICAgICAgICAgICJ0eXBlIjogInN0cmluZyIsCiAgICAgICAgICAia2V5cyI6IFsKICAgICAgICAgICAgImZyb20iCiAgICAgICAgICBdLAogICAgICAgICAgInBsYWNlIjogImJhbGFuY2VzIgogICAgICAgIH0sCiAgICAgICAgewogICAgICAgICAgIm5hbWUiOiAiYW1vdW50IiwKICAgICAgICAgICJ0eXBlIjogImludDY0IiwKICAgICAgICAgICJ2YWx1ZSI6IHRydWUKICAgICAgICB9CiAgICAgIF0sCiAgICAgICJmaWVsZHMiOiBbCiAgICAgICAgewogICAgICAgICAgIm5hbWUiOiAiZnJvbSIsCiAgICAgICAgICAibGFiZWwiOiAiRnJvbSBBZGRyZXNzIiwKICAgICAgICAgICJ0eXBlIjogImFkZHJlc3MiLAogICAgICAgICAgInJlcXVpcmVkIjogdHJ1ZSwKICAgICAgICAgICJhdXRvRmlsbCI6ICJ3YWxsZXQiLAogICAgICAgICAgInBsYWNlaG9sZGVyIjogIkFkZHJlc3MgdG8gYnVybiBmcm9tIgogICAgICAgIH0sCiAgICAgICAgewogICAgICAgICAgIm5hbWUiOiAiYW1vdW50IiwKICAgICAgICAgICJsYWJlbCI6ICJBbW91bnQiLAogICAgICAgICAgInR5cGUiOiAiYW1vdW50IiwKICAgICAgICAgICJyZXF1aXJlZCI6IHRydWUsCiAgICAgICAgICAicGxhY2Vob2xkZXIiOiAiQW1vdW50IHRvIGJ1cm4iCiAgICAgICAgfQogICAgICBdLAogICAgICAiaHR0cF9tZXRob2QiOiAiUE9TVCIsCiAgICAgICJodHRwX3BhdGgiOiAiL2FwaS9idXJuIiwKICAgICAgImV2ZW50X3R5cGUiOiAiQnVybmVkIgogICAgfQogIF0sCiAgImFyY3MiOiBbCiAgICB7CiAgICAgICJmcm9tIjogImJhbGFuY2VzIiwKICAgICAgInRvIjogInRyYW5zZmVyIiwKICAgICAgImtleXMiOiBbCiAgICAgICAgImZyb20iCiAgICAgIF0sCiAgICAgICJ2YWx1ZSI6ICJhbW91bnQiCiAgICB9LAogICAgewogICAgICAiZnJvbSI6ICJ0cmFuc2ZlciIsCiAgICAgICJ0byI6ICJiYWxhbmNlcyIsCiAgICAgICJrZXlzIjogWwogICAgICAgICJ0byIKICAgICAgXSwKICAgICAgInZhbHVlIjogImFtb3VudCIKICAgIH0sCiAgICB7CiAgICAgICJmcm9tIjogImFwcHJvdmUiLAogICAgICAidG8iOiAiYWxsb3dhbmNlcyIsCiAgICAgICJrZXlzIjogWwogICAgICAgICJvd25lciIsCiAgICAgICAgInNwZW5kZXIiCiAgICAgIF0sCiAgICAgICJ2YWx1ZSI6ICJhbW91bnQiCiAgICB9LAogICAgewogICAgICAiZnJvbSI6ICJiYWxhbmNlcyIsCiAgICAgICJ0byI6ICJ0cmFuc2Zlcl9mcm9tIiwKICAgICAgImtleXMiOiBbCiAgICAgICAgImZyb20iCiAgICAgIF0sCiAgICAgICJ2YWx1ZSI6ICJhbW91bnQiCiAgICB9LAogICAgewogICAgICAiZnJvbSI6ICJhbGxvd2FuY2VzIiwKICAgICAgInRvIjogInRyYW5zZmVyX2Zyb20iLAogICAgICAia2V5cyI6IFsKICAgICAgICAiZnJvbSIsCiAgICAgICAgImNhbGxlciIKICAgICAgXSwKICAgICAgInZhbHVlIjogImFtb3VudCIKICAgIH0sCiAgICB7CiAgICAgICJmcm9tIjogInRyYW5zZmVyX2Zyb20iLAogICAgICAidG8iOiAiYmFsYW5jZXMiLAogICAgICAia2V5cyI6IFsKICAgICAgICAidG8iCiAgICAgIF0sCiAgICAgICJ2YWx1ZSI6ICJhbW91bnQiCiAgICB9LAogICAgewogICAgICAiZnJvbSI6ICJtaW50IiwKICAgICAgInRvIjogImJhbGFuY2VzIiwKICAgICAgImtleXMiOiBbCiAgICAgICAgInRvIgogICAgICBdLAogICAgICAidmFsdWUiOiAiYW1vdW50IgogICAgfSwKICAgIHsKICAgICAgImZyb20iOiAibWludCIsCiAgICAgICJ0byI6ICJ0b3RhbF9zdXBwbHkiLAogICAgICAidmFsdWUiOiAiYW1vdW50IgogICAgfSwKICAgIHsKICAgICAgImZyb20iOiAiYmFsYW5jZXMiLAogICAgICAidG8iOiAiYnVybiIsCiAgICAgICJrZXlzIjogWwogICAgICAgICJmcm9tIgogICAgICBdLAogICAgICAidmFsdWUiOiAiYW1vdW50IgogICAgfSwKICAgIHsKICAgICAgImZyb20iOiAidG90YWxfc3VwcGx5IiwKICAgICAgInRvIjogImJ1cm4iLAogICAgICAidmFsdWUiOiAiYW1vdW50IgogICAgfQogIF0sCiAgImNvbnN0cmFpbnRzIjogWwogICAgewogICAgICAiaWQiOiAiY29uc2VydmF0aW9uIiwKICAgICAgImV4cHIiOiAic3VtKGJhbGFuY2VzKSA9PSB0b3RhbF9zdXBwbHkiCiAgICB9CiAgXSwKICAiZXZlbnRzIjogWwogICAgewogICAgICAiaWQiOiAidHJhbnNmZXJfZXZlbnQiLAogICAgICAibmFtZSI6ICJUcmFuc2ZlciIsCiAgICAgICJkZXNjcmlwdGlvbiI6ICJFbWl0dGVkIHdoZW4gdG9rZW5zIGFyZSB0cmFuc2ZlcnJlZCBkaXJlY3RseSIsCiAgICAgICJmaWVsZHMiOiBbCiAgICAgICAgewogICAgICAgICAgIm5hbWUiOiAiZnJvbSIsCiAgICAgICAgICAidHlwZSI6ICJzdHJpbmciLAogICAgICAgICAgInJlcXVpcmVkIjogdHJ1ZSwKICAgICAgICAgICJkZXNjcmlwdGlvbiI6ICJTZW5kZXIgYWRkcmVzcyIKICAgICAgICB9LAogICAgICAgIHsKICAgICAgICAgICJuYW1lIjogInRvIiwKICAgICAgICAgICJ0eXBlIjogInN0cmluZyIsCiAgICAgICAgICAicmVxdWlyZWQiOiB0cnVlLAogICAgICAgICAgImRlc2NyaXB0aW9uIjogIlJlY2lwaWVudCBhZGRyZXNzIgogICAgICAgIH0sCiAgICAgICAgewogICAgICAgICAgIm5hbWUiOiAiYW1vdW50IiwKICAgICAgICAgICJ0eXBlIjogImludGVnZXIiLAogICAgICAgICAgInJlcXVpcmVkIjogdHJ1ZSwKICAgICAgICAgICJkZXNjcmlwdGlvbiI6ICJBbW91bnQgdHJhbnNmZXJyZWQiCiAgICAgICAgfQogICAgICBdCiAgICB9LAogICAgewogICAgICAiaWQiOiAidHJhbnNmZXJfZnJvbV9ldmVudCIsCiAgICAgICJuYW1lIjogIlRyYW5zZmVyRnJvbSIsCiAgICAgICJkZXNjcmlwdGlvbiI6ICJFbWl0dGVkIHdoZW4gdG9rZW5zIGFyZSB0cmFuc2ZlcnJlZCB2aWEgYWxsb3dhbmNlIiwKICAgICAgImZpZWxkcyI6IFsKICAgICAgICB7CiAgICAgICAgICAibmFtZSI6ICJmcm9tIiwKICAgICAgICAgICJ0eXBlIjogInN0cmluZyIsCiAgICAgICAgICAicmVxdWlyZWQiOiB0cnVlLAogICAgICAgICAgImRlc2NyaXB0aW9uIjogIlNlbmRlciBhZGRyZXNzIgogICAgICAgIH0sCiAgICAgICAgewogICAgICAgICAgIm5hbWUiOiAidG8iLAogICAgICAgICAgInR5cGUiOiAic3RyaW5nIiwKICAgICAgICAgICJyZXF1aXJlZCI6IHRydWUsCiAgICAgICAgICAiZGVzY3JpcHRpb24iOiAiUmVjaXBpZW50IGFkZHJlc3MiCiAgICAgICAgfSwKICAgICAgICB7CiAgICAgICAgICAibmFtZSI6ICJjYWxsZXIiLAogICAgICAgICAgInR5cGUiOiAic3RyaW5nIiwKICAgICAgICAgICJyZXF1aXJlZCI6IHRydWUsCiAgICAgICAgICAiZGVzY3JpcHRpb24iOiAiQ2FsbGVyIHdobyBpbml0aWF0ZWQgdGhlIHRyYW5zZmVyIgogICAgICAgIH0sCiAgICAgICAgewogICAgICAgICAgIm5hbWUiOiAiYW1vdW50IiwKICAgICAgICAgICJ0eXBlIjogImludGVnZXIiLAogICAgICAgICAgInJlcXVpcmVkIjogdHJ1ZSwKICAgICAgICAgICJkZXNjcmlwdGlvbiI6ICJBbW91bnQgdHJhbnNmZXJyZWQiCiAgICAgICAgfQogICAgICBdCiAgICB9LAogICAgewogICAgICAiaWQiOiAiYXBwcm92YWxfZXZlbnQiLAogICAgICAibmFtZSI6ICJBcHByb3ZhbCIsCiAgICAgICJkZXNjcmlwdGlvbiI6ICJFbWl0dGVkIHdoZW4gc3BlbmRpbmcgYXBwcm92YWwgaXMgZ3JhbnRlZCIsCiAgICAgICJmaWVsZHMiOiBbCiAgICAgICAgewogICAgICAgICAgIm5hbWUiOiAib3duZXIiLAogICAgICAgICAgInR5cGUiOiAic3RyaW5nIiwKICAgICAgICAgICJyZXF1aXJlZCI6IHRydWUsCiAgICAgICAgICAiZGVzY3JpcHRpb24iOiAiVG9rZW4gb3duZXIgYWRkcmVzcyIKICAgICAgICB9LAogICAgICAgIHsKICAgICAgICAgICJuYW1lIjogInNwZW5kZXIiLAogICAgICAgICAgInR5cGUiOiAic3RyaW5nIiwKICAgICAgICAgICJyZXF1aXJlZCI6IHRydWUsCiAgICAgICAgICAiZGVzY3JpcHRpb24iOiAiQXBwcm92ZWQgc3BlbmRlciBhZGRyZXNzIgogICAgICAgIH0sCiAgICAgICAgewogICAgICAgICAgIm5hbWUiOiAiYW1vdW50IiwKICAgICAgICAgICJ0eXBlIjogImludGVnZXIiLAogICAgICAgICAgInJlcXVpcmVkIjogdHJ1ZSwKICAgICAgICAgICJkZXNjcmlwdGlvbiI6ICJBcHByb3ZlZCBhbW91bnQiCiAgICAgICAgfQogICAgICBdCiAgICB9LAogICAgewogICAgICAiaWQiOiAibWludF9ldmVudCIsCiAgICAgICJuYW1lIjogIk1pbnQiLAogICAgICAiZGVzY3JpcHRpb24iOiAiRW1pdHRlZCB3aGVuIG5ldyB0b2tlbnMgYXJlIGNyZWF0ZWQiLAogICAgICAiZmllbGRzIjogWwogICAgICAgIHsKICAgICAgICAgICJuYW1lIjogInRvIiwKICAgICAgICAgICJ0eXBlIjogInN0cmluZyIsCiAgICAgICAgICAicmVxdWlyZWQiOiB0cnVlLAogICAgICAgICAgImRlc2NyaXB0aW9uIjogIlJlY2lwaWVudCBhZGRyZXNzIgogICAgICAgIH0sCiAgICAgICAgewogICAgICAgICAgIm5hbWUiOiAiYW1vdW50IiwKICAgICAgICAgICJ0eXBlIjogImludGVnZXIiLAogICAgICAgICAgInJlcXVpcmVkIjogdHJ1ZSwKICAgICAgICAgICJkZXNjcmlwdGlvbiI6ICJBbW91bnQgbWludGVkIgogICAgICAgIH0KICAgICAgXQogICAgfSwKICAgIHsKICAgICAgImlkIjogImJ1cm5fZXZlbnQiLAogICAgICAibmFtZSI6ICJCdXJuIiwKICAgICAgImRlc2NyaXB0aW9uIjogIkVtaXR0ZWQgd2hlbiB0b2tlbnMgYXJlIGRlc3Ryb3llZCIsCiAgICAgICJmaWVsZHMiOiBbCiAgICAgICAgewogICAgICAgICAgIm5hbWUiOiAiZnJvbSIsCiAgICAgICAgICAidHlwZSI6ICJzdHJpbmciLAogICAgICAgICAgInJlcXVpcmVkIjogdHJ1ZSwKICAgICAgICAgICJkZXNjcmlwdGlvbiI6ICJBZGRyZXNzIGJ1cm5pbmcgdG9rZW5zIgogICAgICAgIH0sCiAgICAgICAgewogICAgICAgICAgIm5hbWUiOiAiYW1vdW50IiwKICAgICAgICAgICJ0eXBlIjogImludGVnZXIiLAogICAgICAgICAgInJlcXVpcmVkIjogdHJ1ZSwKICAgICAgICAgICJkZXNjcmlwdGlvbiI6ICJBbW91bnQgYnVybmVkIgogICAgICAgIH0KICAgICAgXQogICAgfQogIF0sCiAgInJvbGVzIjogWwogICAgewogICAgICAiaWQiOiAiYWRtaW4iLAogICAgICAibmFtZSI6ICJBZG1pbmlzdHJhdG9yIiwKICAgICAgImRlc2NyaXB0aW9uIjogIkNhbiBtaW50IGFuZCBidXJuIHRva2VucyIKICAgIH0sCiAgICB7CiAgICAgICJpZCI6ICJob2xkZXIiLAogICAgICAibmFtZSI6ICJUb2tlbiBIb2xkZXIiLAogICAgICAiZGVzY3JpcHRpb24iOiAiQ2FuIHRyYW5zZmVyIGFuZCBhcHByb3ZlIHRva2VucyIsCiAgICAgICJkeW5hbWljR3JhbnQiOiAiYmFsYW5jZXNbdXNlci5sb2dpbl0gXHUwMDNlIDAiCiAgICB9CiAgXSwKICAiYWNjZXNzIjogWwogICAgewogICAgICAidHJhbnNpdGlvbiI6ICJtaW50IiwKICAgICAgInJvbGVzIjogWwogICAgICAgICJhZG1pbiIKICAgICAgXQogICAgfSwKICAgIHsKICAgICAgInRyYW5zaXRpb24iOiAiYnVybiIsCiAgICAgICJyb2xlcyI6IFsKICAgICAgICAiYWRtaW4iCiAgICAgIF0KICAgIH0sCiAgICB7CiAgICAgICJ0cmFuc2l0aW9uIjogInRyYW5zZmVyIiwKICAgICAgInJvbGVzIjogWwogICAgICAgICJob2xkZXIiLAogICAgICAgICJhZG1pbiIKICAgICAgXQogICAgfSwKICAgIHsKICAgICAgInRyYW5zaXRpb24iOiAiYXBwcm92ZSIsCiAgICAgICJyb2xlcyI6IFsKICAgICAgICAiaG9sZGVyIiwKICAgICAgICAiYWRtaW4iCiAgICAgIF0KICAgIH0sCiAgICB7CiAgICAgICJ0cmFuc2l0aW9uIjogInRyYW5zZmVyX2Zyb20iLAogICAgICAicm9sZXMiOiBbCiAgICAgICAgImhvbGRlciIsCiAgICAgICAgImFkbWluIgogICAgICBdCiAgICB9CiAgXSwKICAidmlld3MiOiBbCiAgICB7CiAgICAgICJpZCI6ICJ0b2tlbi1kYXNoYm9hcmQiLAogICAgICAibmFtZSI6ICJUb2tlbiBEYXNoYm9hcmQiLAogICAgICAia2luZCI6ICJjYXJkIiwKICAgICAgImRlc2NyaXB0aW9uIjogIk92ZXJ2aWV3IG9mIHRva2VuIHN0YXRlIiwKICAgICAgImdyb3VwcyI6IFsKICAgICAgICB7CiAgICAgICAgICAiaWQiOiAic3VwcGx5IiwKICAgICAgICAgICJuYW1lIjogIlRva2VuIFN1cHBseSIsCiAgICAgICAgICAiZmllbGRzIjogWwogICAgICAgICAgICB7CiAgICAgICAgICAgICAgImJpbmRpbmciOiAidG90YWxfc3VwcGx5IiwKICAgICAgICAgICAgICAibGFiZWwiOiAiVG90YWwgU3VwcGx5IiwKICAgICAgICAgICAgICAidHlwZSI6ICJudW1iZXIiLAogICAgICAgICAgICAgICJyZWFkb25seSI6IHRydWUKICAgICAgICAgICAgfQogICAgICAgICAgXQogICAgICAgIH0KICAgICAgXSwKICAgICAgImFjdGlvbnMiOiBbCiAgICAgICAgIm1pbnQiLAogICAgICAgICJidXJuIgogICAgICBdCiAgICB9LAogICAgewogICAgICAiaWQiOiAidHJhbnNmZXItZm9ybSIsCiAgICAgICJuYW1lIjogIlRyYW5zZmVyIFRva2VucyIsCiAgICAgICJraW5kIjogImZvcm0iLAogICAgICAiZGVzY3JpcHRpb24iOiAiVHJhbnNmZXIgdG9rZW5zIHRvIGFub3RoZXIgYWRkcmVzcyIsCiAgICAgICJncm91cHMiOiBbCiAgICAgICAgewogICAgICAgICAgImlkIjogInRyYW5zZmVyLWRldGFpbHMiLAogICAgICAgICAgIm5hbWUiOiAiVHJhbnNmZXIgRGV0YWlscyIsCiAgICAgICAgICAiZmllbGRzIjogWwogICAgICAgICAgICB7CiAgICAgICAgICAgICAgImJpbmRpbmciOiAiZnJvbSIsCiAgICAgICAgICAgICAgImxhYmVsIjogIkZyb20gQWRkcmVzcyIsCiAgICAgICAgICAgICAgInR5cGUiOiAidGV4dCIsCiAgICAgICAgICAgICAgInJlcXVpcmVkIjogdHJ1ZQogICAgICAgICAgICB9LAogICAgICAgICAgICB7CiAgICAgICAgICAgICAgImJpbmRpbmciOiAidG8iLAogICAgICAgICAgICAgICJsYWJlbCI6ICJUbyBBZGRyZXNzIiwKICAgICAgICAgICAgICAidHlwZSI6ICJ0ZXh0IiwKICAgICAgICAgICAgICAicmVxdWlyZWQiOiB0cnVlCiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIHsKICAgICAgICAgICAgICAiYmluZGluZyI6ICJhbW91bnQiLAogICAgICAgICAgICAgICJsYWJlbCI6ICJBbW91bnQiLAogICAgICAgICAgICAgICJ0eXBlIjogIm51bWJlciIsCiAgICAgICAgICAgICAgInJlcXVpcmVkIjogdHJ1ZQogICAgICAgICAgICB9CiAgICAgICAgICBdCiAgICAgICAgfQogICAgICBdLAogICAgICAiYWN0aW9ucyI6IFsKICAgICAgICAidHJhbnNmZXIiCiAgICAgIF0KICAgIH0sCiAgICB7CiAgICAgICJpZCI6ICJhcHByb3ZlLWZvcm0iLAogICAgICAibmFtZSI6ICJBcHByb3ZlIFNwZW5kaW5nIiwKICAgICAgImtpbmQiOiAiZm9ybSIsCiAgICAgICJkZXNjcmlwdGlvbiI6ICJBcHByb3ZlIGFub3RoZXIgYWRkcmVzcyB0byBzcGVuZCB0b2tlbnMiLAogICAgICAiZ3JvdXBzIjogWwogICAgICAgIHsKICAgICAgICAgICJpZCI6ICJhcHByb3ZhbC1kZXRhaWxzIiwKICAgICAgICAgICJuYW1lIjogIkFwcHJvdmFsIERldGFpbHMiLAogICAgICAgICAgImZpZWxkcyI6IFsKICAgICAgICAgICAgewogICAgICAgICAgICAgICJiaW5kaW5nIjogIm93bmVyIiwKICAgICAgICAgICAgICAibGFiZWwiOiAiT3duZXIgQWRkcmVzcyIsCiAgICAgICAgICAgICAgInR5cGUiOiAidGV4dCIsCiAgICAgICAgICAgICAgInJlcXVpcmVkIjogdHJ1ZQogICAgICAgICAgICB9LAogICAgICAgICAgICB7CiAgICAgICAgICAgICAgImJpbmRpbmciOiAic3BlbmRlciIsCiAgICAgICAgICAgICAgImxhYmVsIjogIlNwZW5kZXIgQWRkcmVzcyIsCiAgICAgICAgICAgICAgInR5cGUiOiAidGV4dCIsCiAgICAgICAgICAgICAgInJlcXVpcmVkIjogdHJ1ZQogICAgICAgICAgICB9LAogICAgICAgICAgICB7CiAgICAgICAgICAgICAgImJpbmRpbmciOiAiYW1vdW50IiwKICAgICAgICAgICAgICAibGFiZWwiOiAiQWxsb3dhbmNlIEFtb3VudCIsCiAgICAgICAgICAgICAgInR5cGUiOiAibnVtYmVyIiwKICAgICAgICAgICAgICAicmVxdWlyZWQiOiB0cnVlCiAgICAgICAgICAgIH0KICAgICAgICAgIF0KICAgICAgICB9CiAgICAgIF0sCiAgICAgICJhY3Rpb25zIjogWwogICAgICAgICJhcHByb3ZlIgogICAgICBdCiAgICB9CiAgXSwKICAibmF2aWdhdGlvbiI6IHsKICAgICJicmFuZCI6ICJFUkMtMjAgVG9rZW4iLAogICAgIml0ZW1zIjogWwogICAgICB7CiAgICAgICAgImxhYmVsIjogIkFkbWluIiwKICAgICAgICAicGF0aCI6ICIvYWRtaW4iLAogICAgICAgICJpY29uIjogIuKame+4jyIsCiAgICAgICAgInJvbGVzIjogWwogICAgICAgICAgImFkbWluIgogICAgICAgIF0KICAgICAgfQogICAgXQogIH0sCiAgImFkbWluIjogewogICAgImVuYWJsZWQiOiB0cnVlLAogICAgInBhdGgiOiAiL2FkbWluIiwKICAgICJyb2xlcyI6IFsKICAgICAgImFkbWluIgogICAgXSwKICAgICJmZWF0dXJlcyI6IFsKICAgICAgImxpc3QiLAogICAgICAiZGV0YWlsIiwKICAgICAgImhpc3RvcnkiCiAgICBdCiAgfSwKICAiZXZlbnRTb3VyY2luZyI6IHsKICAgICJzbmFwc2hvdHMiOiB7CiAgICAgICJlbmFibGVkIjogdHJ1ZSwKICAgICAgImZyZXF1ZW5jeSI6IDEwMAogICAgfQogIH0sCiAgImRlYnVnIjogewogICAgImVuYWJsZWQiOiB0cnVlLAogICAgImV2YWwiOiB0cnVlCiAgfSwKICAiZ3JhcGhxbCI6IHsKICAgICJlbmFibGVkIjogdHJ1ZSwKICAgICJwbGF5Z3JvdW5kIjogdHJ1ZQogIH0sCiAgImRlY2ltYWxzIjogMTgsCiAgInVuaXQiOiAiRVRIIiwKICAid2FsbGV0IjogewogICAgImVuYWJsZWQiOiB0cnVlLAogICAgImFjY291bnRzIjogWwogICAgICB7CiAgICAgICAgImFkZHJlc3MiOiAiMHhmMzlGZDZlNTFhYWQ4OEY2RjRjZTZhQjg4MjcyNzljZmZGYjkyMjY2IiwKICAgICAgICAibmFtZSI6ICJBbGljZSAoQWRtaW4pIiwKICAgICAgICAicm9sZXMiOiBbCiAgICAgICAgICAiYWRtaW4iLAogICAgICAgICAgImhvbGRlciIKICAgICAgICBdLAogICAgICAgICJpbml0aWFsQmFsYW5jZSI6ICIxMDAwMCIKICAgICAgfSwKICAgICAgewogICAgICAgICJhZGRyZXNzIjogIjB4NzA5OTc5NzBDNTE4MTJkYzNBMDEwQzdkMDFiNTBlMGQxN2RjNzlDOCIsCiAgICAgICAgIm5hbWUiOiAiQm9iIChIb2xkZXIpIiwKICAgICAgICAicm9sZXMiOiBbCiAgICAgICAgICAiaG9sZGVyIgogICAgICAgIF0sCiAgICAgICAgImluaXRpYWxCYWxhbmNlIjogIjEwMDAiCiAgICAgIH0sCiAgICAgIHsKICAgICAgICAiYWRkcmVzcyI6ICIweDNDNDRDZERkQjZhOTAwZmEyYjU4NWRkMjk5ZTAzZDEyRkE0MjkzQkMiLAogICAgICAgICJuYW1lIjogIkNoYXJsaWUgKEhvbGRlcikiLAogICAgICAgICJyb2xlcyI6IFsKICAgICAgICAgICJob2xkZXIiCiAgICAgICAgXSwKICAgICAgICAiaW5pdGlhbEJhbGFuY2UiOiAiNTAwIgogICAgICB9LAogICAgICB7CiAgICAgICAgImFkZHJlc3MiOiAiMHg5MEY3OWJmNkVCMmM0Zjg3MDM2NUU3ODU5ODJFMWYxMDFFOTNiOTA2IiwKICAgICAgICAibmFtZSI6ICJEYXZlIChPYnNlcnZlcikiLAogICAgICAgICJpbml0aWFsQmFsYW5jZSI6ICIwIgogICAgICB9CiAgICBdLAogICAgImJhbGFuY2VGaWVsZCI6ICJiYWxhbmNlcyIsCiAgICAic2hvd0luTmF2IjogdHJ1ZSwKICAgICJhdXRvQ29ubmVjdCI6IHRydWUKICB9Cn0="

	return func(w http.ResponseWriter, r *http.Request) {
		schemaJSON, err := base64.StdEncoding.DecodeString(schemaBase64)
		if err != nil {
			api.Error(w, http.StatusInternalServerError, "schema_decode_error", "Failed to decode schema")
			return
		}
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusOK)
		w.Write(schemaJSON)
	}
}

