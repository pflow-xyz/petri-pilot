// Code generated by petri-pilot. DO NOT EDIT.

package erc20token

import (
	"context"
	"encoding/json"
	"net/http"

	"github.com/pflow-xyz/petri-pilot/generated/erc20token/graph"
	"github.com/pflow-xyz/petri-pilot/pkg/runtime/eventstore"
)

// GraphQLConfig holds the GraphQL server configuration.
var GraphQLConfig = struct {
	Path       string
	Playground bool
}{
	Path:       "/graphql",
	Playground: true,
}

// GraphQLHandler creates the GraphQL HTTP handler.
func GraphQLHandler(app *Application) http.HandlerFunc {
	resolver := graph.NewResolver(&graphQLApp{app: app})
	h := &graphQLHandler{resolver: resolver}
	return h.ServeHTTP
}

// PlaygroundHandler serves the GraphQL Playground UI.
func PlaygroundHandler() http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "text/html; charset=utf-8")
		w.Write([]byte(playgroundHTML))
	}
}

var playgroundHTML = "<!DOCTYPE html>\n" +
	"<html>\n" +
	"<head>\n" +
	"  <title>erc20-token GraphQL Playground</title>\n" +
	"  <link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/graphql-playground-react/build/static/css/index.css\" />\n" +
	"  <link rel=\"shortcut icon\" href=\"https://cdn.jsdelivr.net/npm/graphql-playground-react/build/favicon.png\" />\n" +
	"  <script src=\"https://cdn.jsdelivr.net/npm/graphql-playground-react/build/static/js/middleware.js\"></script>\n" +
	"</head>\n" +
	"<body>\n" +
	"  <div id=\"root\"></div>\n" +
	"  <script>\n" +
	"    window.addEventListener('load', function() {\n" +
	"      GraphQLPlayground.init(document.getElementById('root'), {\n" +
	"        endpoint: '/graphql',\n" +
	"        settings: {\n" +
	"          'editor.theme': 'dark',\n" +
	"          'editor.fontFamily': \"'Source Code Pro', 'Consolas', 'Inconsolata', 'Droid Sans Mono', 'Monaco', monospace\",\n" +
	"          'editor.fontSize': 14,\n" +
	"          'request.credentials': 'same-origin'\n" +
	"        }\n" +
	"      })\n" +
	"    })\n" +
	"  </script>\n" +
	"</body>\n" +
	"</html>\n"


// graphQLApp wraps Application to implement the resolver interface.
type graphQLApp struct {
	app *Application
}

func (a *graphQLApp) Create(ctx context.Context) (string, error) {
	return a.app.Create(ctx)
}

func (a *graphQLApp) Load(ctx context.Context, id string) (graph.Aggregate, error) {
	return a.app.Load(ctx, id)
}

func (a *graphQLApp) GetState(ctx context.Context, id string) (graph.Aggregate, error) {
	return a.app.GetState(ctx, id)
}

func (a *graphQLApp) Execute(ctx context.Context, id, transition string, data map[string]any) (graph.Aggregate, error) {
	return a.app.Execute(ctx, id, transition, data)
}

func (a *graphQLApp) HealthCheck(ctx context.Context) error {
	return a.app.HealthCheck(ctx)
}

func (a *graphQLApp) GetStore() eventstore.Store {
	return a.app.store
}


// graphQLHandler implements a simple GraphQL HTTP handler.
type graphQLHandler struct {
	resolver *graph.Resolver
}

func (h *graphQLHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	var req struct {
		Query         string                 `json:"query"`
		OperationName string                 `json:"operationName"`
		Variables     map[string]interface{} `json:"variables"`
	}

	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}

	// Execute the GraphQL operation
	result := h.executeGraphQL(r.Context(), req.Query, req.OperationName, req.Variables)

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(result)
}

func (h *graphQLHandler) executeGraphQL(ctx context.Context, query, operationName string, variables map[string]interface{}) map[string]interface{} {
	// This is a simplified GraphQL executor
	// In production, use github.com/99designs/gqlgen for full spec compliance

	result := make(map[string]interface{})
	data := make(map[string]interface{})
	var errors []map[string]interface{}

	// Detect mutation vs query
	isMutation := containsString(query, "mutation")

	// Handle create mutation
	if isMutation && containsString(query, "createErc20Token") {
		state, err := h.resolver.CreateErc20Token(ctx)
		if err != nil {
			errors = append(errors, map[string]interface{}{"message": err.Error()})
		} else {
			data["createErc20Token"] = state
		}
	}

	// Handle transition mutations

	if isMutation && containsString(query, "transfer") {
		input := graph.TransferInput{}
		if vars, ok := variables["input"].(map[string]interface{}); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
			if v, ok := vars["from"]; ok {
				switch val := v.(type) {
				case string:
					input.From = &val
				}
			}
			if v, ok := vars["to"]; ok {
				switch val := v.(type) {
				case string:
					input.To = &val
				}
			}
			if v, ok := vars["amount"]; ok {
				switch val := v.(type) {
				case float64:
					i := int64(val)
					input.Amount = &i
				}
			}
		}
		res, err := h.resolver.Transfer(ctx, input)
		if err != nil {
			errors = append(errors, map[string]interface{}{"message": err.Error()})
		} else {
			data["transfer"] = res
		}
	}

	if isMutation && containsString(query, "approve") {
		input := graph.ApproveInput{}
		if vars, ok := variables["input"].(map[string]interface{}); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
			if v, ok := vars["owner"]; ok {
				switch val := v.(type) {
				case string:
					input.Owner = &val
				}
			}
			if v, ok := vars["spender"]; ok {
				switch val := v.(type) {
				case string:
					input.Spender = &val
				}
			}
			if v, ok := vars["amount"]; ok {
				switch val := v.(type) {
				case float64:
					i := int64(val)
					input.Amount = &i
				}
			}
		}
		res, err := h.resolver.Approve(ctx, input)
		if err != nil {
			errors = append(errors, map[string]interface{}{"message": err.Error()})
		} else {
			data["approve"] = res
		}
	}

	if isMutation && containsString(query, "transferFrom") {
		input := graph.TransferFromInput{}
		if vars, ok := variables["input"].(map[string]interface{}); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
			if v, ok := vars["from"]; ok {
				switch val := v.(type) {
				case string:
					input.From = &val
				}
			}
			if v, ok := vars["to"]; ok {
				switch val := v.(type) {
				case string:
					input.To = &val
				}
			}
			if v, ok := vars["caller"]; ok {
				switch val := v.(type) {
				case string:
					input.Caller = &val
				}
			}
			if v, ok := vars["amount"]; ok {
				switch val := v.(type) {
				case float64:
					i := int64(val)
					input.Amount = &i
				}
			}
		}
		res, err := h.resolver.TransferFrom(ctx, input)
		if err != nil {
			errors = append(errors, map[string]interface{}{"message": err.Error()})
		} else {
			data["transferFrom"] = res
		}
	}

	if isMutation && containsString(query, "mint") {
		input := graph.MintInput{}
		if vars, ok := variables["input"].(map[string]interface{}); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
			if v, ok := vars["to"]; ok {
				switch val := v.(type) {
				case string:
					input.To = &val
				}
			}
			if v, ok := vars["amount"]; ok {
				switch val := v.(type) {
				case float64:
					i := int64(val)
					input.Amount = &i
				}
			}
		}
		res, err := h.resolver.Mint(ctx, input)
		if err != nil {
			errors = append(errors, map[string]interface{}{"message": err.Error()})
		} else {
			data["mint"] = res
		}
	}

	if isMutation && containsString(query, "burn") {
		input := graph.BurnInput{}
		if vars, ok := variables["input"].(map[string]interface{}); ok {
			if id, ok := vars["aggregateId"].(string); ok {
				input.AggregateID = id
			}
			if v, ok := vars["from"]; ok {
				switch val := v.(type) {
				case string:
					input.From = &val
				}
			}
			if v, ok := vars["amount"]; ok {
				switch val := v.(type) {
				case float64:
					i := int64(val)
					input.Amount = &i
				}
			}
		}
		res, err := h.resolver.Burn(ctx, input)
		if err != nil {
			errors = append(errors, map[string]interface{}{"message": err.Error()})
		} else {
			data["burn"] = res
		}
	}


	// Handle query for single aggregate
	if !isMutation && containsString(query, "erc20token(") {
		id := ""
		if idVar, ok := variables["id"].(string); ok {
			id = idVar
		}
		if id != "" {
			state, err := h.resolver.Erc20Token(ctx, id)
			if err != nil {
				errors = append(errors, map[string]interface{}{"message": err.Error()})
			} else {
				data["erc20token"] = state
			}
		}
	}

	// Handle list query
	if !isMutation && containsString(query, "erc20tokenList") {
		var place *string
		var page, perPage *int
		if p, ok := variables["place"].(string); ok {
			place = &p
		}
		if p, ok := variables["page"].(float64); ok {
			pi := int(p)
			page = &pi
		}
		if p, ok := variables["perPage"].(float64); ok {
			pi := int(p)
			perPage = &pi
		}
		list, err := h.resolver.Erc20TokenList(ctx, place, page, perPage)
		if err != nil {
			errors = append(errors, map[string]interface{}{"message": err.Error()})
		} else {
			data["erc20tokenList"] = list
		}
	}

	// Handle admin stats query
	if !isMutation && containsString(query, "adminStats") {
		stats, err := h.resolver.AdminStats(ctx)
		if err != nil {
			errors = append(errors, map[string]interface{}{"message": err.Error()})
		} else {
			data["adminStats"] = stats
		}
	}


	// Handle events query
	if !isMutation && containsString(query, "events(") {
		aggID := ""
		var from *int
		if id, ok := variables["aggregateId"].(string); ok {
			aggID = id
		}
		if f, ok := variables["from"].(float64); ok {
			fi := int(f)
			from = &fi
		}
		if aggID != "" {
			events, err := h.resolver.Events(ctx, aggID, from)
			if err != nil {
				errors = append(errors, map[string]interface{}{"message": err.Error()})
			} else {
				data["events"] = events
			}
		}
	}


	result["data"] = data
	if len(errors) > 0 {
		result["errors"] = errors
	}

	return result
}

func containsString(s, substr string) bool {
	return len(s) >= len(substr) && (s == substr || len(s) > 0 && containsStringHelper(s, substr))
}

func containsStringHelper(s, substr string) bool {
	for i := 0; i <= len(s)-len(substr); i++ {
		if s[i:i+len(substr)] == substr {
			return true
		}
	}
	return false
}
