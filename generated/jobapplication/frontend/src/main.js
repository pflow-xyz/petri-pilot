// Generated by petri-pilot. DO NOT EDIT.

import { createNavigation, refreshNavigation } from './navigation.js'
import { navigate, initRouter, getRouteParams, getCurrentRoute } from './router.js'
import { loadViews, renderFormView, renderDetailView, renderTableView, getFormData } from './views.js'

// API client
const API_BASE = ''

// ============================================================================
// Token Amount Scaling
// ============================================================================
// Decimals: 0 (0 = no scaling)
// Unit: ""

const TOKEN_DECIMALS = 0
const TOKEN_UNIT = ""
const TOKEN_SCALE = TOKEN_DECIMALS > 0 ? Math.pow(10, TOKEN_DECIMALS) : 1

// Convert from smallest unit (wei) to display unit (ETH)
// e.g., "1000000000000000000" -> "1"
// Handles both string and number inputs
function toDisplayAmount(rawAmount) {
  if (TOKEN_DECIMALS === 0) return rawAmount
  if (rawAmount === null || rawAmount === undefined) return ''

  // Handle string amounts (may be very large)
  const str = String(rawAmount)
  if (str === '0') return '0'

  // Pad with leading zeros if needed
  const padded = str.padStart(TOKEN_DECIMALS + 1, '0')
  const intPart = padded.slice(0, -TOKEN_DECIMALS) || '0'
  const fracPart = padded.slice(-TOKEN_DECIMALS).replace(/0+$/, '')

  return fracPart ? `${intPart}.${fracPart}` : intPart
}

// Convert from display unit (ETH) to smallest unit (wei)
// e.g., 1.0 -> "1000000000000000000"
// Returns a STRING to avoid JavaScript number precision issues with large values
function toRawAmount(displayAmount) {
  if (TOKEN_DECIMALS === 0) return displayAmount
  if (displayAmount === null || displayAmount === undefined || displayAmount === '') return "0"

  const amount = typeof displayAmount === 'string' ? parseFloat(displayAmount) : displayAmount
  if (isNaN(amount)) return "0"

  // Use BigInt arithmetic to avoid precision loss
  const multiplier = BigInt(10 ** TOKEN_DECIMALS)
  const whole = BigInt(Math.floor(amount))
  const frac = amount - Math.floor(amount)
  const fracWei = BigInt(Math.round(frac * Number(multiplier)))
  return String(whole * multiplier + fracWei)
}

// Format amount for display with unit
function formatAmount(rawAmount) {
  const display = toDisplayAmount(rawAmount)
  if (TOKEN_UNIT) {
    return `${display} ${TOKEN_UNIT}`
  }
  return display.toString()
}

// Check if a field name represents a token amount (should be scaled)
function isAmountField(fieldName) {
  const amountFields = ['amount', 'value', 'balance', 'total_supply', 'allowance']
  return amountFields.some(f => fieldName.toLowerCase().includes(f))
}

// Scale form data for API submission
function scaleFormData(data) {
  if (TOKEN_DECIMALS === 0) return data
  const scaled = { ...data }
  for (const [key, value] of Object.entries(scaled)) {
    if (isAmountField(key) && (typeof value === 'number' || !isNaN(parseFloat(value)))) {
      scaled[key] = toRawAmount(value)
    }
  }
  return scaled
}

// Check if value is a numeric amount (number or numeric string)
function isNumericAmount(value) {
  if (typeof value === 'number') return true
  if (typeof value === 'string' && /^\d+$/.test(value)) return true
  return false
}

// Unscale state data for display
function unscaleStateData(state) {
  if (TOKEN_DECIMALS === 0) return state
  const unscaled = { ...state }
  for (const [key, value] of Object.entries(unscaled)) {
    if (isAmountField(key)) {
      if (isNumericAmount(value)) {
        unscaled[key] = toDisplayAmount(value)
      } else if (typeof value === 'object' && value !== null) {
        // Handle maps like balances: { alice: 1000000000000000000 }
        // and nested maps like allowances: { owner: { spender: amount } }
        unscaled[key] = {}
        for (const [k, v] of Object.entries(value)) {
          if (isNumericAmount(v)) {
            unscaled[key][k] = toDisplayAmount(v)
          } else if (typeof v === 'object' && v !== null) {
            // Handle nested map (2 levels deep)
            unscaled[key][k] = {}
            for (const [k2, v2] of Object.entries(v)) {
              unscaled[key][k][k2] = isNumericAmount(v2) ? toDisplayAmount(v2) : v2
            }
          } else {
            unscaled[key][k] = v
          }
        }
      }
    }
  }
  return unscaled
}

// App state
let currentUser = null
let authToken = null
let instances = []
let currentInstance = null

// Transition definitions with fields (populated in renderInstanceDetail)
const TRANSITION_DEFS = [
  {
    id: 'start_screening',
    name: 'Start Screening',
    description: "Begin candidate screening",
    fields: [
    ]
  },
  {
    id: 'begin_checks',
    name: 'Begin Checks',
    description: "Start parallel phone screen and background check processes",
    fields: [
    ]
  },
  {
    id: 'schedule_phone_screen',
    name: 'Schedule Phone Screen',
    description: "Schedule phone screen",
    fields: [
    ]
  },
  {
    id: 'start_background_check',
    name: 'Start Background Check',
    description: "Initiate background check",
    fields: [
    ]
  },
  {
    id: 'complete_phone_screen',
    name: 'Complete Phone Screen',
    description: "Complete phone screen",
    fields: [
    ]
  },
  {
    id: 'complete_background_check',
    name: 'Complete Background Check',
    description: "Complete background check",
    fields: [
    ]
  },
  {
    id: 'advance_to_interview',
    name: 'Advance To Interview',
    description: "Both checks passed, advance to interview",
    fields: [
    ]
  },
  {
    id: 'conduct_interview',
    name: 'Conduct Interview',
    description: "Conduct interview",
    fields: [
    ]
  },
  {
    id: 'extend_offer',
    name: 'Extend Offer',
    description: "Extend job offer",
    fields: [
    ]
  },
  {
    id: 'accept_offer',
    name: 'Accept Offer',
    description: "Candidate accepts offer",
    fields: [
    ]
  },
  {
    id: 'reject_after_screen',
    name: 'Reject After Screen',
    description: "Reject after screening",
    fields: [
    ]
  },
  {
    id: 'reject_after_interview',
    name: 'Reject After Interview',
    description: "Reject after interview",
    fields: [
    ]
  },
  {
    id: 'decline_offer',
    name: 'Decline Offer',
    description: "Candidate declines offer",
    fields: [
    ]
  },
]

// ============================================================================
// Auth
// ============================================================================

function loadAuth() {
  const stored = localStorage.getItem('auth')
  if (stored) {
    try {
      const auth = JSON.parse(stored)
      if (auth.expires_at && new Date(auth.expires_at) > new Date()) {
        authToken = auth.token
        currentUser = auth.user
        return true
      }
      localStorage.removeItem('auth')
    } catch (e) {
      localStorage.removeItem('auth')
    }
  }
  return false
}

function saveAuth(data) {
  localStorage.setItem('auth', JSON.stringify(data))
  authToken = data.token
  currentUser = data.user
  window.dispatchEvent(new CustomEvent('auth-change'))
}

function clearAuth() {
  localStorage.removeItem('auth')
  authToken = null
  currentUser = null
  window.dispatchEvent(new CustomEvent('auth-change'))
}

// Reload auth from localStorage (called when wallet module updates auth)
function reloadAuth() {
  const stored = localStorage.getItem('auth')
  if (stored) {
    try {
      const auth = JSON.parse(stored)
      authToken = auth.token
      currentUser = auth.user
      return true
    } catch (e) {
      return false
    }
  }
  authToken = null
  currentUser = null
  return false
}

// Listen for auth changes from wallet module
window.addEventListener('auth-change', () => {
  reloadAuth()
})

function getHeaders() {
  const headers = { 'Content-Type': 'application/json' }
  if (authToken) {
    headers['Authorization'] = `Bearer ${authToken}`
  }
  return headers
}

// ============================================================================
// API
// ============================================================================

async function handleResponse(response) {
  if (response.status === 401) {
    clearAuth()
    showError('Session expired. Please log in again.')
    throw new Error('Unauthorized')
  }
  if (!response.ok) {
    const error = await response.json().catch(() => ({}))
    throw new Error(error.message || response.statusText)
  }
  return response.json()
}

const api = {
  async getMe() {
    const response = await fetch(`${API_BASE}/auth/me`, { headers: getHeaders() })
    return handleResponse(response)
  },

  async logout() {
    await fetch(`${API_BASE}/auth/logout`, { method: 'POST', headers: getHeaders() })
    clearAuth()
  },

  async listInstances() {
    const response = await fetch(`${API_BASE}/admin/instances`, { headers: getHeaders() })
    return handleResponse(response)
  },

  async getInstance(id) {
    const response = await fetch(`${API_BASE}/api/jobapplication/${id}`, { headers: getHeaders() })
    return handleResponse(response)
  },

  async createInstance(data = {}) {
    const response = await fetch(`${API_BASE}/api/jobapplication`, {
      method: 'POST',
      headers: getHeaders(),
      body: JSON.stringify(data),
    })
    return handleResponse(response)
  },

  async executeTransition(transitionId, aggregateId, data = {}) {
    // Scale amount fields before sending to API
    const scaledData = scaleFormData(data)
    // Get the API path from transition definition, or fall back to default
    const transition = window.pilot?.getTransition?.(transitionId)
    let apiPath = transition?.apiPath || `/api/${transitionId}`
    // Substitute {id} placeholder with actual aggregate ID
    apiPath = apiPath.replace('{id}', aggregateId)
    const response = await fetch(`${API_BASE}${apiPath}`, {
      method: 'POST',
      headers: getHeaders(),
      body: JSON.stringify({ aggregate_id: aggregateId, data: scaledData }),
    })
    return handleResponse(response)
  },
}

// Export for global access
window.api = api

// Export current instance for debug wallet view
Object.defineProperty(window, 'currentInstance', {
  get: function() { return currentInstance }
})

// Export auth functions for testing
window.setAuthToken = function(token) {
  authToken = token
}
window.saveAuth = saveAuth
window.clearAuth = clearAuth

// ============================================================================
// UI Helpers
// ============================================================================

function showError(message) {
  const app = document.getElementById('app')
  const existing = app.querySelector('.alert-error')
  if (existing) existing.remove()

  const alert = document.createElement('div')
  alert.className = 'alert alert-error'
  alert.textContent = message
  app.insertBefore(alert, app.firstChild)

  setTimeout(() => alert.remove(), 5000)
}

function showSuccess(message) {
  const app = document.getElementById('app')
  const existing = app.querySelector('.alert-success')
  if (existing) existing.remove()

  const alert = document.createElement('div')
  alert.className = 'alert alert-success'
  alert.textContent = message
  app.insertBefore(alert, app.firstChild)

  setTimeout(() => alert.remove(), 3000)
}

// Get human-readable status from places
function getStatus(places) {
  if (!places) return 'unknown'
  for (const [place, tokens] of Object.entries(places)) {
    if (tokens > 0) return place
  }
  return 'unknown'
}

// Format status as badge
function formatStatus(status) {
  const statusClass = `badge-${status.toLowerCase().replace(/_/g, '-')}`
  return `<span class="badge ${statusClass}">${status.replace(/_/g, ' ')}</span>`
}

// ============================================================================
// Page Renderers
// ============================================================================

// List page - shows all instances
async function renderListPage() {
  const app = document.getElementById('app')
  app.innerHTML = `
    <div class="page">
      <div class="page-header">
        <h1>job-application</h1>
        <button class="btn btn-primary" onclick="handleCreateNew()">+ New</button>
      </div>
      <div id="instances-list" class="entity-list">
        <div class="loading">Loading...</div>
      </div>
    </div>
  `

  try {
    const result = await api.listInstances()
    instances = result.instances || []
    renderInstancesList()
  } catch (err) {
    document.getElementById('instances-list').innerHTML = `
      <div class="empty-state">
        <h3>No instances yet</h3>
        <p>Create your first instance to get started.</p>
        <button class="btn btn-primary" onclick="handleCreateNew()" style="margin-top: 1rem">+ Create New</button>
      </div>
    `
  }
}

function renderInstancesList() {
  const container = document.getElementById('instances-list')
  if (!container) return

  if (instances.length === 0) {
    container.innerHTML = `
      <div class="empty-state">
        <h3>No instances yet</h3>
        <p>Create your first instance to get started.</p>
        <button class="btn btn-primary" onclick="handleCreateNew()" style="margin-top: 1rem">+ Create New</button>
      </div>
    `
    return
  }

  container.innerHTML = instances.map(inst => {
    const status = getStatus(inst.state || inst.places)
    return `
      <div class="entity-card" onclick="navigate('/job-application/${inst.id}')">
        <div class="entity-info">
          <h3>${inst.id}</h3>
          <div class="entity-meta">
            ${formatStatus(status)} &middot; Version ${inst.version || 0}
          </div>
        </div>
        <div class="entity-actions">
          <button class="btn btn-sm btn-secondary" onclick="event.stopPropagation(); navigate('/job-application/${inst.id}')">
            View
          </button>
        </div>
      </div>
    `
  }).join('')
}

// Detail page - shows single instance with actions
async function renderDetailPage() {
  const params = getRouteParams()
  const id = params.id

  const app = document.getElementById('app')
  app.innerHTML = `
    <div class="page">
      <div class="page-header">
        <div>
          <button class="btn btn-link" onclick="navigate('/job-application')" style="margin-left: -0.5rem">
            &larr; Back to List
          </button>
          <h1 style="margin-top: 0.5rem">Instance: ${id}</h1>
        </div>
      </div>
      <div id="instance-detail">
        <div class="loading">Loading...</div>
      </div>
    </div>
  `

  try {
    const result = await api.getInstance(id)
    currentInstance = {
      id: result.aggregate_id || id,
      version: result.version,
      state: result.state,
      displayState: unscaleStateData(result.state), // Unscaled for display
      places: result.places,
      enabled: result.enabled || result.enabled_transitions || [],
    }
    // Store state for debug wallet view
    window.currentInstanceState = currentInstance.state
    renderInstanceDetail()
  } catch (err) {
    document.getElementById('instance-detail').innerHTML = `
      <div class="alert alert-error">Failed to load instance: ${err.message}</div>
    `
  }
}

function renderInstanceDetail() {
  const container = document.getElementById('instance-detail')
  if (!container || !currentInstance) return

  const status = getStatus(currentInstance.places)
  const enabled = currentInstance.enabled || []

  // Use global transition definitions
  const transitions = TRANSITION_DEFS

  container.innerHTML = `
    <div class="card">
      <div class="card-header">Status</div>
      <div class="detail-list">
        <div class="detail-field">
          <dt>ID</dt>
          <dd><code>${currentInstance.id}</code></dd>
        </div>
        <div class="detail-field">
          <dt>Status</dt>
          <dd>${formatStatus(status)}</dd>
        </div>
        <div class="detail-field">
          <dt>Version</dt>
          <dd>${currentInstance.version || 0}</dd>
        </div>
      </div>
    </div>

    <div class="card">
      <div class="card-header">Actions</div>
      <div class="view-actions">
        ${transitions.map(t => {
          const isEnabled = enabled.includes(t.id)
          return `
            <button
              class="btn ${isEnabled ? 'btn-primary' : 'btn-secondary'}"
              onclick="handleTransition('${t.id}')"
              ${isEnabled ? '' : 'disabled'}
              title="${t.description || t.name}"
            >
              ${t.name}
            </button>
          `
        }).join('')}
      </div>
      ${enabled.length === 0 ? '<p style="color: #666; margin-top: 1rem;">No actions available in current state.</p>' : ''}
    </div>

    <div class="card">
      <div class="card-header">Current State${TOKEN_UNIT ? ` (${TOKEN_UNIT})` : ''}</div>
      <div class="detail-list">
        ${renderStateDisplay(currentInstance.displayState || currentInstance.state)}
      </div>
    </div>
  `
}

// Render state data for display (handles nested objects like balances map)
function renderStateDisplay(state) {
  if (!state || Object.keys(state).length === 0) {
    return '<p style="color: #999;">No state data</p>'
  }

  return Object.entries(state).map(([key, value]) => {
    if (typeof value === 'object' && value !== null) {
      // Render nested object (like balances: { alice: 750, bob: 250 })
      // or doubly nested (like allowances: { owner: { spender: amount } })
      const entries = Object.entries(value)
      if (entries.length === 0) {
        return `
          <div class="detail-field">
            <dt>${formatFieldName(key)}</dt>
            <dd><span style="color: #999;">Empty</span></dd>
          </div>
        `
      }
      return `
        <div class="detail-field">
          <dt>${formatFieldName(key)}</dt>
          <dd>
            <div class="nested-state">
              ${entries.map(([k, v]) => {
                if (typeof v === 'object' && v !== null) {
                  // Handle nested map (2 levels deep, like allowances)
                  const innerEntries = Object.entries(v)
                  if (innerEntries.length === 0) {
                    return `
                      <div class="state-entry">
                        <span class="state-key">${k}</span>
                        <span class="state-value" style="color: #999;">Empty</span>
                      </div>
                    `
                  }
                  return `
                    <div class="state-entry nested-group">
                      <span class="state-key">${k}</span>
                      <div class="nested-state" style="margin-left: 1rem;">
                        ${innerEntries.map(([k2, v2]) => `
                          <div class="state-entry">
                            <span class="state-key">${k2}</span>
                            <span class="state-value">${formatStateValue(key, v2)}</span>
                          </div>
                        `).join('')}
                      </div>
                    </div>
                  `
                }
                return `
                  <div class="state-entry">
                    <span class="state-key">${k}</span>
                    <span class="state-value">${formatStateValue(key, v)}</span>
                  </div>
                `
              }).join('')}
            </div>
          </dd>
        </div>
      `
    }
    return `
      <div class="detail-field">
        <dt>${formatFieldName(key)}</dt>
        <dd>${formatStateValue(key, value)}</dd>
      </div>
    `
  }).join('')
}

// Format field name for display (e.g., "total_supply" -> "Total Supply")
function formatFieldName(name) {
  return name.replace(/_/g, ' ').replace(/\b\w/g, c => c.toUpperCase())
}

// Format state value with unit if applicable
function formatStateValue(fieldName, value) {
  if (isAmountField(fieldName) && TOKEN_UNIT) {
    return `<strong>${value}</strong> ${TOKEN_UNIT}`
  }
  return `<strong>${value}</strong>`
}

// ============================================================================
// Action Form Modal
// ============================================================================

// Get the connected wallet address (if wallet feature is enabled)
function getConnectedWallet() {
  if (typeof wallet !== 'undefined' && wallet.getAccount) {
    const account = wallet.getAccount()
    return account?.address || null
  }
  return null
}

// Resolve auto-fill value
function resolveAutoFill(autoFill, state) {
  if (!autoFill) return ''
  if (autoFill === 'wallet') {
    return getConnectedWallet() || ''
  }
  if (autoFill === 'user') {
    return currentUser?.id || currentUser?.login || ''
  }
  // State path like "balances.{wallet}"
  if (autoFill.startsWith('balances.') || autoFill.includes('.')) {
    // Could resolve from state if needed
    return ''
  }
  return ''
}

// Create action form modal HTML
function createActionModal() {
  return `
    <div id="action-modal" class="modal" style="display: none;">
      <div class="modal-backdrop" onclick="hideActionModal()"></div>
      <div class="modal-content">
        <div class="modal-header">
          <h3 id="action-modal-title">Execute Action</h3>
          <button onclick="hideActionModal()" class="modal-close">&times;</button>
        </div>
        <div class="modal-body">
          <form id="action-form" onsubmit="handleActionSubmit(event)">
            <div id="action-form-fields"></div>
            <div class="form-actions">
              <button type="submit" class="btn btn-primary">Execute</button>
              <button type="button" class="btn btn-secondary" onclick="hideActionModal()">Cancel</button>
            </div>
          </form>
        </div>
      </div>
    </div>
    <style>
      .modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 1000;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .modal-backdrop {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
      }
      .modal-content {
        position: relative;
        background: white;
        border-radius: 8px;
        padding: 0;
        min-width: 400px;
        max-width: 90%;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
      }
      .modal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 1rem 1.5rem;
        border-bottom: 1px solid #eee;
      }
      .modal-header h3 {
        margin: 0;
        font-size: 1.25rem;
      }
      .modal-close {
        background: none;
        border: none;
        font-size: 1.5rem;
        cursor: pointer;
        color: #666;
        padding: 0;
        line-height: 1;
      }
      .modal-close:hover {
        color: #333;
      }
      .modal-body {
        padding: 1.5rem;
      }
      .address-input-wrapper {
        position: relative;
      }
      .address-picker-btn {
        position: absolute;
        right: 4px;
        top: 50%;
        transform: translateY(-50%);
        background: #f0f0f0;
        border: 1px solid #ddd;
        border-radius: 4px;
        padding: 4px 8px;
        font-size: 0.85rem;
        cursor: pointer;
      }
      .address-picker-btn:hover {
        background: #e0e0e0;
      }
      .field-description {
        font-size: 0.85rem;
        color: #666;
        margin-top: 0.25rem;
      }
    </style>
  `
}

// Current action being executed
let currentActionId = null

// Show action modal for a transition
function showActionModal(transitionId) {
  const transition = TRANSITION_DEFS.find(t => t.id === transitionId)
  if (!transition) return

  currentActionId = transitionId

  // Update modal title
  document.getElementById('action-modal-title').textContent = transition.name

  // Build form fields
  const fieldsHtml = transition.fields.map(field => {
    const autoValue = resolveAutoFill(field.autoFill, currentInstance?.state)
    const value = autoValue || field.defaultValue || ''
    const required = field.required ? 'required' : ''

    // Determine input type
    let inputHtml = ''
    if (field.type === 'amount') {
      inputHtml = `
        <input
          type="number"
          name="${field.name}"
          value="${value}"
          placeholder="${field.placeholder || 'Amount'}"
          step="any"
          ${required}
          class="form-control"
        />
        ${TOKEN_UNIT ? `<span class="field-description">Amount in ${TOKEN_UNIT}</span>` : ''}
      `
    } else if (field.type === 'address') {
      // Use dropdown for address fields in demo mode
      const accounts = getWalletAccounts()
      if (accounts.length > 0) {
        inputHtml = `
          <select name="${field.name}" ${required} class="form-control">
            <option value="">Select address...</option>
            ${accounts.map(acc => `
              <option value="${acc.address}" ${acc.address === value ? 'selected' : ''}>
                ${acc.name || 'Account'} (${acc.address.slice(0, 8)}...${acc.address.slice(-6)})
              </option>
            `).join('')}
          </select>
        `
      } else {
        inputHtml = `
          <input
            type="text"
            name="${field.name}"
            value="${value}"
            placeholder="${field.placeholder || '0x...'}"
            ${required}
            class="form-control"
          />
        `
      }
    } else if (field.type === 'hidden') {
      inputHtml = `<input type="hidden" name="${field.name}" value="${value}" />`
    } else {
      inputHtml = `
        <input
          type="${field.type === 'number' ? 'number' : 'text'}"
          name="${field.name}"
          value="${value}"
          placeholder="${field.placeholder || ''}"
          ${required}
          class="form-control"
        />
      `
    }

    // Hidden fields don't need labels
    if (field.type === 'hidden') {
      return inputHtml
    }

    return `
      <div class="form-field">
        <label>${field.label}${field.required ? ' *' : ''}</label>
        ${inputHtml}
      </div>
    `
  }).join('')

  document.getElementById('action-form-fields').innerHTML = fieldsHtml

  // Show modal
  document.getElementById('action-modal').style.display = 'flex'
}

// Hide action modal
window.hideActionModal = function() {
  document.getElementById('action-modal').style.display = 'none'
  currentActionId = null
}

// Handle action form submission
window.handleActionSubmit = async function(event) {
  event.preventDefault()

  if (!currentActionId || !currentInstance) return

  // Save action ID before hiding modal (which clears it)
  const actionId = currentActionId
  const instanceId = currentInstance.id

  const form = event.target
  const formData = new FormData(form)
  const data = {}

  for (const [key, value] of formData.entries()) {
    // Convert numeric strings to numbers for amount fields
    const field = TRANSITION_DEFS.find(t => t.id === actionId)?.fields.find(f => f.name === key)
    if (field && (field.type === 'amount' || field.type === 'number')) {
      data[key] = parseFloat(value) || 0
    } else {
      data[key] = value
    }
  }

  hideActionModal()

  try {
    const result = await api.executeTransition(actionId, instanceId, data)
    currentInstance = {
      ...currentInstance,
      version: result.version,
      state: result.state,
      displayState: unscaleStateData(result.state),
      places: result.state,
      enabled: result.enabled || [],
    }
    // Store state for wallet balance display
    window.currentInstanceState = currentInstance.state
    renderInstanceDetail()
    showSuccess(`Action "${actionId}" completed!`)
  } catch (err) {
    showError(`Failed to execute ${actionId}: ${err.message}`)
  }
}

// Check if wallet accounts are available for address picker
function hasWalletAccounts() {
  if (typeof wallet !== 'undefined' && wallet.getAccounts) {
    const accounts = wallet.getAccounts()
    return accounts && accounts.length > 0
  }
  return false
}

// Get wallet accounts for dropdowns
function getWalletAccounts() {
  if (typeof wallet !== 'undefined' && wallet.getAccounts) {
    return wallet.getAccounts() || []
  }
  return []
}

// Show address picker dropdown
window.showAddressPicker = function(fieldName) {
  if (typeof wallet === 'undefined' || !wallet.getAccounts) return

  const accounts = wallet.getAccounts()
  if (!accounts || accounts.length === 0) return

  // Create dropdown
  const existing = document.querySelector('.address-picker-dropdown')
  if (existing) existing.remove()

  const input = document.querySelector(`[name="${fieldName}"]`)
  if (!input) return

  const rect = input.getBoundingClientRect()
  const dropdown = document.createElement('div')
  dropdown.className = 'address-picker-dropdown'
  dropdown.style.cssText = `
    position: fixed;
    top: ${rect.bottom + 4}px;
    left: ${rect.left}px;
    width: ${rect.width}px;
    background: white;
    border: 1px solid #ddd;
    border-radius: 4px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    z-index: 2000;
    max-height: 200px;
    overflow-y: auto;
  `

  dropdown.innerHTML = accounts.map(acc => `
    <div class="address-picker-option" onclick="selectAddress('${fieldName}', '${acc.address}')" style="
      padding: 8px 12px;
      cursor: pointer;
      border-bottom: 1px solid #eee;
    ">
      <div style="font-weight: 500;">${acc.name || 'Account'}</div>
      <div style="font-size: 0.85rem; color: #666; font-family: monospace;">${acc.address.slice(0, 10)}...${acc.address.slice(-8)}</div>
    </div>
  `).join('')

  document.body.appendChild(dropdown)

  // Close on click outside
  setTimeout(() => {
    document.addEventListener('click', function closeDropdown(e) {
      if (!dropdown.contains(e.target)) {
        dropdown.remove()
        document.removeEventListener('click', closeDropdown)
      }
    })
  }, 0)
}

// Select address from picker
window.selectAddress = function(fieldName, address) {
  const input = document.querySelector(`[name="${fieldName}"]`)
  if (input) {
    input.value = address
    input.dispatchEvent(new Event('input', { bubbles: true }))
  }
  const dropdown = document.querySelector('.address-picker-dropdown')
  if (dropdown) dropdown.remove()
}

// Form page - create new instance
async function renderFormPage() {
  const app = document.getElementById('app')
  app.innerHTML = `
    <div class="page">
      <div class="page-header">
        <div>
          <button class="btn btn-link" onclick="navigate('/job-application')" style="margin-left: -0.5rem">
            &larr; Cancel
          </button>
          <h1 style="margin-top: 0.5rem">Create New</h1>
        </div>
      </div>
      <div class="card">
        <form id="create-form" onsubmit="handleSubmitCreate(event)">
          <p style="color: #666; margin-bottom: 1rem;">Create a new workflow instance. The instance will start in the initial state.</p>
          <div class="form-actions">
            <button type="submit" class="btn btn-primary">Create</button>
            <button type="button" class="btn btn-secondary" onclick="navigate('/job-application')">Cancel</button>
          </div>
        </form>
      </div>
    </div>
  `
}

// Schema viewer page
async function renderSchemaPage() {
  const app = document.getElementById('app')
  app.innerHTML = `
    <div class="page">
      <div class="page-header">
        <h1>Schema Viewer</h1>
        <p style="color: #666; margin-top: 0.5rem;">Inspect the Petri net model that powers this application</p>
      </div>
      <div id="schema-content" class="card">
        <div class="loading">Loading schema...</div>
      </div>
    </div>
  `

  try {
    const response = await fetch(`${API_BASE}/api/schema`)
    const schema = await response.json()

    const schemaContent = document.getElementById('schema-content')
    schemaContent.innerHTML = `
      <div class="schema-viewer">
        <div class="schema-tabs">
          <button class="schema-tab active" onclick="showSchemaTab('overview')">Overview</button>
          <button class="schema-tab" onclick="showSchemaTab('places')">Places (${schema.places?.length || 0})</button>
          <button class="schema-tab" onclick="showSchemaTab('transitions')">Transitions (${schema.transitions?.length || 0})</button>
          <button class="schema-tab" onclick="showSchemaTab('arcs')">Arcs (${schema.arcs?.length || 0})</button>
          <button class="schema-tab" onclick="showSchemaTab('raw')">Raw JSON</button>
        </div>

        <div id="schema-tab-overview" class="schema-tab-content active">
          <div class="schema-overview">
            <div class="schema-info-card">
              <h3>${schema.name || 'Unnamed'}</h3>
              <p>${schema.description || 'No description'}</p>
            </div>
            <div class="schema-stats">
              <div class="stat-item">
                <span class="stat-value">${schema.places?.length || 0}</span>
                <span class="stat-label">Places</span>
              </div>
              <div class="stat-item">
                <span class="stat-value">${schema.transitions?.length || 0}</span>
                <span class="stat-label">Transitions</span>
              </div>
              <div class="stat-item">
                <span class="stat-value">${schema.arcs?.length || 0}</span>
                <span class="stat-label">Arcs</span>
              </div>
              <div class="stat-item">
                <span class="stat-value">${schema.roles?.length || 0}</span>
                <span class="stat-label">Roles</span>
              </div>
            </div>
          </div>
        </div>

        <div id="schema-tab-places" class="schema-tab-content" style="display: none;">
          <table class="schema-table">
            <thead>
              <tr>
                <th>ID</th>
                <th>Description</th>
                <th>Initial</th>
                <th>Capacity</th>
              </tr>
            </thead>
            <tbody>
              ${(schema.places || []).map(p => `
                <tr>
                  <td><code>${p.id}</code></td>
                  <td>${p.description || '-'}</td>
                  <td>${p.initial || 0}</td>
                  <td>${p.capacity || 'âˆž'}</td>
                </tr>
              `).join('')}
            </tbody>
          </table>
        </div>

        <div id="schema-tab-transitions" class="schema-tab-content" style="display: none;">
          <table class="schema-table">
            <thead>
              <tr>
                <th>ID</th>
                <th>Description</th>
                <th>Guard</th>
                <th>Roles</th>
              </tr>
            </thead>
            <tbody>
              ${(schema.transitions || []).map(t => `
                <tr>
                  <td><code>${t.id}</code></td>
                  <td>${t.description || '-'}</td>
                  <td><code>${t.guard || '-'}</code></td>
                  <td>${(t.roles || []).join(', ') || '-'}</td>
                </tr>
              `).join('')}
            </tbody>
          </table>
        </div>

        <div id="schema-tab-arcs" class="schema-tab-content" style="display: none;">
          <table class="schema-table">
            <thead>
              <tr>
                <th>From</th>
                <th>To</th>
                <th>Weight</th>
                <th>Type</th>
              </tr>
            </thead>
            <tbody>
              ${(schema.arcs || []).map(a => `
                <tr>
                  <td><code>${a.from}</code></td>
                  <td><code>${a.to}</code></td>
                  <td>${a.weight || 1}</td>
                  <td>${a.type || 'normal'}</td>
                </tr>
              `).join('')}
            </tbody>
          </table>
        </div>

        <div id="schema-tab-raw" class="schema-tab-content" style="display: none;">
          <pre class="schema-json">${JSON.stringify(schema, null, 2)}</pre>
        </div>
      </div>

      <style>
        .schema-viewer {
          padding: 1rem;
        }
        .schema-tabs {
          display: flex;
          gap: 0.5rem;
          margin-bottom: 1rem;
          border-bottom: 1px solid #eee;
          padding-bottom: 0.5rem;
        }
        .schema-tab {
          padding: 0.5rem 1rem;
          border: none;
          background: #f5f5f5;
          border-radius: 4px;
          cursor: pointer;
          font-size: 0.9rem;
        }
        .schema-tab:hover {
          background: #e9e9e9;
        }
        .schema-tab.active {
          background: #007bff;
          color: white;
        }
        .schema-tab-content {
          display: none;
        }
        .schema-tab-content.active {
          display: block;
        }
        .schema-overview {
          display: flex;
          flex-direction: column;
          gap: 1.5rem;
        }
        .schema-info-card h3 {
          margin: 0 0 0.5rem 0;
          font-size: 1.5rem;
        }
        .schema-info-card p {
          margin: 0;
          color: #666;
        }
        .schema-stats {
          display: grid;
          grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
          gap: 1rem;
        }
        .stat-item {
          background: #f8f9fa;
          padding: 1rem;
          border-radius: 8px;
          text-align: center;
        }
        .stat-value {
          display: block;
          font-size: 2rem;
          font-weight: 600;
          color: #007bff;
        }
        .stat-label {
          display: block;
          font-size: 0.85rem;
          color: #666;
          margin-top: 0.25rem;
        }
        .schema-table {
          width: 100%;
          border-collapse: collapse;
        }
        .schema-table th,
        .schema-table td {
          padding: 0.75rem;
          text-align: left;
          border-bottom: 1px solid #eee;
        }
        .schema-table th {
          background: #f8f9fa;
          font-weight: 600;
        }
        .schema-table code {
          background: #f0f0f0;
          padding: 0.2rem 0.4rem;
          border-radius: 3px;
          font-size: 0.85rem;
        }
        .schema-json {
          background: #1e1e1e;
          color: #d4d4d4;
          padding: 1rem;
          border-radius: 8px;
          overflow-x: auto;
          font-size: 0.85rem;
          line-height: 1.5;
        }
      </style>
    `
  } catch (err) {
    console.error('Failed to load schema:', err)
    document.getElementById('schema-content').innerHTML = `
      <div class="error">Failed to load schema: ${err.message}</div>
    `
  }
}

// Schema tab switching
window.showSchemaTab = function(tabName) {
  // Update tab buttons
  document.querySelectorAll('.schema-tab').forEach(tab => {
    tab.classList.remove('active')
  })
  event.target.classList.add('active')

  // Update tab content
  document.querySelectorAll('.schema-tab-content').forEach(content => {
    content.style.display = 'none'
    content.classList.remove('active')
  })
  const targetContent = document.getElementById(`schema-tab-${tabName}`)
  if (targetContent) {
    targetContent.style.display = 'block'
    targetContent.classList.add('active')
  }
}

// Admin dashboard
async function renderAdminPage() {
  const app = document.getElementById('app')
  app.innerHTML = `
    <div class="page">
      <div class="page-header">
        <h1>Admin Dashboard</h1>
      </div>
      <div id="admin-stats" class="card">
        <div class="loading">Loading statistics...</div>
      </div>
      <div id="admin-instances" class="card">
        <div class="card-header">Recent Instances</div>
        <div class="loading">Loading...</div>
      </div>
    </div>
  `

  try {
    const [stats, instancesResult] = await Promise.all([
      fetch(`${API_BASE}/admin/stats`, { headers: getHeaders() }).then(r => r.json()).catch(() => null),
      api.listInstances()
    ])

    if (stats) {
      document.getElementById('admin-stats').innerHTML = `
        <div class="card-header">Statistics</div>
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 1rem;">
          <div>
            <div style="font-size: 2rem; font-weight: 600;">${stats.total_streams || 0}</div>
            <div style="color: #666;">Total Instances</div>
          </div>
          <div>
            <div style="font-size: 2rem; font-weight: 600;">${stats.total_events || 0}</div>
            <div style="color: #666;">Total Events</div>
          </div>
        </div>
      `
    } else {
      document.getElementById('admin-stats').innerHTML = ''
    }

    instances = instancesResult.instances || []
    const container = document.getElementById('admin-instances').querySelector('.loading')
    if (container) {
      container.outerHTML = instances.length > 0
        ? `<table class="table">
            <thead>
              <tr>
                <th>ID</th>
                <th>Status</th>
                <th>Version</th>
                <th>Actions</th>
              </tr>
            </thead>
            <tbody>
              ${instances.slice(0, 20).map(inst => {
                const status = getStatus(inst.state || inst.places)
                return `
                  <tr>
                    <td><code>${inst.id}</code></td>
                    <td>${formatStatus(status)}</td>
                    <td>${inst.version || 0}</td>
                    <td><button class="btn btn-sm btn-link" onclick="navigate('/job-application/${inst.id}')">View</button></td>
                  </tr>
                `
              }).join('')}
            </tbody>
          </table>`
        : '<p style="color: #666; padding: 1rem;">No instances yet.</p>'
    }
  } catch (err) {
    showError('Failed to load admin data: ' + err.message)
  }
}

// ============================================================================
// Event Handlers
// ============================================================================

window.navigate = navigate

window.handleCreateNew = async function() {
  navigate('/job-application/new')
}

window.handleSubmitCreate = async function(event) {
  event.preventDefault()
  try {
    const result = await api.createInstance({})
    showSuccess('Instance created successfully!')
    navigate(`/job-application/${result.aggregate_id || result.id}`)
  } catch (err) {
    showError('Failed to create: ' + err.message)
  }
}

window.handleTransition = async function(transitionId) {
  if (!currentInstance) return

  // Check if transition has fields - show modal if so
  const transition = TRANSITION_DEFS.find(t => t.id === transitionId)
  if (transition && transition.fields && transition.fields.length > 0) {
    showActionModal(transitionId)
    return
  }

  // No fields - execute directly
  try {
    const result = await api.executeTransition(transitionId, currentInstance.id)
    currentInstance = {
      ...currentInstance,
      version: result.version,
      state: result.state,
      displayState: unscaleStateData(result.state),
      places: result.state,
      enabled: result.enabled || [],
    }
    // Store state for wallet balance display
    window.currentInstanceState = currentInstance.state
    renderInstanceDetail()
    showSuccess(`Action "${transitionId}" completed!`)
  } catch (err) {
    showError(`Failed to execute ${transitionId}: ${err.message}`)
  }
}

// ============================================================================
// Routing
// ============================================================================

function handleRouteChange(event) {
  const route = event.detail?.route || getCurrentRoute()
  if (!route) {
    renderListPage()
    return
  }

  const path = route.path
  if (path === '/job-application' || path === '/') {
    renderListPage()
  } else if (path === '/job-application/new') {
    renderFormPage()
  } else if (path === '/job-application/:id') {
    renderDetailPage()
  } else if (path === '/schema') {
    renderSchemaPage()
  } else if (path === '/admin' || path.startsWith('/admin')) {
    renderAdminPage()
  } else {
    renderListPage()
  }
}

// ============================================================================
// OAuth Callback Handler
// ============================================================================

async function handleOAuthCallback() {
  const params = new URLSearchParams(window.location.search)
  const token = params.get('token')
  const expiresAt = params.get('expires_at')

  if (token) {
    authToken = token
    try {
      const user = await api.getMe()
      saveAuth({ token, expires_at: expiresAt, user })
      window.history.replaceState({}, '', window.location.pathname)
      await refreshNavigation()
    } catch (err) {
      clearAuth()
      showError('Failed to complete login')
    }
  }
}

// ============================================================================
// Initialize
// ============================================================================

async function init() {
  // Load auth state
  loadAuth()

  // Handle OAuth callback
  await handleOAuthCallback()

  // Load view definitions
  await loadViews()

  // Render navigation
  const nav = document.getElementById('nav')
  nav.innerHTML = await createNavigation()

  // Add action modal to body
  const modalContainer = document.createElement('div')
  modalContainer.innerHTML = createActionModal()
  document.body.appendChild(modalContainer)

  // Setup routing
  window.addEventListener('route-change', handleRouteChange)
  initRouter()

  // Initial render
  handleRouteChange({ detail: { route: getCurrentRoute() } })
}


// ============================================================================
// Debug WebSocket Client
// ============================================================================

let debugWs = null
let debugSessionId = null

function initDebugWebSocket() {
  const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:'
  const wsUrl = `${wsProtocol}//${window.location.host}/ws`

  debugWs = new WebSocket(wsUrl)

  debugWs.onopen = () => {
    console.log('[Debug] WebSocket connected')
  }

  debugWs.onmessage = (event) => {
    try {
      const msg = JSON.parse(event.data)

      if (msg.id === 'session' && msg.type === 'session') {
        // Data is already parsed from JSON
        const data = typeof msg.data === 'string' ? JSON.parse(msg.data) : msg.data
        debugSessionId = data.session_id
        console.log('[Debug] Session ID:', debugSessionId)
      } else if (msg.type === 'eval') {
        handleDebugEval(msg)
      }
    } catch (e) {
      console.error('[Debug] Failed to parse message:', e)
    }
  }

  debugWs.onclose = () => {
    console.log('[Debug] WebSocket disconnected, reconnecting in 3s...')
    debugSessionId = null
    setTimeout(initDebugWebSocket, 3000)
  }

  debugWs.onerror = (err) => {
    console.error('[Debug] WebSocket error:', err)
  }
}

async function handleDebugEval(msg) {
  try {
    // Data may be parsed object or string
    const data = typeof msg.data === 'string' ? JSON.parse(msg.data) : msg.data
    const code = data.code

    // Execute the code using Function constructor
    const fn = new Function('return (async () => { ' + code + ' })()')
    const result = await fn()

    // Send response back - data should be an object, not a string
    const response = {
      type: 'response',
      id: msg.id,
      data: {
        result: result,
        type: typeof result
      }
    }
    debugWs.send(JSON.stringify(response))
  } catch (e) {
    // Send error response
    const response = {
      type: 'response',
      id: msg.id,
      data: {
        error: e.message
      }
    }
    debugWs.send(JSON.stringify(response))
  }
}

// Export debug functions for external use
window.debugSessionId = () => debugSessionId
window.debugWs = () => debugWs

// ============================================================================
// Pilot - Debug/Test Driving API
// ============================================================================

/**
 * window.pilot provides a clean API for driving the app programmatically.
 * Use this for:
 * - Automated E2E tests via the debug WebSocket
 * - Manual debugging from the browser console
 * - Visual confirmation of UI behavior
 */
window.pilot = {
  // --- Navigation ---

  /** Navigate to the list page */
  async list() {
    navigate('/job-application')
    // Wait for instances to load
    await this.waitFor('.entity-card, .empty-state', 5000).catch(() => {})
    return instances
  },

  /** Navigate to create new instance form */
  newForm() {
    navigate('/job-application/new')
    return this.waitForRender()
  },

  /** Navigate to view a specific instance */
  async view(id) {
    navigate(`/job-application/${id}`)
    await this.waitForRender()
    return currentInstance
  },

  /** Navigate to admin dashboard */
  admin() {
    navigate('/admin')
    return this.waitForRender()
  },

  // --- Instance Operations ---

  /** Create a new instance and navigate to it */
  async create(data = {}) {
    const result = await api.createInstance(data)
    const id = result.aggregate_id || result.id
    navigate(`/job-application/${id}`)
    await this.waitForRender()
    return { id, ...result }
  },

  /** Get the current instance (from detail page) */
  getCurrentInstance() {
    return currentInstance
  },

  /** Get all loaded instances (from list page) */
  getInstances() {
    return instances
  },

  /** Reload current instance state from API */
  async refresh() {
    if (!currentInstance) throw new Error('No current instance')
    const result = await api.getInstance(currentInstance.id)
    currentInstance = {
      id: result.aggregate_id || currentInstance.id,
      version: result.version,
      state: result.state,
      places: result.places,
      enabled: result.enabled || result.enabled_transitions || [],
    }
    renderInstanceDetail()
    return currentInstance
  },

  // --- Actions ---

  /** Execute a transition on the current instance */
  async action(transitionId, data = {}) {
    if (!currentInstance) throw new Error('No current instance - navigate to detail page first')
    const result = await api.executeTransition(transitionId, currentInstance.id, data)
    currentInstance = {
      ...currentInstance,
      version: result.version,
      state: result.state,
      places: result.state,
      enabled: result.enabled || [],
    }
    renderInstanceDetail()
    return { success: true, state: currentInstance.places, enabled: currentInstance.enabled }
  },

  /** Check if a transition is enabled for the current instance */
  isEnabled(transitionId) {
    if (!currentInstance) return false
    return (currentInstance.enabled || []).includes(transitionId)
  },

  /** Get list of enabled transitions */
  getEnabled() {
    return currentInstance?.enabled || []
  },

  // --- Form Operations ---

  /** Fill a form field by name */
  fill(name, value) {
    const input = document.querySelector(`[name="${name}"]`)
    if (!input) throw new Error(`No input found with name: ${name}`)
    input.value = value
    input.dispatchEvent(new Event('input', { bubbles: true }))
    return this
  },

  /** Submit the current form */
  async submit() {
    const form = document.querySelector('form')
    if (!form) throw new Error('No form found on page')
    const event = new Event('submit', { bubbles: true, cancelable: true })
    form.dispatchEvent(event)
    await this.waitForRender()
    return currentInstance
  },

  // --- UI Inspection ---

  /** Get text content of an element */
  getText(selector) {
    const el = document.querySelector(selector)
    return el ? el.textContent.trim() : null
  },

  /** Check if an element exists */
  exists(selector) {
    return document.querySelector(selector) !== null
  },

  /** Get all buttons on the page */
  getButtons() {
    return Array.from(document.querySelectorAll('button')).map(btn => ({
      text: btn.textContent.trim(),
      disabled: btn.disabled,
      className: btn.className,
    }))
  },

  /** Click a button by text */
  async clickButton(text) {
    const buttons = document.querySelectorAll('button')
    for (const btn of buttons) {
      if (btn.textContent.trim() === text && !btn.disabled) {
        btn.click()
        await this.waitForRender()
        return true
      }
    }
    throw new Error(`No enabled button found with text: ${text}`)
  },

  // --- State ---

  /** Get the current Petri net state (places with token counts) */
  getState() {
    return currentInstance?.places || null
  },

  /** Get the current status (place with token) */
  getStatus() {
    if (!currentInstance?.places) return null
    for (const [place, tokens] of Object.entries(currentInstance.places)) {
      if (tokens > 0) return place
    }
    return null
  },

  /** Get the current route */
  getRoute() {
    return getCurrentRoute()
  },

  /** Get current authenticated user */
  getUser() {
    return currentUser
  },

  /** Check if user is authenticated */
  isAuthenticated() {
    return authToken !== null
  },

  // --- Utilities ---

  /** Wait for render to complete */
  waitForRender(ms = 50) {
    return new Promise(resolve => setTimeout(resolve, ms))
  },

  /** Wait for an element to appear */
  async waitFor(selector, timeout = 5000) {
    const start = Date.now()
    while (Date.now() - start < timeout) {
      if (document.querySelector(selector)) {
        return document.querySelector(selector)
      }
      await this.waitForRender(50)
    }
    throw new Error(`Timeout waiting for: ${selector}`)
  },

  /** Wait for current instance to be in a specific state */
  async waitForState(place, timeout = 5000) {
    const start = Date.now()
    while (Date.now() - start < timeout) {
      if (currentInstance?.places?.[place] > 0) {
        return currentInstance
      }
      await this.waitForRender(100)
    }
    throw new Error(`Timeout waiting for state: ${place}`)
  },

  /** Log current state to console (for debugging) */
  debug() {
    console.log('=== Pilot Debug ===')
    console.log('Route:', getCurrentRoute())
    console.log('User:', currentUser)
    console.log('Instance:', currentInstance)
    console.log('Enabled:', currentInstance?.enabled)
    console.log('State:', currentInstance?.places)
    return {
      route: getCurrentRoute(),
      user: currentUser,
      instance: currentInstance,
    }
  },

  // --- Event Sourcing ---

  /** Get event history for current instance */
  async getEvents() {
    if (!currentInstance) throw new Error('No current instance')
    const response = await fetch(`${API_BASE}/api/jobapplication/${currentInstance.id}/events`, {
      headers: getHeaders()
    })
    const data = await handleResponse(response)
    return data.events || []
  },

  /** Get event count for current instance */
  async getEventCount() {
    const events = await this.getEvents()
    return events.length
  },

  /** Get the last event for current instance */
  async getLastEvent() {
    const events = await this.getEvents()
    return events.length > 0 ? events[events.length - 1] : null
  },

  /** Replay instance to a specific version (read-only view) */
  async replayTo(version) {
    if (!currentInstance) throw new Error('No current instance')
    const events = await this.getEvents()
    const filtered = events.filter(e => (e.version || e.sequence) <= version)

    // Compute state by applying events up to version
    const places = {}
    // Initialize with first event or empty
    for (const event of filtered) {
      if (event.state) {
        Object.assign(places, event.state)
      }
    }
    return { version, events: filtered, places }
  },

  // --- Role/Auth Testing ---

  /** Login as a specific role (or array of roles) */
  async loginAs(roles) {
    const rolesArray = typeof roles === 'string' ? [roles] : roles
    const response = await fetch(`${API_BASE}/api/debug/login`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ login: 'pilot-user', roles: rolesArray }),
    })
    const data = await response.json()
    saveAuth(data)
    await this.waitForRender(100)
    return data
  },

  /** Logout current user */
  logout() {
    clearAuth()
    return this.waitForRender()
  },

  /** Get current user's roles */
  getRoles() {
    return currentUser?.roles || []
  },

  /** Check if current user has a specific role */
  hasRole(role) {
    return this.getRoles().includes(role)
  },

  // --- Assertions (throw on failure) ---

  /** Assert current instance is in expected state */
  assertState(expectedPlace) {
    const status = this.getStatus()
    if (status !== expectedPlace) {
      throw new Error(`Expected state '${expectedPlace}', got '${status}'`)
    }
    return this
  },

  /** Assert a transition is enabled */
  assertEnabled(transitionId) {
    if (!this.isEnabled(transitionId)) {
      const enabled = this.getEnabled()
      throw new Error(`Expected '${transitionId}' to be enabled. Enabled: [${enabled.join(', ')}]`)
    }
    return this
  },

  /** Assert a transition is disabled */
  assertDisabled(transitionId) {
    if (this.isEnabled(transitionId)) {
      throw new Error(`Expected '${transitionId}' to be disabled, but it is enabled`)
    }
    return this
  },

  /** Assert element exists in DOM */
  assertExists(selector) {
    if (!this.exists(selector)) {
      throw new Error(`Expected element '${selector}' to exist`)
    }
    return this
  },

  /** Assert element contains text */
  assertText(selector, expected) {
    const actual = this.getText(selector)
    if (actual !== expected) {
      throw new Error(`Expected '${selector}' to contain '${expected}', got '${actual}'`)
    }
    return this
  },

  /** Assert user is authenticated */
  assertAuthenticated() {
    if (!this.isAuthenticated()) {
      throw new Error('Expected user to be authenticated')
    }
    return this
  },

  /** Assert user has role */
  assertRole(role) {
    if (!this.hasRole(role)) {
      throw new Error(`Expected user to have role '${role}'. Has: [${this.getRoles().join(', ')}]`)
    }
    return this
  },

  // --- Workflow Introspection ---

  /** Get all transition definitions */
  getTransitions() {
    return [
      { id: 'start_screening', name: 'Start Screening', description: "Begin candidate screening", requiredRoles: ["recruiter"], apiPath: '/api/start_screening' },
      { id: 'begin_checks', name: 'Begin Checks', description: "Start parallel phone screen and background check processes", requiredRoles: ["recruiter"], apiPath: '/api/begin_checks' },
      { id: 'schedule_phone_screen', name: 'Schedule Phone Screen', description: "Schedule phone screen", requiredRoles: ["recruiter"], apiPath: '/api/schedule_phone_screen' },
      { id: 'start_background_check', name: 'Start Background Check', description: "Initiate background check", requiredRoles: ["recruiter"], apiPath: '/api/start_background_check' },
      { id: 'complete_phone_screen', name: 'Complete Phone Screen', description: "Complete phone screen", requiredRoles: ["recruiter"], apiPath: '/api/complete_phone_screen' },
      { id: 'complete_background_check', name: 'Complete Background Check', description: "Complete background check", requiredRoles: ["recruiter"], apiPath: '/api/complete_background_check' },
      { id: 'advance_to_interview', name: 'Advance To Interview', description: "Both checks passed, advance to interview", requiredRoles: ["recruiter"], apiPath: '/api/advance_to_interview' },
      { id: 'conduct_interview', name: 'Conduct Interview', description: "Conduct interview", requiredRoles: ["hiring_manager"], apiPath: '/api/conduct_interview' },
      { id: 'extend_offer', name: 'Extend Offer', description: "Extend job offer", requiredRoles: ["hiring_manager"], apiPath: '/api/extend_offer' },
      { id: 'accept_offer', name: 'Accept Offer', description: "Candidate accepts offer", requiredRoles: ["candidate"], apiPath: '/api/accept_offer' },
      { id: 'reject_after_screen', name: 'Reject After Screen', description: "Reject after screening", requiredRoles: ["recruiter"], apiPath: '/api/reject_after_screen' },
      { id: 'reject_after_interview', name: 'Reject After Interview', description: "Reject after interview", requiredRoles: ["hiring_manager"], apiPath: '/api/reject_after_interview' },
      { id: 'decline_offer', name: 'Decline Offer', description: "Candidate declines offer", requiredRoles: ["candidate"], apiPath: '/api/decline_offer' },
    ]
  },

  /** Get all place definitions */
  getPlaces() {
    return [
      { id: 'applied', name: 'Applied', initial: 1 },
      { id: 'screening', name: 'Screening', initial: 0 },
      { id: 'ready_for_phone_screen', name: 'ReadyForPhoneScreen', initial: 0 },
      { id: 'ready_for_background_check', name: 'ReadyForBackgroundCheck', initial: 0 },
      { id: 'phone_screen_pending', name: 'PhoneScreenPending', initial: 0 },
      { id: 'phone_screen_complete', name: 'PhoneScreenComplete', initial: 0 },
      { id: 'background_check_pending', name: 'BackgroundCheckPending', initial: 0 },
      { id: 'background_check_complete', name: 'BackgroundCheckComplete', initial: 0 },
      { id: 'ready_for_interview', name: 'ReadyForInterview', initial: 0 },
      { id: 'interviewing', name: 'Interviewing', initial: 0 },
      { id: 'offer_extended', name: 'OfferExtended', initial: 0 },
      { id: 'hired', name: 'Hired', initial: 0 },
      { id: 'rejected', name: 'Rejected', initial: 0 },
    ]
  },

  /** Get transition by ID */
  getTransition(id) {
    return this.getTransitions().find(t => t.id === id) || null
  },

  /** Check if transition can fire, with reason if not */
  canFire(transitionId) {
    const transition = this.getTransition(transitionId)
    if (!transition) {
      return { canFire: false, reason: `Unknown transition: ${transitionId}` }
    }

    if (!currentInstance) {
      return { canFire: false, reason: 'No current instance' }
    }

    const enabled = this.isEnabled(transitionId)
    if (!enabled) {
      const status = this.getStatus()
      return {
        canFire: false,
        reason: `Transition '${transitionId}' not enabled in state '${status}'`,
        currentState: status,
        enabledTransitions: this.getEnabled()
      }
    }

    // Check role-based access control
    if (transition.requiredRoles && transition.requiredRoles.length > 0) {
      const userRoles = this.getRoles()
      const hasRequiredRole = transition.requiredRoles.some(r => userRoles.includes(r))
      if (!hasRequiredRole) {
        return {
          canFire: false,
          reason: `User lacks required role. Need one of: [${transition.requiredRoles.join(', ')}]. Has: [${userRoles.join(', ')}]`,
          requiredRoles: transition.requiredRoles,
          userRoles: userRoles
        }
      }
    }

    return { canFire: true }
  },

  /** Execute a sequence of transitions */
  async sequence(transitionIds, options = {}) {
    const results = []
    const { stopOnError = true, data = {} } = options

    for (const id of transitionIds) {
      const check = this.canFire(id)
      if (!check.canFire) {
        if (stopOnError) {
          throw new Error(`Sequence failed at '${id}': ${check.reason}`)
        }
        results.push({ transition: id, success: false, error: check.reason })
        continue
      }

      try {
        const result = await this.action(id, data[id] || {})
        results.push({ transition: id, success: true, state: result.state })
      } catch (e) {
        if (stopOnError) throw e
        results.push({ transition: id, success: false, error: e.message })
      }
    }

    return results
  },

  /** Get workflow summary */
  getWorkflowInfo() {
    return {
      places: this.getPlaces(),
      transitions: this.getTransitions(),
      initialPlace: this.getPlaces().find(p => p.initial > 0)?.id,
    }
  },
}


// Start the app
init()


// Initialize debug WebSocket after app init
initDebugWebSocket()

