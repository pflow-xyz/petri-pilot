// Generated by petri-pilot. DO NOT EDIT.

/**
 * Router configuration for job-application application
 * Provides client-side routing with dynamic route matching
 */

// API base path for when service is mounted at a prefix
const API_BASE = window.API_BASE || ''

// Frontend base path (may differ from API_BASE when in dash view)
function getFrontendBase() {
  const path = window.location.pathname
  const match = path.match(/^(\/~[^\/]+)\//)
  if (match) {
    return match[1]  // e.g., /~coffeeshop
  }
  return API_BASE  // e.g., /coffeeshop
}

// Helper to strip base prefix from a path for route matching
function stripBase(path) {
  const frontendBase = getFrontendBase()
  // First try stripping frontend base (handles dash view)
  if (frontendBase && path.startsWith(frontendBase)) {
    return path.slice(frontendBase.length) || '/'
  }
  // Fall back to API_BASE
  if (API_BASE && path.startsWith(API_BASE)) {
    return path.slice(API_BASE.length) || '/'
  }
  return path
}

// Route definitions - order matters! More specific routes first
export const routes = [
  // Root redirects to list
  {
    path: '/',
    component: 'List',
    title: 'job-application',
  },
  // Entity routes
  {
    path: '/job-application',
    component: 'List',
    title: 'job-application',
  },
  {
    path: '/job-application/new',
    component: 'Form',
    title: 'New job-application',
  },
  {
    path: '/job-application/:id',
    component: 'Detail',
    title: 'job-application Detail',
  },
  // Schema viewer
  {
    path: '/schema',
    component: 'Schema',
    title: 'Schema Viewer',
  },
]

// Current route state
let currentRoute = null
let currentParams = {}

// Route matcher - tries routes in order, returns first match
function matchRoute(path) {
  // Normalize path
  path = path || '/'
  if (path !== '/' && path.endsWith('/')) {
    path = path.slice(0, -1)
  }

  for (const route of routes) {
    const params = {}
    // Escape special regex chars except our param pattern
    let pattern = route.path.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
    // Replace :param with capture group
    pattern = pattern.replace(/:[^/]+/g, '([^/]+)')
    const regex = new RegExp(`^${pattern}$`)
    const match = path.match(regex)

    if (match) {
      // Extract params from dynamic segments
      const paramNames = (route.path.match(/:[^/]+/g) || []).map(p => p.slice(1))
      paramNames.forEach((name, i) => {
        params[name] = decodeURIComponent(match[i + 1])
      })

      return { route, params }
    }
  }
  return null
}

// Navigate to a path
export function navigate(path, state = {}) {
  // Handle relative paths
  if (!path.startsWith('/')) {
    path = '/' + path
  }

  // Strip API_BASE if present for route matching
  const routePath = stripBase(path)
  const match = matchRoute(routePath)

  if (!match) {
    // Fallback to list page for unknown routes
    console.warn(`No route found for path: ${path}, falling back to list`)
    const fallbackPath = '/job-application'
    const fallback = matchRoute(fallbackPath)
    if (fallback) {
      currentRoute = fallback.route
      currentParams = fallback.params
      window.history.pushState(state, '', `${getFrontendBase()}${fallbackPath}`)
      renderCurrentRoute()
    }
    return
  }

  // Check role requirements
  if (match.route.roles && match.route.roles.length > 0) {
    const user = getCurrentUser()
    if (!user || !hasAnyRole(user, match.route.roles)) {
      console.warn('Access denied:', path)
      navigate(`${getFrontendBase()}/job-application`)
      return
    }
  }

  currentRoute = match.route
  currentParams = match.params

  // Update browser history - use frontend base (respects dash view)
  const frontendBase = getFrontendBase()
  const historyPath = path.startsWith(frontendBase) ? path : `${frontendBase}${routePath}`
  window.history.pushState(state, '', historyPath)

  // Trigger render
  renderCurrentRoute()
}

// Handle browser back/forward
window.addEventListener('popstate', () => {
  const path = stripBase(window.location.pathname)
  const match = matchRoute(path)
  if (match) {
    currentRoute = match.route
    currentParams = match.params
    renderCurrentRoute()
  } else {
    // Fallback to list
    navigate(`${getFrontendBase()}/job-application`)
  }
})

// Get current user from auth
function getCurrentUser() {
  const auth = localStorage.getItem('auth')
  if (auth) {
    try {
      return JSON.parse(auth).user
    } catch (e) {
      return null
    }
  }
  return null
}

// Check if user has any of the required roles
function hasAnyRole(user, roles) {
  if (!user || !user.roles) {
    return false
  }
  return roles.some(role => user.roles.includes(role))
}

// Render the current route
function renderCurrentRoute() {
  // Dispatch custom event for page changes
  window.dispatchEvent(new CustomEvent('route-change', {
    detail: {
      route: currentRoute,
      params: currentParams
    }
  }))
}

// Get current route params
export function getRouteParams() {
  return currentParams
}

// Get current route
export function getCurrentRoute() {
  return currentRoute
}

// Initialize router
export function initRouter() {
  const path = stripBase(window.location.pathname)
  const match = matchRoute(path)

  if (match) {
    currentRoute = match.route
    currentParams = match.params
  } else {
    // Default to list page
    currentRoute = routes.find(r => r.path === '/job-application') || routes[0]
    currentParams = {}
  }
}
