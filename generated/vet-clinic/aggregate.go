// Code generated by petri-pilot. DO NOT EDIT.

package main

import (
	"context"
	"encoding/json"
	"fmt"

	"github.com/google/uuid"
	"github.com/pflow-xyz/petri-pilot/pkg/runtime"
	"github.com/pflow-xyz/petri-pilot/pkg/runtime/aggregate"
	"github.com/pflow-xyz/petri-pilot/pkg/runtime/eventstore"
)

// State holds the aggregate state for vet-clinic.
type State struct {
	Requested int `json:"requested"`
	Scheduled int `json:"scheduled"`
	CheckedIn int `json:"checked_in"`
	InProgress int `json:"in_progress"`
	Completed int `json:"completed"`
	CheckedOut int `json:"checked_out"`
	Cancelled int `json:"cancelled"`
	NoShow int `json:"no_show"`
	AwaitingLab int `json:"awaiting_lab"`
	AwaitingAuthorization int `json:"awaiting_authorization"`
	Referred int `json:"referred"`
}

// NewState creates a new State with initialized collections.
func NewState() State {
	return State{
	}
}

// Aggregate wraps a StateMachine with the vet-clinic state.
type Aggregate struct {
	sm *aggregate.StateMachine[State]
}

// NewAggregate creates a new aggregate with initial state.
func NewAggregate(id string) *Aggregate {
	if id == "" {
		id = uuid.New().String()
	}
	sm := aggregate.NewStateMachine(id, NewState(), InitialPlaces())

	// Register transitions with their input/output places
	sm.AddTransition(aggregate.Transition{
		ID:        TransitionSchedule,
		EventType: EventTypeSchedule,
		Inputs: map[string]int{
			PlaceRequested: 1,
		},
		Outputs: map[string]int{
			PlaceScheduled: 1,
		},
	})
	sm.AddTransition(aggregate.Transition{
		ID:        TransitionCheckIn,
		EventType: EventTypeCheckIn,
		Inputs: map[string]int{
			PlaceScheduled: 1,
		},
		Outputs: map[string]int{
			PlaceCheckedIn: 1,
		},
	})
	sm.AddTransition(aggregate.Transition{
		ID:        TransitionStartExam,
		EventType: EventTypeStartExam,
		Inputs: map[string]int{
			PlaceCheckedIn: 1,
		},
		Outputs: map[string]int{
			PlaceInProgress: 1,
		},
	})
	sm.AddTransition(aggregate.Transition{
		ID:        TransitionComplete,
		EventType: EventTypeComplete,
		Inputs: map[string]int{
			PlaceInProgress: 1,
		},
		Outputs: map[string]int{
			PlaceCompleted: 1,
		},
	})
	sm.AddTransition(aggregate.Transition{
		ID:        TransitionCheckout,
		EventType: EventTypeCheckout,
		Inputs: map[string]int{
			PlaceCompleted: 1,
		},
		Outputs: map[string]int{
			PlaceCheckedOut: 1,
		},
	})
	sm.AddTransition(aggregate.Transition{
		ID:        TransitionCancelRequested,
		EventType: EventTypeCancelRequested,
		Inputs: map[string]int{
			PlaceRequested: 1,
		},
		Outputs: map[string]int{
			PlaceCancelled: 1,
		},
	})
	sm.AddTransition(aggregate.Transition{
		ID:        TransitionCancelScheduled,
		EventType: EventTypeCancelScheduled,
		Inputs: map[string]int{
			PlaceScheduled: 1,
		},
		Outputs: map[string]int{
			PlaceCancelled: 1,
		},
	})
	sm.AddTransition(aggregate.Transition{
		ID:        TransitionMarkNoShow,
		EventType: EventTypeMarkNoShow,
		Inputs: map[string]int{
			PlaceScheduled: 1,
		},
		Outputs: map[string]int{
			PlaceNoShow: 1,
		},
	})
	sm.AddTransition(aggregate.Transition{
		ID:        TransitionSendToLab,
		EventType: EventTypeSendToLab,
		Inputs: map[string]int{
			PlaceInProgress: 1,
		},
		Outputs: map[string]int{
			PlaceAwaitingLab: 1,
		},
	})
	sm.AddTransition(aggregate.Transition{
		ID:        TransitionReceiveResults,
		EventType: EventTypeReceiveResults,
		Inputs: map[string]int{
			PlaceAwaitingLab: 1,
		},
		Outputs: map[string]int{
			PlaceInProgress: 1,
		},
	})
	sm.AddTransition(aggregate.Transition{
		ID:        TransitionRequestAuth,
		EventType: EventTypeRequestAuth,
		Inputs: map[string]int{
			// No input arcs - can fire anytime during the appointment
		},
		Outputs: map[string]int{
			PlaceAwaitingAuthorization: 1,
		},
		Inhibitors: map[string]bool{
			// Cannot request auth once appointment is closed
			PlaceCheckedOut: true,
			PlaceCancelled:  true,
			PlaceNoShow:     true,
			PlaceReferred:   true,
		},
	})
	sm.AddTransition(aggregate.Transition{
		ID:        TransitionAuthorize,
		EventType: EventTypeAuthorize,
		Inputs: map[string]int{
			PlaceAwaitingAuthorization: 1,
		},
		Outputs: map[string]int{
			// No output - just clears the awaiting_authorization state
		},
	})
	sm.AddTransition(aggregate.Transition{
		ID:        TransitionReferOut,
		EventType: EventTypeReferOut,
		Inputs: map[string]int{
			PlaceInProgress: 1,
		},
		Outputs: map[string]int{
			PlaceReferred: 1,
		},
	})

	// Register event handlers for state updates
	sm.RegisterHandler(EventTypeSchedule, func(state *State, event *runtime.Event) error {
		return applySchedule(state, event)
	})
	sm.RegisterHandler(EventTypeCheckIn, func(state *State, event *runtime.Event) error {
		return applyCheckIn(state, event)
	})
	sm.RegisterHandler(EventTypeStartExam, func(state *State, event *runtime.Event) error {
		return applyStartExam(state, event)
	})
	sm.RegisterHandler(EventTypeComplete, func(state *State, event *runtime.Event) error {
		return applyComplete(state, event)
	})
	sm.RegisterHandler(EventTypeCheckout, func(state *State, event *runtime.Event) error {
		return applyCheckout(state, event)
	})
	sm.RegisterHandler(EventTypeCancelRequested, func(state *State, event *runtime.Event) error {
		return applyCancelRequested(state, event)
	})
	sm.RegisterHandler(EventTypeCancelScheduled, func(state *State, event *runtime.Event) error {
		return applyCancelScheduled(state, event)
	})
	sm.RegisterHandler(EventTypeMarkNoShow, func(state *State, event *runtime.Event) error {
		return applyMarkNoShow(state, event)
	})
	sm.RegisterHandler(EventTypeSendToLab, func(state *State, event *runtime.Event) error {
		return applySendToLab(state, event)
	})
	sm.RegisterHandler(EventTypeReceiveResults, func(state *State, event *runtime.Event) error {
		return applyReceiveResults(state, event)
	})
	sm.RegisterHandler(EventTypeRequestAuth, func(state *State, event *runtime.Event) error {
		return applyRequestAuth(state, event)
	})
	sm.RegisterHandler(EventTypeAuthorize, func(state *State, event *runtime.Event) error {
		return applyAuthorize(state, event)
	})
	sm.RegisterHandler(EventTypeReferOut, func(state *State, event *runtime.Event) error {
		return applyReferOut(state, event)
	})
	return &Aggregate{sm: sm}
}

// ID returns the aggregate identifier.
func (a *Aggregate) ID() string {
	return a.sm.ID()
}

// Version returns the current event version.
func (a *Aggregate) Version() int {
	return a.sm.Version()
}

// State returns the current state.
func (a *Aggregate) State() any {
	return a.sm.State()
}

// Places returns current token distribution.
func (a *Aggregate) Places() map[string]int {
	places := make(map[string]int)
	for _, p := range AllPlaces() {
		places[p] = a.sm.Tokens(p)
	}
	return places
}

// EnabledTransitions returns transitions that can fire.
func (a *Aggregate) EnabledTransitions() []string {
	return a.sm.EnabledTransitions()
}

// CanFire checks if a transition can fire.
func (a *Aggregate) CanFire(transitionID string) bool {
	return a.sm.CanFire(transitionID)
}

// Fire executes a transition and returns the resulting event.
func (a *Aggregate) Fire(transitionID string, data any) (*runtime.Event, error) {
	return a.sm.Fire(transitionID, data)
}

// Apply applies an event to update the aggregate state.
func (a *Aggregate) Apply(event *runtime.Event) error {
	// Update state machine (this calls the registered handlers)
	return a.sm.Apply(event)
}

// Event application functions

func applySchedule(state *State, event *runtime.Event) error {
	// No data transformations for this transition
	_ = state
	_ = event
	return nil
}

func applyCheckIn(state *State, event *runtime.Event) error {
	// No data transformations for this transition
	_ = state
	_ = event
	return nil
}

func applyStartExam(state *State, event *runtime.Event) error {
	// No data transformations for this transition
	_ = state
	_ = event
	return nil
}

func applyComplete(state *State, event *runtime.Event) error {
	// No data transformations for this transition
	_ = state
	_ = event
	return nil
}

func applyCheckout(state *State, event *runtime.Event) error {
	// No data transformations for this transition
	_ = state
	_ = event
	return nil
}

func applyCancelRequested(state *State, event *runtime.Event) error {
	// No data transformations for this transition
	_ = state
	_ = event
	return nil
}

func applyCancelScheduled(state *State, event *runtime.Event) error {
	// No data transformations for this transition
	_ = state
	_ = event
	return nil
}

func applyMarkNoShow(state *State, event *runtime.Event) error {
	// No data transformations for this transition
	_ = state
	_ = event
	return nil
}

func applySendToLab(state *State, event *runtime.Event) error {
	// No data transformations for this transition
	_ = state
	_ = event
	return nil
}

func applyReceiveResults(state *State, event *runtime.Event) error {
	// No data transformations for this transition
	_ = state
	_ = event
	return nil
}

func applyRequestAuth(state *State, event *runtime.Event) error {
	// No data transformations for this transition
	_ = state
	_ = event
	return nil
}

func applyAuthorize(state *State, event *runtime.Event) error {
	// No data transformations for this transition
	_ = state
	_ = event
	return nil
}

func applyReferOut(state *State, event *runtime.Event) error {
	// No data transformations for this transition
	_ = state
	_ = event
	return nil
}

// Application wires together the aggregate and event store.
type Application struct {
	store eventstore.Store
}

// NewApplication creates a new application instance.
func NewApplication(store eventstore.Store) *Application {
	return &Application{store: store}
}

// Create creates a new aggregate and returns its ID.
func (app *Application) Create(ctx context.Context) (string, error) {
	agg := NewAggregate("")
	return agg.ID(), nil
}

// Load loads an aggregate from the event store.
func (app *Application) Load(ctx context.Context, id string) (*Aggregate, error) {
	events, err := app.store.Read(ctx, id, 0)
	if err != nil {
		return nil, fmt.Errorf("reading events: %w", err)
	}

	agg := NewAggregate(id)
	for _, event := range events {
		if err := agg.Apply(event); err != nil {
			return nil, fmt.Errorf("applying event %s: %w", event.ID, err)
		}
	}

	return agg, nil
}

// Execute fires a transition on an aggregate and persists the event.
func (app *Application) Execute(ctx context.Context, id, transitionID string, data any) (*Aggregate, error) {
	// Load current state
	agg, err := app.Load(ctx, id)
	if err != nil {
		return nil, err
	}

	// Check if transition can fire
	if !agg.CanFire(transitionID) {
		return nil, fmt.Errorf("transition %s cannot fire from current state", transitionID)
	}

	// Fire transition (this updates token counts but not version)
	event, err := agg.Fire(transitionID, data)
	if err != nil {
		return nil, fmt.Errorf("firing transition: %w", err)
	}

	// Persist event (this assigns the event version)
	// The expected version should match the current stream version (-1 for new streams)
	_, err = app.store.Append(ctx, id, agg.Version(), []*runtime.Event{event})
	if err != nil {
		return nil, fmt.Errorf("persisting event: %w", err)
	}

	// Apply the event to update the aggregate's version
	if err := agg.Apply(event); err != nil {
		return nil, fmt.Errorf("applying event: %w", err)
	}

	return agg, nil
}

// GetState returns the current state of an aggregate.
func (app *Application) GetState(ctx context.Context, id string) (*Aggregate, error) {
	return app.Load(ctx, id)
}

// HealthCheck verifies the event store is accessible.
func (app *Application) HealthCheck(ctx context.Context) error {
	// Try to read from a non-existent stream - this exercises the store connection
	_, err := app.store.Read(ctx, "__health_check__", 0)
	// Ignore "not found" errors - we just want to verify connectivity
	if err != nil && err.Error() != "stream not found" {
		return err
	}
	return nil
}

// Helper to unmarshal event data
func unmarshalEventData[T any](event *runtime.Event) (*T, error) {
	var data T
	if err := json.Unmarshal(event.Data, &data); err != nil {
		return nil, err
	}
	return &data, nil
}
