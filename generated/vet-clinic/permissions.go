// Code generated by petri-pilot. DO NOT EDIT.

package main

import (
	"fmt"
)

// Role constants
const (
	RoleOfficeManager = "office_manager"
	RoleDvm = "dvm"
	RoleRvt = "rvt"
	RoleVetAssistant = "vet_assistant"
	RoleFrontDesk = "front_desk"
)

// AllRolesFor maps each role to its effective roles (including inherited).
// For example, if admin inherits from user, AllRolesFor[RoleAdmin] = []string{"admin", "user"}.
var AllRolesFor = map[string][]string{
	RoleOfficeManager: { "office_manager" },
	RoleDvm: { "dvm" },
	RoleRvt: { "rvt" },
	RoleVetAssistant: { "vet_assistant" },
	RoleFrontDesk: { "front_desk" },
}

// HasRole checks if a user has a specific role (including inherited roles).
func HasRole(user *User, roleID string) bool {
	if user == nil {
		return false
	}

	// Get effective roles for each of the user's roles
	for _, userRole := range user.Roles {
		effectiveRoles, ok := AllRolesFor[userRole]
		if !ok {
			// Role not in hierarchy, just check direct match
			if userRole == roleID {
				return true
			}
			continue
		}

		for _, effective := range effectiveRoles {
			if effective == roleID {
				return true
			}
		}
	}

	return false
}

// HasAnyRole checks if a user has at least one of the specified roles.
func HasAnyRole(user *User, roleIDs []string) bool {
	if user == nil || len(roleIDs) == 0 {
		return false
	}

	for _, roleID := range roleIDs {
		if HasRole(user, roleID) {
			return true
		}
	}

	return false
}

// HasAnyRoleWithState checks if a user has at least one of the specified roles,
// including roles granted dynamically based on state.
func HasAnyRoleWithState(user *User, roleIDs []string, state map[string]any) bool {
	if user == nil || len(roleIDs) == 0 {
		return false
	}

	for _, roleID := range roleIDs {
		// First check static roles
		if HasRole(user, roleID) {
			return true
		}
		// Then check dynamic grants
		if HasDynamicRole(user, roleID, state) {
			return true
		}
	}

	return false
}

// HasDynamicRole checks if a user is dynamically granted a role based on state.
func HasDynamicRole(user *User, roleID string, state map[string]any) bool {
	if user == nil || state == nil {
		return false
	}

	// Build bindings for evaluation
	bindings := map[string]any{
		"user": map[string]any{
			"id":    user.ID,
			"login": user.Login,
			"email": user.Email,
			"roles": user.Roles,
		},
	}
	// Merge state into bindings
	for k, v := range state {
		bindings[k] = v
	}

	// Check dynamic grant expressions for each role
	switch roleID {
	}

	return false
}

// ErrUnauthorized is returned when a user is not authenticated.
var ErrUnauthorized = fmt.Errorf("unauthorized: authentication required")

// ErrForbidden is returned when a user lacks permission for an action.
var ErrForbidden = fmt.Errorf("forbidden: insufficient permissions")

// CheckRoleAccess verifies that a user has one of the required roles.
// Returns nil if access is granted, ErrUnauthorized if user is nil,
// or ErrForbidden if user lacks required roles.
func CheckRoleAccess(user *User, requiredRoles []string) error {
	if user == nil {
		return ErrUnauthorized
	}

	if len(requiredRoles) == 0 {
		// No role requirement - any authenticated user allowed
		return nil
	}

	if !HasAnyRole(user, requiredRoles) {
		return ErrForbidden
	}

	return nil
}


// CheckAccessSchedule verifies access for the schedule transition.
func CheckAccessSchedule(user *User, state map[string]any) error {
	if user == nil {
		return ErrUnauthorized
	}
	
	// Check role requirements (including dynamic role grants based on state)
	requiredRoles := []string{ "front_desk", "office_manager" }
	if !HasAnyRoleWithState(user, requiredRoles, state) {
		return ErrForbidden
	}
	
	
	return nil
}

// CheckAccessCancelRequested verifies access for the cancel_requested transition.
func CheckAccessCancelRequested(user *User, state map[string]any) error {
	if user == nil {
		return ErrUnauthorized
	}
	
	// Check role requirements (including dynamic role grants based on state)
	requiredRoles := []string{ "front_desk", "office_manager" }
	if !HasAnyRoleWithState(user, requiredRoles, state) {
		return ErrForbidden
	}
	
	
	return nil
}

// CheckAccessCancelScheduled verifies access for the cancel_scheduled transition.
func CheckAccessCancelScheduled(user *User, state map[string]any) error {
	if user == nil {
		return ErrUnauthorized
	}
	
	// Check role requirements (including dynamic role grants based on state)
	requiredRoles := []string{ "front_desk", "office_manager" }
	if !HasAnyRoleWithState(user, requiredRoles, state) {
		return ErrForbidden
	}
	
	
	return nil
}

// CheckAccessMarkNoShow verifies access for the mark_no_show transition.
func CheckAccessMarkNoShow(user *User, state map[string]any) error {
	if user == nil {
		return ErrUnauthorized
	}
	
	// Check role requirements (including dynamic role grants based on state)
	requiredRoles := []string{ "front_desk", "office_manager" }
	if !HasAnyRoleWithState(user, requiredRoles, state) {
		return ErrForbidden
	}
	
	
	return nil
}

// CheckAccessCheckIn verifies access for the check_in transition.
func CheckAccessCheckIn(user *User, state map[string]any) error {
	if user == nil {
		return ErrUnauthorized
	}
	
	// Check role requirements (including dynamic role grants based on state)
	requiredRoles := []string{ "front_desk", "vet_assistant", "office_manager" }
	if !HasAnyRoleWithState(user, requiredRoles, state) {
		return ErrForbidden
	}
	
	
	return nil
}

// CheckAccessStartExam verifies access for the start_exam transition.
func CheckAccessStartExam(user *User, state map[string]any) error {
	if user == nil {
		return ErrUnauthorized
	}
	
	// Check role requirements (including dynamic role grants based on state)
	requiredRoles := []string{ "dvm", "rvt", "office_manager" }
	if !HasAnyRoleWithState(user, requiredRoles, state) {
		return ErrForbidden
	}
	
	
	return nil
}

// CheckAccessSendToLab verifies access for the send_to_lab transition.
func CheckAccessSendToLab(user *User, state map[string]any) error {
	if user == nil {
		return ErrUnauthorized
	}
	
	// Check role requirements (including dynamic role grants based on state)
	requiredRoles := []string{ "dvm", "rvt", "office_manager" }
	if !HasAnyRoleWithState(user, requiredRoles, state) {
		return ErrForbidden
	}
	
	
	return nil
}

// CheckAccessReceiveResults verifies access for the receive_results transition.
func CheckAccessReceiveResults(user *User, state map[string]any) error {
	if user == nil {
		return ErrUnauthorized
	}
	
	// Check role requirements (including dynamic role grants based on state)
	requiredRoles := []string{ "dvm", "rvt", "office_manager" }
	if !HasAnyRoleWithState(user, requiredRoles, state) {
		return ErrForbidden
	}
	
	
	return nil
}

// CheckAccessComplete verifies access for the complete transition.
func CheckAccessComplete(user *User, state map[string]any) error {
	if user == nil {
		return ErrUnauthorized
	}
	
	// Check role requirements (including dynamic role grants based on state)
	requiredRoles := []string{ "dvm", "rvt", "office_manager" }
	if !HasAnyRoleWithState(user, requiredRoles, state) {
		return ErrForbidden
	}
	
	
	return nil
}

// CheckAccessRequestAuth verifies access for the request_auth transition.
func CheckAccessRequestAuth(user *User, state map[string]any) error {
	if user == nil {
		return ErrUnauthorized
	}
	
	// Check role requirements (including dynamic role grants based on state)
	requiredRoles := []string{ "dvm", "office_manager" }
	if !HasAnyRoleWithState(user, requiredRoles, state) {
		return ErrForbidden
	}
	
	
	return nil
}

// CheckAccessAuthorize verifies access for the authorize transition.
func CheckAccessAuthorize(user *User, state map[string]any) error {
	if user == nil {
		return ErrUnauthorized
	}
	
	// Check role requirements (including dynamic role grants based on state)
	requiredRoles := []string{ "dvm", "office_manager" }
	if !HasAnyRoleWithState(user, requiredRoles, state) {
		return ErrForbidden
	}
	
	
	return nil
}

// CheckAccessReferOut verifies access for the refer_out transition.
func CheckAccessReferOut(user *User, state map[string]any) error {
	if user == nil {
		return ErrUnauthorized
	}
	
	// Check role requirements (including dynamic role grants based on state)
	requiredRoles := []string{ "dvm", "office_manager" }
	if !HasAnyRoleWithState(user, requiredRoles, state) {
		return ErrForbidden
	}
	
	
	return nil
}

// CheckAccessCheckout verifies access for the checkout transition.
func CheckAccessCheckout(user *User, state map[string]any) error {
	if user == nil {
		return ErrUnauthorized
	}
	
	// Check role requirements (including dynamic role grants based on state)
	requiredRoles := []string{ "front_desk", "vet_assistant", "office_manager" }
	if !HasAnyRoleWithState(user, requiredRoles, state) {
		return ErrForbidden
	}
	
	
	return nil
}


// GetUserRoles returns the effective roles for a user (with inheritance expanded).
func GetUserRoles(user *User) []string {
	if user == nil {
		return nil
	}

	seen := make(map[string]bool)
	var result []string

	for _, role := range user.Roles {
		effectiveRoles, ok := AllRolesFor[role]
		if !ok {
			// Role not in hierarchy, add directly
			if !seen[role] {
				seen[role] = true
				result = append(result, role)
			}
			continue
		}

		for _, r := range effectiveRoles {
			if !seen[r] {
				seen[r] = true
				result = append(result, r)
			}
		}
	}

	return result
}
