// Generated by petri-pilot. DO NOT EDIT.

import { createNavigation, refreshNavigation } from './navigation.js'
import { navigate, initRouter, getRouteParams, getCurrentRoute } from './router.js'
import { loadViews, renderFormView, renderDetailView, renderTableView, getFormData } from './views.js'

// API client
const API_BASE = ''

// App state
let currentUser = null
let authToken = null
let instances = []
let currentInstance = null

// ============================================================================
// Auth
// ============================================================================

function loadAuth() {
  const stored = localStorage.getItem('auth')
  if (stored) {
    try {
      const auth = JSON.parse(stored)
      if (auth.expires_at && new Date(auth.expires_at) > new Date()) {
        authToken = auth.token
        currentUser = auth.user
        return true
      }
      localStorage.removeItem('auth')
    } catch (e) {
      localStorage.removeItem('auth')
    }
  }
  return false
}

function saveAuth(data) {
  localStorage.setItem('auth', JSON.stringify(data))
  authToken = data.token
  currentUser = data.user
  window.dispatchEvent(new CustomEvent('auth-change'))
}

function clearAuth() {
  localStorage.removeItem('auth')
  authToken = null
  currentUser = null
  window.dispatchEvent(new CustomEvent('auth-change'))
}

function getHeaders() {
  const headers = { 'Content-Type': 'application/json' }
  if (authToken) {
    headers['Authorization'] = `Bearer ${authToken}`
  }
  return headers
}

// ============================================================================
// API
// ============================================================================

async function handleResponse(response) {
  if (response.status === 401) {
    clearAuth()
    showError('Session expired. Please log in again.')
    throw new Error('Unauthorized')
  }
  if (!response.ok) {
    const error = await response.json().catch(() => ({}))
    throw new Error(error.message || response.statusText)
  }
  return response.json()
}

const api = {
  async getMe() {
    const response = await fetch(`${API_BASE}/auth/me`, { headers: getHeaders() })
    return handleResponse(response)
  },

  async logout() {
    await fetch(`${API_BASE}/auth/logout`, { method: 'POST', headers: getHeaders() })
    clearAuth()
  },

  async listInstances() {
    const response = await fetch(`${API_BASE}/admin/instances`, { headers: getHeaders() })
    return handleResponse(response)
  },

  async getInstance(id) {
    const response = await fetch(`${API_BASE}/api/accesstest/${id}`, { headers: getHeaders() })
    return handleResponse(response)
  },

  async createInstance(data = {}) {
    const response = await fetch(`${API_BASE}/api/accesstest`, {
      method: 'POST',
      headers: getHeaders(),
      body: JSON.stringify(data),
    })
    return handleResponse(response)
  },

  async executeTransition(transitionId, aggregateId, data = {}) {
    const response = await fetch(`${API_BASE}/api/${transitionId}`, {
      method: 'POST',
      headers: getHeaders(),
      body: JSON.stringify({ aggregate_id: aggregateId, data }),
    })
    return handleResponse(response)
  },
}

// Export for global access
window.api = api

// Export auth functions for testing
window.setAuthToken = function(token) {
  authToken = token
}
window.saveAuth = saveAuth
window.clearAuth = clearAuth

// ============================================================================
// UI Helpers
// ============================================================================

function showError(message) {
  const app = document.getElementById('app')
  const existing = app.querySelector('.alert-error')
  if (existing) existing.remove()

  const alert = document.createElement('div')
  alert.className = 'alert alert-error'
  alert.textContent = message
  app.insertBefore(alert, app.firstChild)

  setTimeout(() => alert.remove(), 5000)
}

function showSuccess(message) {
  const app = document.getElementById('app')
  const existing = app.querySelector('.alert-success')
  if (existing) existing.remove()

  const alert = document.createElement('div')
  alert.className = 'alert alert-success'
  alert.textContent = message
  app.insertBefore(alert, app.firstChild)

  setTimeout(() => alert.remove(), 3000)
}

// Get human-readable status from places
function getStatus(places) {
  if (!places) return 'unknown'
  for (const [place, tokens] of Object.entries(places)) {
    if (tokens > 0) return place
  }
  return 'unknown'
}

// Format status as badge
function formatStatus(status) {
  const statusClass = `badge-${status.toLowerCase().replace(/_/g, '-')}`
  return `<span class="badge ${statusClass}">${status.replace(/_/g, ' ')}</span>`
}

// ============================================================================
// Page Renderers
// ============================================================================

// List page - shows all instances
async function renderListPage() {
  const app = document.getElementById('app')
  app.innerHTML = `
    <div class="page">
      <div class="page-header">
        <h1>access-test</h1>
        <button class="btn btn-primary" onclick="handleCreateNew()">+ New</button>
      </div>
      <div id="instances-list" class="entity-list">
        <div class="loading">Loading...</div>
      </div>
    </div>
  `

  try {
    const result = await api.listInstances()
    instances = result.instances || []
    renderInstancesList()
  } catch (err) {
    document.getElementById('instances-list').innerHTML = `
      <div class="empty-state">
        <h3>No instances yet</h3>
        <p>Create your first instance to get started.</p>
        <button class="btn btn-primary" onclick="handleCreateNew()" style="margin-top: 1rem">+ Create New</button>
      </div>
    `
  }
}

function renderInstancesList() {
  const container = document.getElementById('instances-list')
  if (!container) return

  if (instances.length === 0) {
    container.innerHTML = `
      <div class="empty-state">
        <h3>No instances yet</h3>
        <p>Create your first instance to get started.</p>
        <button class="btn btn-primary" onclick="handleCreateNew()" style="margin-top: 1rem">+ Create New</button>
      </div>
    `
    return
  }

  container.innerHTML = instances.map(inst => {
    const status = getStatus(inst.state || inst.places)
    return `
      <div class="entity-card" onclick="navigate('/access-test/${inst.id}')">
        <div class="entity-info">
          <h3>${inst.id}</h3>
          <div class="entity-meta">
            ${formatStatus(status)} &middot; Version ${inst.version || 0}
          </div>
        </div>
        <div class="entity-actions">
          <button class="btn btn-sm btn-secondary" onclick="event.stopPropagation(); navigate('/access-test/${inst.id}')">
            View
          </button>
        </div>
      </div>
    `
  }).join('')
}

// Detail page - shows single instance with actions
async function renderDetailPage() {
  const params = getRouteParams()
  const id = params.id

  const app = document.getElementById('app')
  app.innerHTML = `
    <div class="page">
      <div class="page-header">
        <div>
          <button class="btn btn-link" onclick="navigate('/access-test')" style="margin-left: -0.5rem">
            &larr; Back to List
          </button>
          <h1 style="margin-top: 0.5rem">Instance: ${id}</h1>
        </div>
      </div>
      <div id="instance-detail">
        <div class="loading">Loading...</div>
      </div>
    </div>
  `

  try {
    const result = await api.getInstance(id)
    currentInstance = {
      id: result.aggregate_id || id,
      version: result.version,
      state: result.state,
      places: result.places,
      enabled: result.enabled || result.enabled_transitions || [],
    }
    renderInstanceDetail()
  } catch (err) {
    document.getElementById('instance-detail').innerHTML = `
      <div class="alert alert-error">Failed to load instance: ${err.message}</div>
    `
  }
}

function renderInstanceDetail() {
  const container = document.getElementById('instance-detail')
  if (!container || !currentInstance) return

  const status = getStatus(currentInstance.places)
  const enabled = currentInstance.enabled || []

  // Transition definitions
  const transitions = [
    { id: 'submit', name: 'Submit', description: 'Submit for review' },
    { id: 'approve', name: 'Approve', description: 'Approve the submission' },
    { id: 'reject', name: 'Reject', description: 'Reject the submission' },
  ]

  container.innerHTML = `
    <div class="card">
      <div class="card-header">Status</div>
      <div class="detail-list">
        <div class="detail-field">
          <dt>ID</dt>
          <dd><code>${currentInstance.id}</code></dd>
        </div>
        <div class="detail-field">
          <dt>Status</dt>
          <dd>${formatStatus(status)}</dd>
        </div>
        <div class="detail-field">
          <dt>Version</dt>
          <dd>${currentInstance.version || 0}</dd>
        </div>
      </div>
    </div>

    <div class="card">
      <div class="card-header">Actions</div>
      <div class="view-actions">
        ${transitions.map(t => {
          const isEnabled = enabled.includes(t.id)
          return `
            <button
              class="btn ${isEnabled ? 'btn-primary' : 'btn-secondary'}"
              onclick="handleTransition('${t.id}')"
              ${isEnabled ? '' : 'disabled'}
              title="${t.description || t.name}"
            >
              ${t.name}
            </button>
          `
        }).join('')}
      </div>
      ${enabled.length === 0 ? '<p style="color: #666; margin-top: 1rem;">No actions available in current state.</p>' : ''}
    </div>

    <div class="card">
      <div class="card-header">Current State</div>
      <div class="detail-list">
        ${Object.entries(currentInstance.places || {}).map(([place, tokens]) => `
          <div class="detail-field">
            <dt>${place}</dt>
            <dd>${tokens > 0 ? `<span class="badge badge-${place}">${tokens} token${tokens > 1 ? 's' : ''}</span>` : '<span style="color: #999;">0</span>'}</dd>
          </div>
        `).join('')}
      </div>
    </div>
  `
}

// Form page - create new instance
async function renderFormPage() {
  const app = document.getElementById('app')
  app.innerHTML = `
    <div class="page">
      <div class="page-header">
        <div>
          <button class="btn btn-link" onclick="navigate('/access-test')" style="margin-left: -0.5rem">
            &larr; Cancel
          </button>
          <h1 style="margin-top: 0.5rem">Create New</h1>
        </div>
      </div>
      <div class="card">
        <form id="create-form" onsubmit="handleSubmitCreate(event)">
          <p style="color: #666; margin-bottom: 1rem;">Create a new workflow instance. The instance will start in the initial state.</p>
          <div class="form-actions">
            <button type="submit" class="btn btn-primary">Create</button>
            <button type="button" class="btn btn-secondary" onclick="navigate('/access-test')">Cancel</button>
          </div>
        </form>
      </div>
    </div>
  `
}

// Admin dashboard
async function renderAdminPage() {
  const app = document.getElementById('app')
  app.innerHTML = `
    <div class="page">
      <div class="page-header">
        <h1>Admin Dashboard</h1>
      </div>
      <div id="admin-stats" class="card">
        <div class="loading">Loading statistics...</div>
      </div>
      <div id="admin-instances" class="card">
        <div class="card-header">Recent Instances</div>
        <div class="loading">Loading...</div>
      </div>
    </div>
  `

  try {
    const [stats, instancesResult] = await Promise.all([
      fetch(`${API_BASE}/admin/stats`, { headers: getHeaders() }).then(r => r.json()).catch(() => null),
      api.listInstances()
    ])

    if (stats) {
      document.getElementById('admin-stats').innerHTML = `
        <div class="card-header">Statistics</div>
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 1rem;">
          <div>
            <div style="font-size: 2rem; font-weight: 600;">${stats.total_streams || 0}</div>
            <div style="color: #666;">Total Instances</div>
          </div>
          <div>
            <div style="font-size: 2rem; font-weight: 600;">${stats.total_events || 0}</div>
            <div style="color: #666;">Total Events</div>
          </div>
        </div>
      `
    } else {
      document.getElementById('admin-stats').innerHTML = ''
    }

    instances = instancesResult.instances || []
    const container = document.getElementById('admin-instances').querySelector('.loading')
    if (container) {
      container.outerHTML = instances.length > 0
        ? `<table class="table">
            <thead>
              <tr>
                <th>ID</th>
                <th>Status</th>
                <th>Version</th>
                <th>Actions</th>
              </tr>
            </thead>
            <tbody>
              ${instances.slice(0, 20).map(inst => {
                const status = getStatus(inst.state || inst.places)
                return `
                  <tr>
                    <td><code>${inst.id}</code></td>
                    <td>${formatStatus(status)}</td>
                    <td>${inst.version || 0}</td>
                    <td><button class="btn btn-sm btn-link" onclick="navigate('/access-test/${inst.id}')">View</button></td>
                  </tr>
                `
              }).join('')}
            </tbody>
          </table>`
        : '<p style="color: #666; padding: 1rem;">No instances yet.</p>'
    }
  } catch (err) {
    showError('Failed to load admin data: ' + err.message)
  }
}

// ============================================================================
// Event Handlers
// ============================================================================

window.navigate = navigate

window.handleCreateNew = async function() {
  navigate('/access-test/new')
}

window.handleSubmitCreate = async function(event) {
  event.preventDefault()
  try {
    const result = await api.createInstance({})
    showSuccess('Instance created successfully!')
    navigate(`/access-test/${result.aggregate_id || result.id}`)
  } catch (err) {
    showError('Failed to create: ' + err.message)
  }
}

window.handleTransition = async function(transitionId) {
  if (!currentInstance) return

  try {
    const result = await api.executeTransition(transitionId, currentInstance.id)
    currentInstance = {
      ...currentInstance,
      version: result.version,
      state: result.state,
      places: result.state,
      enabled: result.enabled || [],
    }
    renderInstanceDetail()
    showSuccess(`Action "${transitionId}" completed!`)
  } catch (err) {
    showError(`Failed to execute ${transitionId}: ${err.message}`)
  }
}

// ============================================================================
// Routing
// ============================================================================

function handleRouteChange(event) {
  const route = event.detail?.route || getCurrentRoute()
  if (!route) {
    renderListPage()
    return
  }

  const path = route.path
  if (path === '/access-test' || path === '/') {
    renderListPage()
  } else if (path === '/access-test/new') {
    renderFormPage()
  } else if (path === '/access-test/:id') {
    renderDetailPage()
  } else if (path === '/admin' || path.startsWith('/admin')) {
    renderAdminPage()
  } else {
    renderListPage()
  }
}

// ============================================================================
// OAuth Callback Handler
// ============================================================================

async function handleOAuthCallback() {
  const params = new URLSearchParams(window.location.search)
  const token = params.get('token')
  const expiresAt = params.get('expires_at')

  if (token) {
    authToken = token
    try {
      const user = await api.getMe()
      saveAuth({ token, expires_at: expiresAt, user })
      window.history.replaceState({}, '', window.location.pathname)
      await refreshNavigation()
    } catch (err) {
      clearAuth()
      showError('Failed to complete login')
    }
  }
}

// ============================================================================
// Initialize
// ============================================================================

async function init() {
  // Load auth state
  loadAuth()

  // Handle OAuth callback
  await handleOAuthCallback()

  // Load view definitions
  await loadViews()

  // Render navigation
  const nav = document.getElementById('nav')
  nav.innerHTML = await createNavigation()

  // Setup routing
  window.addEventListener('route-change', handleRouteChange)
  initRouter()

  // Initial render
  handleRouteChange({ detail: { route: getCurrentRoute() } })
}


// ============================================================================
// Debug WebSocket Client
// ============================================================================

let debugWs = null
let debugSessionId = null

function initDebugWebSocket() {
  const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:'
  const wsUrl = `${wsProtocol}//${window.location.host}/ws`

  debugWs = new WebSocket(wsUrl)

  debugWs.onopen = () => {
    console.log('[Debug] WebSocket connected')
  }

  debugWs.onmessage = (event) => {
    try {
      const msg = JSON.parse(event.data)

      if (msg.id === 'session' && msg.type === 'session') {
        // Data is already parsed from JSON
        const data = typeof msg.data === 'string' ? JSON.parse(msg.data) : msg.data
        debugSessionId = data.session_id
        console.log('[Debug] Session ID:', debugSessionId)
      } else if (msg.type === 'eval') {
        handleDebugEval(msg)
      }
    } catch (e) {
      console.error('[Debug] Failed to parse message:', e)
    }
  }

  debugWs.onclose = () => {
    console.log('[Debug] WebSocket disconnected, reconnecting in 3s...')
    debugSessionId = null
    setTimeout(initDebugWebSocket, 3000)
  }

  debugWs.onerror = (err) => {
    console.error('[Debug] WebSocket error:', err)
  }
}

async function handleDebugEval(msg) {
  try {
    // Data may be parsed object or string
    const data = typeof msg.data === 'string' ? JSON.parse(msg.data) : msg.data
    const code = data.code

    // Execute the code using Function constructor
    const fn = new Function('return (async () => { ' + code + ' })()')
    const result = await fn()

    // Send response back - data should be an object, not a string
    const response = {
      type: 'response',
      id: msg.id,
      data: {
        result: result,
        type: typeof result
      }
    }
    debugWs.send(JSON.stringify(response))
  } catch (e) {
    // Send error response
    const response = {
      type: 'response',
      id: msg.id,
      data: {
        error: e.message
      }
    }
    debugWs.send(JSON.stringify(response))
  }
}

// Export debug functions for external use
window.debugSessionId = () => debugSessionId
window.debugWs = () => debugWs

// ============================================================================
// Pilot - Debug/Test Driving API
// ============================================================================

/**
 * window.pilot provides a clean API for driving the app programmatically.
 * Use this for:
 * - Automated E2E tests via the debug WebSocket
 * - Manual debugging from the browser console
 * - Visual confirmation of UI behavior
 */
window.pilot = {
  // --- Navigation ---

  /** Navigate to the list page */
  async list() {
    navigate('/access-test')
    // Wait for instances to load
    await this.waitFor('.entity-card, .empty-state', 5000).catch(() => {})
    return instances
  },

  /** Navigate to create new instance form */
  newForm() {
    navigate('/access-test/new')
    return this.waitForRender()
  },

  /** Navigate to view a specific instance */
  async view(id) {
    navigate(`/access-test/${id}`)
    await this.waitForRender()
    return currentInstance
  },

  /** Navigate to admin dashboard */
  admin() {
    navigate('/admin')
    return this.waitForRender()
  },

  // --- Instance Operations ---

  /** Create a new instance and navigate to it */
  async create(data = {}) {
    const result = await api.createInstance(data)
    const id = result.aggregate_id || result.id
    navigate(`/access-test/${id}`)
    await this.waitForRender()
    return { id, ...result }
  },

  /** Get the current instance (from detail page) */
  getCurrentInstance() {
    return currentInstance
  },

  /** Get all loaded instances (from list page) */
  getInstances() {
    return instances
  },

  /** Reload current instance state from API */
  async refresh() {
    if (!currentInstance) throw new Error('No current instance')
    const result = await api.getInstance(currentInstance.id)
    currentInstance = {
      id: result.aggregate_id || currentInstance.id,
      version: result.version,
      state: result.state,
      places: result.places,
      enabled: result.enabled || result.enabled_transitions || [],
    }
    renderInstanceDetail()
    return currentInstance
  },

  // --- Actions ---

  /** Execute a transition on the current instance */
  async action(transitionId, data = {}) {
    if (!currentInstance) throw new Error('No current instance - navigate to detail page first')
    const result = await api.executeTransition(transitionId, currentInstance.id, data)
    currentInstance = {
      ...currentInstance,
      version: result.version,
      state: result.state,
      places: result.state,
      enabled: result.enabled || [],
    }
    renderInstanceDetail()
    return { success: true, state: currentInstance.places, enabled: currentInstance.enabled }
  },

  /** Check if a transition is enabled for the current instance */
  isEnabled(transitionId) {
    if (!currentInstance) return false
    return (currentInstance.enabled || []).includes(transitionId)
  },

  /** Get list of enabled transitions */
  getEnabled() {
    return currentInstance?.enabled || []
  },

  // --- Form Operations ---

  /** Fill a form field by name */
  fill(name, value) {
    const input = document.querySelector(`[name="${name}"]`)
    if (!input) throw new Error(`No input found with name: ${name}`)
    input.value = value
    input.dispatchEvent(new Event('input', { bubbles: true }))
    return this
  },

  /** Submit the current form */
  async submit() {
    const form = document.querySelector('form')
    if (!form) throw new Error('No form found on page')
    const event = new Event('submit', { bubbles: true, cancelable: true })
    form.dispatchEvent(event)
    await this.waitForRender()
    return currentInstance
  },

  // --- UI Inspection ---

  /** Get text content of an element */
  getText(selector) {
    const el = document.querySelector(selector)
    return el ? el.textContent.trim() : null
  },

  /** Check if an element exists */
  exists(selector) {
    return document.querySelector(selector) !== null
  },

  /** Get all buttons on the page */
  getButtons() {
    return Array.from(document.querySelectorAll('button')).map(btn => ({
      text: btn.textContent.trim(),
      disabled: btn.disabled,
      className: btn.className,
    }))
  },

  /** Click a button by text */
  async clickButton(text) {
    const buttons = document.querySelectorAll('button')
    for (const btn of buttons) {
      if (btn.textContent.trim() === text && !btn.disabled) {
        btn.click()
        await this.waitForRender()
        return true
      }
    }
    throw new Error(`No enabled button found with text: ${text}`)
  },

  // --- State ---

  /** Get the current Petri net state (places with token counts) */
  getState() {
    return currentInstance?.places || null
  },

  /** Get the current status (place with token) */
  getStatus() {
    if (!currentInstance?.places) return null
    for (const [place, tokens] of Object.entries(currentInstance.places)) {
      if (tokens > 0) return place
    }
    return null
  },

  /** Get the current route */
  getRoute() {
    return getCurrentRoute()
  },

  /** Get current authenticated user */
  getUser() {
    return currentUser
  },

  /** Check if user is authenticated */
  isAuthenticated() {
    return authToken !== null
  },

  // --- Utilities ---

  /** Wait for render to complete */
  waitForRender(ms = 50) {
    return new Promise(resolve => setTimeout(resolve, ms))
  },

  /** Wait for an element to appear */
  async waitFor(selector, timeout = 5000) {
    const start = Date.now()
    while (Date.now() - start < timeout) {
      if (document.querySelector(selector)) {
        return document.querySelector(selector)
      }
      await this.waitForRender(50)
    }
    throw new Error(`Timeout waiting for: ${selector}`)
  },

  /** Wait for current instance to be in a specific state */
  async waitForState(place, timeout = 5000) {
    const start = Date.now()
    while (Date.now() - start < timeout) {
      if (currentInstance?.places?.[place] > 0) {
        return currentInstance
      }
      await this.waitForRender(100)
    }
    throw new Error(`Timeout waiting for state: ${place}`)
  },

  /** Log current state to console (for debugging) */
  debug() {
    console.log('=== Pilot Debug ===')
    console.log('Route:', getCurrentRoute())
    console.log('User:', currentUser)
    console.log('Instance:', currentInstance)
    console.log('Enabled:', currentInstance?.enabled)
    console.log('State:', currentInstance?.places)
    return {
      route: getCurrentRoute(),
      user: currentUser,
      instance: currentInstance,
    }
  },

  // --- Event Sourcing ---

  /** Get event history for current instance */
  async getEvents() {
    if (!currentInstance) throw new Error('No current instance')
    const response = await fetch(`${API_BASE}/api/accesstest/${currentInstance.id}/events`, {
      headers: getHeaders()
    })
    const data = await handleResponse(response)
    return data.events || []
  },

  /** Get event count for current instance */
  async getEventCount() {
    const events = await this.getEvents()
    return events.length
  },

  /** Get the last event for current instance */
  async getLastEvent() {
    const events = await this.getEvents()
    return events.length > 0 ? events[events.length - 1] : null
  },

  /** Replay instance to a specific version (read-only view) */
  async replayTo(version) {
    if (!currentInstance) throw new Error('No current instance')
    const events = await this.getEvents()
    const filtered = events.filter(e => (e.version || e.sequence) <= version)

    // Compute state by applying events up to version
    const places = {}
    // Initialize with first event or empty
    for (const event of filtered) {
      if (event.state) {
        Object.assign(places, event.state)
      }
    }
    return { version, events: filtered, places }
  },

  // --- Role/Auth Testing ---

  /** Login as a specific role (or array of roles) */
  async loginAs(roles) {
    const rolesArray = typeof roles === 'string' ? [roles] : roles
    const response = await fetch(`${API_BASE}/api/debug/login`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ login: 'pilot-user', roles: rolesArray }),
    })
    const data = await response.json()
    saveAuth(data)
    await this.waitForRender(100)
    return data
  },

  /** Logout current user */
  logout() {
    clearAuth()
    return this.waitForRender()
  },

  /** Get current user's roles */
  getRoles() {
    return currentUser?.roles || []
  },

  /** Check if current user has a specific role */
  hasRole(role) {
    return this.getRoles().includes(role)
  },

  // --- Assertions (throw on failure) ---

  /** Assert current instance is in expected state */
  assertState(expectedPlace) {
    const status = this.getStatus()
    if (status !== expectedPlace) {
      throw new Error(`Expected state '${expectedPlace}', got '${status}'`)
    }
    return this
  },

  /** Assert a transition is enabled */
  assertEnabled(transitionId) {
    if (!this.isEnabled(transitionId)) {
      const enabled = this.getEnabled()
      throw new Error(`Expected '${transitionId}' to be enabled. Enabled: [${enabled.join(', ')}]`)
    }
    return this
  },

  /** Assert a transition is disabled */
  assertDisabled(transitionId) {
    if (this.isEnabled(transitionId)) {
      throw new Error(`Expected '${transitionId}' to be disabled, but it is enabled`)
    }
    return this
  },

  /** Assert element exists in DOM */
  assertExists(selector) {
    if (!this.exists(selector)) {
      throw new Error(`Expected element '${selector}' to exist`)
    }
    return this
  },

  /** Assert element contains text */
  assertText(selector, expected) {
    const actual = this.getText(selector)
    if (actual !== expected) {
      throw new Error(`Expected '${selector}' to contain '${expected}', got '${actual}'`)
    }
    return this
  },

  /** Assert user is authenticated */
  assertAuthenticated() {
    if (!this.isAuthenticated()) {
      throw new Error('Expected user to be authenticated')
    }
    return this
  },

  /** Assert user has role */
  assertRole(role) {
    if (!this.hasRole(role)) {
      throw new Error(`Expected user to have role '${role}'. Has: [${this.getRoles().join(', ')}]`)
    }
    return this
  },

  // --- Workflow Introspection ---

  /** Get all transition definitions */
  getTransitions() {
    return [
      { id: 'submit', name: 'Submit', description: 'Submit for review' },
      { id: 'approve', name: 'Approve', description: 'Approve the submission' },
      { id: 'reject', name: 'Reject', description: 'Reject the submission' },
    ]
  },

  /** Get all place definitions */
  getPlaces() {
    return [
      { id: 'draft', name: 'Draft', initial: 1 },
      { id: 'submitted', name: 'Submitted', initial: 0 },
      { id: 'approved', name: 'Approved', initial: 0 },
      { id: 'rejected', name: 'Rejected', initial: 0 },
    ]
  },

  /** Get transition by ID */
  getTransition(id) {
    return this.getTransitions().find(t => t.id === id) || null
  },

  /** Check if transition can fire, with reason if not */
  canFire(transitionId) {
    const transition = this.getTransition(transitionId)
    if (!transition) {
      return { canFire: false, reason: `Unknown transition: ${transitionId}` }
    }

    if (!currentInstance) {
      return { canFire: false, reason: 'No current instance' }
    }

    const enabled = this.isEnabled(transitionId)
    if (!enabled) {
      const status = this.getStatus()
      return {
        canFire: false,
        reason: `Transition '${transitionId}' not enabled in state '${status}'`,
        currentState: status,
        enabledTransitions: this.getEnabled()
      }
    }

    // Note: Role checks are enforced server-side
    return { canFire: true }
  },

  /** Execute a sequence of transitions */
  async sequence(transitionIds, options = {}) {
    const results = []
    const { stopOnError = true, data = {} } = options

    for (const id of transitionIds) {
      const check = this.canFire(id)
      if (!check.canFire) {
        if (stopOnError) {
          throw new Error(`Sequence failed at '${id}': ${check.reason}`)
        }
        results.push({ transition: id, success: false, error: check.reason })
        continue
      }

      try {
        const result = await this.action(id, data[id] || {})
        results.push({ transition: id, success: true, state: result.state })
      } catch (e) {
        if (stopOnError) throw e
        results.push({ transition: id, success: false, error: e.message })
      }
    }

    return results
  },

  /** Get workflow summary */
  getWorkflowInfo() {
    return {
      places: this.getPlaces(),
      transitions: this.getTransitions(),
      initialPlace: this.getPlaces().find(p => p.initial > 0)?.id,
    }
  },
}


// Start the app
init()


// Initialize debug WebSocket after app init
initDebugWebSocket()

