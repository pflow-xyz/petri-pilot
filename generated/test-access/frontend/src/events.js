// Generated by petri-pilot. DO NOT EDIT.


/**
 * Event History Viewer
 * Provides time-travel debugging, event replay, and snapshot management
 */

// Helper functions from main.js
const API_BASE = window.API_BASE || ''
const getHeaders = window.getHeaders || (() => ({}))
const handleResponse = window.handleResponse || (r => r.json())
const showError = window.showError || console.error

// Event history state
let currentEvents = []
let selectedVersion = null
let stateAtVersion = null
let snapshotInProgress = false
let replayInProgress = false

// API client for event operations
const eventsAPI = {
  // Get event history for an aggregate
  async getEvents(aggregateId, fromVersion = 0) {
    const response = await fetch(`${API_BASE}/api/access-test/${aggregateId}/events?from=${fromVersion}`, {
      headers: getHeaders(),
    })
    return handleResponse(response)
  },

  // Get state at a specific version (time travel)
  async getStateAtVersion(aggregateId, version) {
    const response = await fetch(`${API_BASE}/api/access-test/${aggregateId}/at/${version}`, {
      headers: getHeaders(),
    })
    return handleResponse(response)
  },

  
  // Create a snapshot of current state
  async createSnapshot(aggregateId) {
    const response = await fetch(`${API_BASE}/api/access-test/${aggregateId}/snapshot`, {
      method: 'POST',
      headers: getHeaders(),
    })
    return handleResponse(response)
  },

  // Replay from snapshot
  async replayFromSnapshot(aggregateId) {
    const response = await fetch(`${API_BASE}/api/access-test/${aggregateId}/replay`, {
      method: 'POST',
      headers: getHeaders(),
    })
    return handleResponse(response)
  },
  
}

// Render event history viewer
export function renderEventViewer(aggregateId) {
  if (!aggregateId) {
    return `
      <div class="event-viewer-empty">
        <p>Please load an aggregate to view its event history</p>
      </div>
    `
  }

  return `
    <div class="event-viewer">
      <div class="event-viewer-header">
        <h2>Event History</h2>
        <div class="event-viewer-controls">
          <button id="refresh-events-btn" class="btn btn-secondary">
            üîÑ Refresh
          </button>
          
          <button id="create-snapshot-btn" class="btn btn-secondary">
            üì∏ Create Snapshot
          </button>
          <button id="replay-snapshot-btn" class="btn btn-secondary">
            ‚èÆÔ∏è Replay from Snapshot
          </button>
          
        </div>
      </div>

      <div class="event-viewer-body">
        <!-- Timeline -->
        <div class="event-timeline-section">
          <h3>Timeline</h3>
          <div id="event-timeline" class="event-timeline">
            <p class="loading">Loading events...</p>
          </div>
        </div>

        <!-- State at Version Viewer -->
        <div class="state-viewer-section">
          <h3>State Inspector</h3>
          <div id="state-at-version" class="state-at-version">
            <p class="hint">Click on an event in the timeline to view state at that version</p>
          </div>
        </div>

        <!-- Diff Viewer -->
        <div class="diff-viewer-section" id="diff-viewer-section" style="display: none;">
          <h3>State Changes</h3>
          <div id="state-diff" class="state-diff"></div>
        </div>
      </div>
    </div>
  `
}

// Load and render event timeline
export async function loadEventTimeline(aggregateId) {
  const timeline = document.getElementById('event-timeline')
  if (!timeline) return

  try {
    const result = await eventsAPI.getEvents(aggregateId)
    currentEvents = result.events || []
    
    if (currentEvents.length === 0) {
      timeline.innerHTML = '<p class="empty">No events found</p>'
      return
    }

    renderTimeline()
  } catch (err) {
    timeline.innerHTML = `<p class="error">Failed to load events: ${err.message}</p>`
  }
}

function renderTimeline() {
  const timeline = document.getElementById('event-timeline')
  if (!timeline) return

  timeline.innerHTML = currentEvents.map(event => {
    const isSelected = selectedVersion === event.version
    return `
      <div class="event-item ${isSelected ? 'selected' : ''}" data-version="${event.version}">
        <div class="event-marker">
          <span class="event-version">v${event.version}</span>
        </div>
        <div class="event-content">
          <div class="event-type">${formatEventType(event.type)}</div>
          <div class="event-meta">
            <span class="event-id">${event.id.substring(0, 8)}</span>
            <span class="event-timestamp">${formatTimestamp(event.timestamp)}</span>
          </div>
          ${event.data ? `<div class="event-data-preview">${formatDataPreview(event.data)}</div>` : ''}
        </div>
      </div>
    `
  }).join('')

  // Add click handlers
  timeline.querySelectorAll('.event-item').forEach(item => {
    item.addEventListener('click', () => {
      const version = parseInt(item.dataset.version)
      selectVersion(version)
    })
  })
}

// Select a version and show state at that point
async function selectVersion(version) {
  const aggregateId = window.aggregateId
  if (!aggregateId) return

  selectedVersion = version
  renderTimeline() // Update selection highlight

  const stateViewer = document.getElementById('state-at-version')
  if (!stateViewer) return

  stateViewer.innerHTML = '<p class="loading">Loading state at version ' + version + '...</p>'

  try {
    const result = await eventsAPI.getStateAtVersion(aggregateId, version)
    stateAtVersion = result
    renderStateAtVersion()
    
    // Show diff if we have a previous version
    if (version > 0) {
      showStateDiff(version)
    }
  } catch (err) {
    stateViewer.innerHTML = `<p class="error">Failed to load state: ${err.message}</p>`
  }
}

function renderStateAtVersion() {
  const stateViewer = document.getElementById('state-at-version')
  if (!stateViewer || !stateAtVersion) return

  // API response may have places at top level or nested in state object
  const places = stateAtVersion.places || stateAtVersion.state?.places || {}
  const version = stateAtVersion.version || selectedVersion

  stateViewer.innerHTML = `
    <div class="state-snapshot">
      <div class="state-header">
        <h4>State at Version ${version}</h4>
      </div>
      <div class="state-places">
        ${Object.entries(places).map(([placeId, tokens]) => `
          <div class="state-place ${tokens > 0 ? 'active' : 'inactive'}">
            <span class="place-name">${placeId}</span>
            <span class="place-tokens">${tokens}</span>
          </div>
        `).join('')}
      </div>
      ${stateAtVersion.enabled_transitions ? `
        <div class="state-transitions">
          <strong>Enabled transitions:</strong>
          ${stateAtVersion.enabled_transitions.map(t => `<span class="enabled-tag">${t}</span>`).join('')}
        </div>
      ` : ''}
    </div>
  `
}

async function showStateDiff(version) {
  const aggregateId = window.aggregateId
  const diffSection = document.getElementById('diff-viewer-section')
  const diffViewer = document.getElementById('state-diff')
  if (!diffViewer || !diffSection) return

  try {
    // Get previous version state
    const prevResult = await eventsAPI.getStateAtVersion(aggregateId, version - 1)
    const prevPlaces = prevResult.places || prevResult.state?.places || {}
    const currPlaces = stateAtVersion.places || stateAtVersion.state?.places || {}

    // Calculate diff
    const diff = calculatePlacesDiff(prevPlaces, currPlaces)
    
    if (diff.length === 0) {
      diffSection.style.display = 'none'
      return
    }

    diffSection.style.display = 'block'
    diffViewer.innerHTML = `
      <div class="diff-items">
        ${diff.map(change => `
          <div class="diff-item ${change.type}">
            <span class="diff-place">${change.place}</span>
            <span class="diff-change">
              ${change.before} ‚Üí ${change.after}
              ${change.delta !== 0 ? `<span class="diff-delta">(${change.delta > 0 ? '+' : ''}${change.delta})</span>` : ''}
            </span>
          </div>
        `).join('')}
      </div>
    `
  } catch (err) {
    console.error('Failed to show diff:', err)
  }
}

function calculatePlacesDiff(before, after) {
  const changes = []
  const allPlaces = new Set([...Object.keys(before), ...Object.keys(after)])

  allPlaces.forEach(place => {
    const beforeVal = before[place] || 0
    const afterVal = after[place] || 0
    
    if (beforeVal !== afterVal) {
      changes.push({
        place,
        before: beforeVal,
        after: afterVal,
        delta: afterVal - beforeVal,
        type: afterVal > beforeVal ? 'increase' : 'decrease'
      })
    }
  })

  return changes
}


// Create snapshot
async function createSnapshot() {
  const aggregateId = window.aggregateId
  if (!aggregateId || snapshotInProgress) return

  const btn = document.getElementById('create-snapshot-btn')
  const originalText = btn.textContent
  
  snapshotInProgress = true
  btn.disabled = true
  btn.textContent = '‚è≥ Creating snapshot...'

  try {
    await eventsAPI.createSnapshot(aggregateId)
    btn.textContent = '‚úÖ Snapshot created'
    setTimeout(() => {
      btn.textContent = originalText
      btn.disabled = false
      snapshotInProgress = false
    }, 2000)
  } catch (err) {
    showError(`Failed to create snapshot: ${err.message}`)
    btn.textContent = originalText
    btn.disabled = false
    snapshotInProgress = false
  }
}

// Replay from snapshot
async function replayFromSnapshot() {
  const aggregateId = window.aggregateId
  if (!aggregateId || replayInProgress) return

  const btn = document.getElementById('replay-snapshot-btn')
  const originalText = btn.textContent
  
  replayInProgress = true
  btn.disabled = true
  btn.textContent = '‚è≥ Replaying...'

  try {
    const result = await eventsAPI.replayFromSnapshot(aggregateId)
    btn.textContent = '‚úÖ Replay complete'
    
    // Refresh the current view
    if (typeof window.loadState === 'function') {
      await window.loadState()
    }
    
    setTimeout(() => {
      btn.textContent = originalText
      btn.disabled = false
      replayInProgress = false
    }, 2000)
  } catch (err) {
    showError(`Failed to replay: ${err.message}`)
    btn.textContent = originalText
    btn.disabled = false
    replayInProgress = false
  }
}


// Formatting helpers
function formatEventType(type) {
  // Convert snake_case or camelCase to Title Case
  // Handle both CamelCase and snake_case
  return type
    .replace(/([A-Z])/g, (match, p1, offset) => (offset > 0 ? ' ' : '') + p1)
    .replace(/_/g, ' ')
    .replace(/^./, str => str.toUpperCase())
    .trim()
}

function formatTimestamp(timestamp) {
  if (!timestamp) return 'Unknown'
  const date = new Date(timestamp)
  return date.toLocaleString()
}

function formatDataPreview(data) {
  if (!data) return ''
  try {
    const obj = typeof data === 'string' ? JSON.parse(data) : data
    const keys = Object.keys(obj)
    if (keys.length === 0) return ''
    if (keys.length === 1) {
      return `${keys[0]}: ${JSON.stringify(obj[keys[0]])}`
    }
    return `${keys.length} fields`
  } catch (e) {
    return ''
  }
}

// Initialize event handlers when DOM is ready
export function initEventViewer() {
  document.addEventListener('click', (e) => {
    if (e.target.id === 'refresh-events-btn') {
      const aggregateId = window.aggregateId
      loadEventTimeline(aggregateId)
    }
    
    else if (e.target.id === 'create-snapshot-btn') {
      createSnapshot()
    }
    else if (e.target.id === 'replay-snapshot-btn') {
      replayFromSnapshot()
    }
    
  })
}

