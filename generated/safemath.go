// Code generated by petri-pilot. DO NOT EDIT.

package main

import (
	"encoding/json"
	"errors"
	"fmt"
	"math/big"

	"github.com/holiman/uint256"
)

var (
	ErrOverflow       = errors.New("arithmetic overflow")
	ErrUnderflow      = errors.New("arithmetic underflow")
	ErrDivisionByZero = errors.New("division by zero")
)

// U256 is an alias for uint256.Int for convenience.
type U256 = uint256.Int

// NewU256 creates a new U256 from a uint64.
func NewU256(v uint64) *U256 {
	return uint256.NewInt(v)
}

// NewU256FromString parses a decimal string into a U256.
func NewU256FromString(s string) (*U256, error) {
	if s == "" {
		return NewU256(0), nil
	}
	z := new(U256)
	if err := z.SetFromDecimal(s); err != nil {
		return nil, fmt.Errorf("invalid decimal string: %w", err)
	}
	return z, nil
}

// NewU256FromBig creates a U256 from a big.Int.
// Returns nil if the value overflows or is negative.
func NewU256FromBig(b *big.Int) *U256 {
	if b == nil || b.Sign() < 0 {
		return nil
	}
	z := new(U256)
	overflow := z.SetFromBig(b)
	if overflow {
		return nil
	}
	return z
}

// U256Zero returns a new zero U256.
func U256Zero() *U256 {
	return NewU256(0)
}

// U256Clone creates a copy of a U256.
func U256Clone(v *U256) *U256 {
	if v == nil {
		return nil
	}
	return new(U256).Set(v)
}

// SafeAdd returns a + b, or error if overflow.
func SafeAdd(a, b *U256) (*U256, error) {
	result := new(U256)
	_, overflow := result.AddOverflow(a, b)
	if overflow {
		return nil, ErrOverflow
	}
	return result, nil
}

// SafeSub returns a - b, or error if underflow.
func SafeSub(a, b *U256) (*U256, error) {
	result := new(U256)
	_, underflow := result.SubOverflow(a, b)
	if underflow {
		return nil, ErrUnderflow
	}
	return result, nil
}

// SafeMul returns a * b, or error if overflow.
func SafeMul(a, b *U256) (*U256, error) {
	result := new(U256)
	_, overflow := result.MulOverflow(a, b)
	if overflow {
		return nil, ErrOverflow
	}
	return result, nil
}

// SafeDiv returns a / b, or error if b is zero.
func SafeDiv(a, b *U256) (*U256, error) {
	if b.IsZero() {
		return nil, ErrDivisionByZero
	}
	result := new(U256)
	result.Div(a, b)
	return result, nil
}

// MulDiv computes (a * b) / c with full precision intermediate result.
func MulDiv(a, b, c *U256) (*U256, error) {
	if c.IsZero() {
		return nil, ErrDivisionByZero
	}
	result := new(U256)
	result.MulDivOverflow(a, b, c)
	return result, nil
}

// U256JSON wraps a U256 for JSON marshaling as a decimal string.
type U256JSON struct {
	*U256
}

// MarshalJSON marshals the U256 as a decimal string.
func (u U256JSON) MarshalJSON() ([]byte, error) {
	if u.U256 == nil {
		return []byte(`"0"`), nil
	}
	return json.Marshal(u.U256.Dec())
}

// UnmarshalJSON unmarshals a decimal string or number into U256.
func (u *U256JSON) UnmarshalJSON(data []byte) error {
	// Try as string first
	var s string
	if err := json.Unmarshal(data, &s); err == nil {
		val, err := NewU256FromString(s)
		if err != nil {
			return err
		}
		u.U256 = val
		return nil
	}

	// Try as number (json.Number preserves precision)
	var n json.Number
	if err := json.Unmarshal(data, &n); err == nil {
		val, err := NewU256FromString(n.String())
		if err != nil {
			return err
		}
		u.U256 = val
		return nil
	}

	return fmt.Errorf("cannot unmarshal %s into U256", string(data))
}

// Int64 returns the value as int64, or 0 if nil.
// Note: May overflow for values larger than 2^63-1.
func (u U256JSON) Int64() int64 {
	if u.U256 == nil {
		return 0
	}
	return int64(u.U256.Uint64())
}

// Uint64 returns the value as uint64, or 0 if nil.
// Note: May overflow for values larger than 2^64-1.
func (u U256JSON) Uint64() uint64 {
	if u.U256 == nil {
		return 0
	}
	return u.U256.Uint64()
}

// U256OrZero returns the value or zero if nil.
func U256OrZero(v *U256) *U256 {
	if v == nil {
		return U256Zero()
	}
	return v
}

// U256Cmp compares two U256 values.
// Returns -1 if a < b, 0 if a == b, 1 if a > b.
func U256Cmp(a, b *U256) int {
	return a.Cmp(b)
}

// U256Gte returns true if a >= b.
func U256Gte(a, b *U256) bool {
	return a.Cmp(b) >= 0
}

// U256Gt returns true if a > b.
func U256Gt(a, b *U256) bool {
	return a.Cmp(b) > 0
}

// U256Lte returns true if a <= b.
func U256Lte(a, b *U256) bool {
	return a.Cmp(b) <= 0
}

// U256Lt returns true if a < b.
func U256Lt(a, b *U256) bool {
	return a.Cmp(b) < 0
}

// U256Eq returns true if a == b.
func U256Eq(a, b *U256) bool {
	return a.Cmp(b) == 0
}
