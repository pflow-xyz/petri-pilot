// Code generated by petri-pilot. DO NOT EDIT.

package main

import (
	"context"
	"fmt"
	"net/http"
	"strings"
	"time"

	"github.com/pflow-xyz/petri-pilot/pkg/dsl"
)

// Middleware provides access control for transitions.
type Middleware struct {
	sessions      SessionStore
	rules         map[string]*AccessControl // transition ID -> access control
	roleHierarchy map[string][]string       // role -> parent roles
}

// AccessControl defines who can execute a transition.
type AccessControl struct {
	TransitionID string
	Roles        []string // Allowed roles (empty = any authenticated user)
	Guard        string   // Optional guard expression
}

// NewMiddleware creates a new middleware instance.
func NewMiddleware(sessions SessionStore, rules []*AccessControl) *Middleware {
	ruleMap := make(map[string]*AccessControl)
	for _, rule := range rules {
		ruleMap[rule.TransitionID] = rule
	}
	
	// Build role hierarchy (child -> parents)
	roleHierarchy := make(map[string][]string)
	
	
	
	
	
	
	
	roleHierarchy["admin"] = []string{ "author", "editor" }
	
	
	
	
	return &Middleware{
		sessions:      sessions,
		rules:         ruleMap,
		roleHierarchy: roleHierarchy,
	}
}

// RequireAuth enforces authentication (any valid user).
func (m *Middleware) RequireAuth(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		user := UserFromContext(r.Context())
		if user == nil {
			http.Error(w, "unauthorized", http.StatusUnauthorized)
			return
		}
		next.ServeHTTP(w, r)
	})
}

// RequireRole enforces role-based access control.
// Accepts a list of allowed roles. User must have at least one.
func (m *Middleware) RequireRole(roles ...string) func(http.Handler) http.Handler {
	return func(next http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			user := UserFromContext(r.Context())
			if user == nil {
				http.Error(w, "unauthorized", http.StatusUnauthorized)
				return
			}

			// Extract user roles from context or user object
			userRoles := m.getUserRoles(user)
			
			// Check if user has any of the required roles
			if !m.hasAnyRole(userRoles, roles) {
				http.Error(w, "forbidden: insufficient permissions", http.StatusForbidden)
				return
			}

			next.ServeHTTP(w, r)
		})
	}
}

// RequirePermission enforces transition-level permission with optional guard evaluation.
func (m *Middleware) RequirePermission(transitionID string) func(http.Handler) http.Handler {
	return func(next http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			user := UserFromContext(r.Context())
			if user == nil {
				http.Error(w, "unauthorized", http.StatusUnauthorized)
				return
			}

			// Get access control rules for this transition
			rule, exists := m.rules[transitionID]
			if !exists {
				// No specific rule, allow any authenticated user
				next.ServeHTTP(w, r)
				return
			}

			// Check role requirements
			if len(rule.Roles) > 0 {
				userRoles := m.getUserRoles(user)
				if !m.hasAnyRole(userRoles, rule.Roles) {
					http.Error(w, fmt.Sprintf("forbidden: action '%s' requires role: %s", transitionID, strings.Join(rule.Roles, " or ")), http.StatusForbidden)
					return
				}
			}

			// Evaluate guard expression if present
			if rule.Guard != "" {
				// Build bindings for guard evaluation
				bindings := m.buildGuardBindings(user, r)
				
				allowed, err := dsl.Evaluate(rule.Guard, bindings, nil)
				if err != nil {
					http.Error(w, fmt.Sprintf("error evaluating access guard: %v", err), http.StatusInternalServerError)
					return
				}
				
				if !allowed {
					http.Error(w, fmt.Sprintf("forbidden: access guard failed for '%s'", transitionID), http.StatusForbidden)
					return
				}
			}

			next.ServeHTTP(w, r)
		})
	}
}

// getUserRoles extracts roles from a user with role hierarchy support.
func (m *Middleware) getUserRoles(user *User) []string {
	// First check if roles are embedded in user object
	if len(user.Roles) > 0 {
		return expandRolesWithInheritance(user.Roles, m.roleHierarchy)
	}
	
	// Fallback to default role
	return []string{"user"}
}

// hasAnyRole checks if user has at least one of the required roles.
func (m *Middleware) hasAnyRole(userRoles []string, requiredRoles []string) bool {
	if len(requiredRoles) == 0 {
		return true // No role requirement
	}
	
	for _, required := range requiredRoles {
		for _, userRole := range userRoles {
			if userRole == required {
				return true
			}
		}
	}
	return false
}

// buildGuardBindings creates bindings for guard expression evaluation.
func (m *Middleware) buildGuardBindings(user *User, r *http.Request) map[string]any {
	bindings := make(map[string]any)
	
	// Add user info to bindings
	bindings["user"] = map[string]any{
		"id":    user.ID,
		"login": user.Login,
		"email": user.Email,
		"roles": m.getUserRoles(user),
	}
	
	// Add request parameters
	bindings["request"] = extractRequestParams(r)
	
	// Add aggregate state (if available in context)
	if state := getAggregateState(r.Context()); state != nil {
		bindings["state"] = state
	}
	
	// Add metadata
	bindings["timestamp"] = time.Now().Unix()
	bindings["path"] = r.URL.Path
	
	return bindings
}

// EvaluateGuard evaluates a guard expression with the given bindings.
// This is a helper function for custom guard evaluation.
func EvaluateGuard(guard string, bindings map[string]any) (bool, error) {
	if guard == "" {
		return true, nil
	}
	return dsl.Evaluate(guard, bindings, nil)
}

// expandRolesWithInheritance expands a list of roles to include inherited roles.
func expandRolesWithInheritance(roles []string, hierarchy map[string][]string) []string {
	seen := make(map[string]bool)
	expanded := make([]string, 0)
	
	var expand func(role string)
	expand = func(role string) {
		if seen[role] {
			return
		}
		seen[role] = true
		expanded = append(expanded, role)
		
		// Add parent roles
		if parents, ok := hierarchy[role]; ok {
			for _, parent := range parents {
				expand(parent)
			}
		}
	}
	
	for _, role := range roles {
		expand(role)
	}
	
	return expanded
}

// extractRequestParams extracts parameters from the HTTP request.
func extractRequestParams(r *http.Request) map[string]any {
	params := make(map[string]any)
	
	// Query parameters
	query := make(map[string]any)
	for key, values := range r.URL.Query() {
		if len(values) == 1 {
			query[key] = values[0]
		} else {
			query[key] = values
		}
	}
	if len(query) > 0 {
		params["query"] = query
	}
	
	// Path parameters (if stored in context by router)
	if pathParams := r.Context().Value("pathParams"); pathParams != nil {
		if p, ok := pathParams.(map[string]string); ok {
			params["path"] = p
		}
	}
	
	// HTTP method and headers
	params["method"] = r.Method
	params["headers"] = r.Header
	
	return params
}

// getAggregateState retrieves the current aggregate state from context.
func getAggregateState(ctx context.Context) map[string]any {
	if state := ctx.Value("aggregateState"); state != nil {
		if s, ok := state.(map[string]any); ok {
			return s
		}
	}
	return nil
}
