// Code generated by petri-pilot. DO NOT EDIT.

package blogpost

import (
	"context"
	"encoding/base64"
	"io/fs"
	"net/http"
	"os"
	"path/filepath"
	"strconv"
	"strings"

	"github.com/pflow-xyz/petri-pilot/pkg/runtime/api"
	"github.com/pflow-xyz/petri-pilot/pkg/runtime/eventstore"
)

// BuildRouter creates an HTTP router for the blog-post workflow.
func BuildRouter(app *Application, middleware *Middleware, sessions SessionStore, navigation *Navigation, debugBroker *DebugBroker) http.Handler {
	r := api.NewRouter()

	// Apply auth middleware to extract user from token (optional, doesn't require auth)
	r.Use(OptionalAuthMiddleware(sessions))

	// Health check - always returns ok if server is running
	r.GET("/health", "Health check", func(w http.ResponseWriter, r *http.Request) {
		api.JSON(w, http.StatusOK, map[string]string{"status": "ok"})
	})

	// Readiness check - verifies dependencies (database, etc.)
	r.GET("/ready", "Readiness check", HandleReady(app))

	// Create new aggregate
	r.POST("/api/blogpost", "Create new blog-post", HandleCreate(app))

	// Get aggregate state
	r.GET("/api/blogpost/{id}", "Get blog-post state", HandleGetState(app))

	// View definitions
	r.GET("/api/views", "Get view definitions", HandleGetViews())


	// Navigation endpoint
	r.GET("/api/navigation", "Get navigation menu", HandleNavigation(navigation))

	// Schema viewer endpoint
	r.GET("/api/schema", "Get model schema", HandleGetSchema())


	// Admin endpoints
	r.GET("/admin/stats", "Admin statistics", HandleAdminStats(app))
	r.GET("/admin/instances", "List instances", HandleAdminListInstances(app))
	r.GET("/admin/instances/{id}", "Get instance detail", HandleAdminGetInstance(app))
	r.GET("/admin/instances/{id}/events", "Get instance events", HandleAdminGetEvents(app))


	// Event replay endpoints
	r.GET("/api/blogpost/{id}/events", "Get event history", HandleGetEvents(app))
	r.GET("/api/blogpost/{id}/at/{version}", "Get state at version", HandleGetStateAtVersion(app))






	// Debug WebSocket and eval endpoints
	r.GET("/ws", "Debug WebSocket connection", HandleDebugWebSocket(debugBroker))
	r.GET("/api/debug/sessions", "List debug sessions", HandleListSessions(debugBroker))
	r.POST("/api/debug/sessions/{id}/eval", "Evaluate code in browser session", HandleSessionEval(debugBroker))
	// Test login endpoint (only available in debug mode)
	r.POST("/api/debug/login", "Create test session with roles", HandleTestLogin(sessions))

















	// Transition endpoints
	r.Transition("create_post", "/api/create_post", "Create a new blog post", middleware.RequirePermission("create_post")(HandleCreatePost(app)))
	r.Transition("update", "/api/update", "Update post content", middleware.RequirePermission("update")(HandleUpdate(app)))
	r.Transition("submit", "/api/submit", "Submit draft for review", middleware.RequirePermission("submit")(HandleSubmit(app)))
	r.Transition("approve", "/api/approve", "Approve and publish the post", middleware.RequirePermission("approve")(HandleApprove(app)))
	r.Transition("reject", "/api/reject", "Reject and return to draft", middleware.RequirePermission("reject")(HandleReject(app)))
	r.Transition("unpublish", "/api/unpublish", "Take down a published post", middleware.RequirePermission("unpublish")(HandleUnpublish(app)))
	r.Transition("restore", "/api/restore", "Restore archived post to draft", middleware.RequirePermission("restore")(HandleRestore(app)))

	// Serve frontend static files
	r.StaticFiles("/", StaticFileHandler())

	return r.Build()
}

// StaticFileHandler returns an http.Handler that serves static files from frontend/.
// It supports SPA routing by returning index.html for paths that don't match static files.
func StaticFileHandler() http.HandlerFunc {
	// Find frontend directory
	frontendPath := "frontend"
	if _, err := os.Stat(frontendPath); os.IsNotExist(err) {
		// Try relative to executable
		exe, _ := os.Executable()
		frontendPath = filepath.Join(filepath.Dir(exe), "frontend")
	}

	return func(w http.ResponseWriter, r *http.Request) {
		// Clean the path
		path := strings.TrimPrefix(r.URL.Path, "/")
		if path == "" {
			path = "index.html"
		}

		// Try to serve the file
		fullPath := filepath.Join(frontendPath, path)

		// Check if file exists
		info, err := os.Stat(fullPath)
		if err != nil || info.IsDir() {
			// File doesn't exist, serve index.html for SPA routing
			http.ServeFile(w, r, filepath.Join(frontendPath, "index.html"))
			return
		}

		http.ServeFile(w, r, fullPath)
	}
}

// StaticFS is a helper interface for embedding static files (optional).
type StaticFS interface {
	fs.FS
}

// HandleCreate creates a new aggregate instance.
func HandleCreate(app *Application) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()

		id, err := app.Create(ctx)
		if err != nil {
			api.Error(w, http.StatusInternalServerError, "CREATE_FAILED", err.Error())
			return
		}

		// Load the new aggregate to get initial state
		agg, err := app.Load(ctx, id)
		if err != nil {
			api.Error(w, http.StatusInternalServerError, "LOAD_FAILED", err.Error())
			return
		}

		api.JSON(w, http.StatusCreated, api.StateResponse{
			AggregateID:        agg.ID(),
			Version:            agg.Version(),
			State:              agg.State(),
			Places:             agg.Places(),
			EnabledTransitions: agg.EnabledTransitions(),
		})
	}
}

// HandleGetState returns the current state of an aggregate.
func HandleGetState(app *Application) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()
		id := r.PathValue("id")
		if id == "" {
			api.Error(w, http.StatusBadRequest, "MISSING_ID", "aggregate ID is required")
			return
		}

		agg, err := app.GetState(ctx, id)
		if err != nil {
			api.Error(w, http.StatusNotFound, "NOT_FOUND", err.Error())
			return
		}

		api.JSON(w, http.StatusOK, api.StateResponse{
			AggregateID:        agg.ID(),
			Version:            agg.Version(),
			State:              agg.State(),
			Places:             agg.Places(),
			EnabledTransitions: agg.EnabledTransitions(),
		})
	}
}

// HandleReady checks if the application is ready to serve requests.
// Returns 200 if all dependencies are available, 503 otherwise.
func HandleReady(app *Application) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		checks := make(map[string]string)
		ready := true

		// Check event store connectivity
		if err := app.HealthCheck(r.Context()); err != nil {
			checks["eventstore"] = err.Error()
			ready = false
		} else {
			checks["eventstore"] = "ok"
		}

		status := http.StatusOK
		statusText := "ready"
		if !ready {
			status = http.StatusServiceUnavailable
			statusText = "not ready"
		}

		api.JSON(w, status, map[string]any{
			"status": statusText,
			"checks": checks,
		})
	}
}


// HandleCreatePost handles the create_post transition.
func HandleCreatePost(app *Application) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()

		var req api.TransitionRequest
		if err := api.DecodeJSON(r, &req); err != nil {
			api.Error(w, http.StatusBadRequest, "INVALID_REQUEST", err.Error())
			return
		}

		if req.AggregateID == "" {
			api.Error(w, http.StatusBadRequest, "MISSING_ID", "aggregate_id is required")
			return
		}

		agg, err := app.Execute(ctx, req.AggregateID, TransitionCreatePost, req.Data)
		if err != nil {
			api.Error(w, http.StatusConflict, "TRANSITION_FAILED", err.Error())
			return
		}

		api.JSON(w, http.StatusOK, api.TransitionResult{
			Success:            true,
			AggregateID:        agg.ID(),
			Version:            agg.Version(),
			State:              agg.Places(),
			EnabledTransitions: agg.EnabledTransitions(),
		})
	}
}


// HandleUpdate handles the update transition.
func HandleUpdate(app *Application) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()

		var req api.TransitionRequest
		if err := api.DecodeJSON(r, &req); err != nil {
			api.Error(w, http.StatusBadRequest, "INVALID_REQUEST", err.Error())
			return
		}

		if req.AggregateID == "" {
			api.Error(w, http.StatusBadRequest, "MISSING_ID", "aggregate_id is required")
			return
		}

		agg, err := app.Execute(ctx, req.AggregateID, TransitionUpdate, req.Data)
		if err != nil {
			api.Error(w, http.StatusConflict, "TRANSITION_FAILED", err.Error())
			return
		}

		api.JSON(w, http.StatusOK, api.TransitionResult{
			Success:            true,
			AggregateID:        agg.ID(),
			Version:            agg.Version(),
			State:              agg.Places(),
			EnabledTransitions: agg.EnabledTransitions(),
		})
	}
}


// HandleSubmit handles the submit transition.
func HandleSubmit(app *Application) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()

		var req api.TransitionRequest
		if err := api.DecodeJSON(r, &req); err != nil {
			api.Error(w, http.StatusBadRequest, "INVALID_REQUEST", err.Error())
			return
		}

		if req.AggregateID == "" {
			api.Error(w, http.StatusBadRequest, "MISSING_ID", "aggregate_id is required")
			return
		}

		agg, err := app.Execute(ctx, req.AggregateID, TransitionSubmit, req.Data)
		if err != nil {
			api.Error(w, http.StatusConflict, "TRANSITION_FAILED", err.Error())
			return
		}

		api.JSON(w, http.StatusOK, api.TransitionResult{
			Success:            true,
			AggregateID:        agg.ID(),
			Version:            agg.Version(),
			State:              agg.Places(),
			EnabledTransitions: agg.EnabledTransitions(),
		})
	}
}


// HandleApprove handles the approve transition.
func HandleApprove(app *Application) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()

		var req api.TransitionRequest
		if err := api.DecodeJSON(r, &req); err != nil {
			api.Error(w, http.StatusBadRequest, "INVALID_REQUEST", err.Error())
			return
		}

		if req.AggregateID == "" {
			api.Error(w, http.StatusBadRequest, "MISSING_ID", "aggregate_id is required")
			return
		}

		agg, err := app.Execute(ctx, req.AggregateID, TransitionApprove, req.Data)
		if err != nil {
			api.Error(w, http.StatusConflict, "TRANSITION_FAILED", err.Error())
			return
		}

		api.JSON(w, http.StatusOK, api.TransitionResult{
			Success:            true,
			AggregateID:        agg.ID(),
			Version:            agg.Version(),
			State:              agg.Places(),
			EnabledTransitions: agg.EnabledTransitions(),
		})
	}
}


// HandleReject handles the reject transition.
func HandleReject(app *Application) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()

		var req api.TransitionRequest
		if err := api.DecodeJSON(r, &req); err != nil {
			api.Error(w, http.StatusBadRequest, "INVALID_REQUEST", err.Error())
			return
		}

		if req.AggregateID == "" {
			api.Error(w, http.StatusBadRequest, "MISSING_ID", "aggregate_id is required")
			return
		}

		agg, err := app.Execute(ctx, req.AggregateID, TransitionReject, req.Data)
		if err != nil {
			api.Error(w, http.StatusConflict, "TRANSITION_FAILED", err.Error())
			return
		}

		api.JSON(w, http.StatusOK, api.TransitionResult{
			Success:            true,
			AggregateID:        agg.ID(),
			Version:            agg.Version(),
			State:              agg.Places(),
			EnabledTransitions: agg.EnabledTransitions(),
		})
	}
}


// HandleUnpublish handles the unpublish transition.
func HandleUnpublish(app *Application) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()

		var req api.TransitionRequest
		if err := api.DecodeJSON(r, &req); err != nil {
			api.Error(w, http.StatusBadRequest, "INVALID_REQUEST", err.Error())
			return
		}

		if req.AggregateID == "" {
			api.Error(w, http.StatusBadRequest, "MISSING_ID", "aggregate_id is required")
			return
		}

		agg, err := app.Execute(ctx, req.AggregateID, TransitionUnpublish, req.Data)
		if err != nil {
			api.Error(w, http.StatusConflict, "TRANSITION_FAILED", err.Error())
			return
		}

		api.JSON(w, http.StatusOK, api.TransitionResult{
			Success:            true,
			AggregateID:        agg.ID(),
			Version:            agg.Version(),
			State:              agg.Places(),
			EnabledTransitions: agg.EnabledTransitions(),
		})
	}
}


// HandleRestore handles the restore transition.
func HandleRestore(app *Application) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()

		var req api.TransitionRequest
		if err := api.DecodeJSON(r, &req); err != nil {
			api.Error(w, http.StatusBadRequest, "INVALID_REQUEST", err.Error())
			return
		}

		if req.AggregateID == "" {
			api.Error(w, http.StatusBadRequest, "MISSING_ID", "aggregate_id is required")
			return
		}

		agg, err := app.Execute(ctx, req.AggregateID, TransitionRestore, req.Data)
		if err != nil {
			api.Error(w, http.StatusConflict, "TRANSITION_FAILED", err.Error())
			return
		}

		api.JSON(w, http.StatusOK, api.TransitionResult{
			Success:            true,
			AggregateID:        agg.ID(),
			Version:            agg.Version(),
			State:              agg.Places(),
			EnabledTransitions: agg.EnabledTransitions(),
		})
	}
}


// HandleGetViews returns the view definitions for the workflow.
func HandleGetViews() http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		data, err := ViewsJSON()
		if err != nil {
			api.Error(w, http.StatusInternalServerError, "VIEWS_ERROR", err.Error())
			return
		}
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusOK)
		w.Write(data)
	}
}


// HandleNavigation returns the navigation menu, filtered by user roles.
func HandleNavigation(nav *Navigation) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		userRoles := getNavUserRoles(r)

		items := []NavigationItem{}
		for _, item := range nav.Items {
			if len(item.Roles) == 0 {
				items = append(items, item)
				continue
			}

			if navHasAnyRole(userRoles, item.Roles) {
				items = append(items, item)
			}
		}

		api.JSON(w, http.StatusOK, map[string]interface{}{
			"brand": nav.Brand,
			"items": items,
		})
	}
}

// getNavUserRoles extracts user roles from the request context.
func getNavUserRoles(r *http.Request) []string {
	user, ok := r.Context().Value("user").(*User)
	if !ok || user == nil {
		return nil
	}
	return user.Roles
}

// navHasAnyRole checks if user has at least one of the required roles.
func navHasAnyRole(userRoles []string, requiredRoles []string) bool {
	for _, required := range requiredRoles {
		for _, userRole := range userRoles {
			if userRole == required {
				return true
			}
		}
	}
	return false
}



// HandleAdminStats wraps the admin stats handler.
func HandleAdminStats(app *Application) http.HandlerFunc {
return func(w http.ResponseWriter, r *http.Request) {
ctx := r.Context()

adminStore, ok := app.store.(interface {
GetStats(ctx context.Context) (*eventstore.Stats, error)
})
if !ok {
api.Error(w, http.StatusInternalServerError, "UNSUPPORTED", "Admin operations not supported")
return
}

stats, err := adminStore.GetStats(ctx)
if err != nil {
api.Error(w, http.StatusInternalServerError, "STATS_FAILED", err.Error())
return
}

api.JSON(w, http.StatusOK, stats)
}
}

// HandleAdminListInstances wraps the admin list instances handler.
func HandleAdminListInstances(app *Application) http.HandlerFunc {
return func(w http.ResponseWriter, r *http.Request) {
ctx := r.Context()

place := r.URL.Query().Get("place")
from := r.URL.Query().Get("from")
to := r.URL.Query().Get("to")
page := getIntQueryParam(r, "page", 1)
perPage := getIntQueryParam(r, "per_page", 50)

adminStore, ok := app.store.(interface {
ListInstances(ctx context.Context, place, from, to string, page, perPage int) ([]eventstore.Instance, int, error)
})
if !ok {
api.Error(w, http.StatusInternalServerError, "UNSUPPORTED", "Admin operations not supported")
return
}

instances, total, err := adminStore.ListInstances(ctx, place, from, to, page, perPage)
if err != nil {
api.Error(w, http.StatusInternalServerError, "LIST_FAILED", err.Error())
return
}

// Load state for each instance by replaying events
// Note: This loads aggregates individually which may be slow for large lists.
// The perPage parameter limits the number of instances processed.
for i := range instances {
agg, err := app.Load(ctx, instances[i].ID)
if err != nil {
// Log error but continue processing other instances
// The state will remain as initialized by ListInstances
continue
}
// Get the Petri net places (token distribution)
instances[i].State = agg.Places()
}

api.JSON(w, http.StatusOK, map[string]interface{}{
"instances": instances,
"total":     total,
"page":      page,
"per_page":  perPage,
})
}
}

// HandleAdminGetInstance wraps the admin get instance handler.
func HandleAdminGetInstance(app *Application) http.HandlerFunc {
return func(w http.ResponseWriter, r *http.Request) {
ctx := r.Context()
id := r.PathValue("id")

agg, err := app.Load(ctx, id)
if err != nil {
api.Error(w, http.StatusNotFound, "NOT_FOUND", err.Error())
return
}

api.JSON(w, http.StatusOK, map[string]interface{}{
"id":      agg.ID(),
"version": agg.Version(),
"state":   agg.State(),
})
}
}

// HandleAdminGetEvents wraps the admin get events handler.
func HandleAdminGetEvents(app *Application) http.HandlerFunc {
return func(w http.ResponseWriter, r *http.Request) {
ctx := r.Context()
id := r.PathValue("id")
from := getIntQueryParam(r, "from", 0)

events, err := app.store.Read(ctx, id, from)
if err != nil {
api.Error(w, http.StatusInternalServerError, "READ_FAILED", err.Error())
return
}

api.JSON(w, http.StatusOK, map[string]interface{}{
"events": events,
})
}
}



// HandleGetEvents returns the event history for an aggregate.
func HandleGetEvents(app *Application) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()
		id := r.PathValue("id")
		from := getIntQueryParam(r, "from", 0)

		events, err := app.store.Read(ctx, id, from)
		if err != nil {
			api.Error(w, http.StatusInternalServerError, "READ_FAILED", err.Error())
			return
		}

		api.JSON(w, http.StatusOK, map[string]interface{}{
			"events": events,
		})
	}
}

// HandleGetStateAtVersion returns the aggregate state at a specific version.
func HandleGetStateAtVersion(app *Application) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()
		id := r.PathValue("id")
		versionStr := r.PathValue("version")

		version := getInt(versionStr, 0)
		if version <= 0 {
			api.Error(w, http.StatusBadRequest, "INVALID_VERSION", "version must be a positive integer")
			return
		}

		events, err := app.store.Read(ctx, id, 0)
		if err != nil {
			api.Error(w, http.StatusInternalServerError, "READ_FAILED", err.Error())
			return
		}

		// Create temporary aggregate and replay up to version
		agg := NewAggregate(id)
		for _, evt := range events {
			if evt.Version > version {
				break
			}
			if err := agg.Apply(evt); err != nil {
				api.Error(w, http.StatusInternalServerError, "APPLY_FAILED", err.Error())
				return
			}
		}

		api.JSON(w, http.StatusOK, map[string]interface{}{
			"id":      agg.ID(),
			"version": version,
			"state":   agg.State(),
		})
	}
}





// Helper functions

func getIntQueryParam(r *http.Request, name string, defaultVal int) int {
	val := r.URL.Query().Get(name)
	return getInt(val, defaultVal)
}

func getInt(s string, defaultVal int) int {
	if s == "" {
		return defaultVal
	}

	intVal, err := strconv.Atoi(s)
	if err != nil {
		return defaultVal
	}

	return intVal
}


// HandleGetSchema returns the model schema JSON for the schema viewer.
func HandleGetSchema() http.HandlerFunc {
	// Schema JSON is embedded at generation time (base64 encoded)
	schemaBase64 := "ewogICJuYW1lIjogImJsb2ctcG9zdCIsCiAgImRlc2NyaXB0aW9uIjogIkEgYmxvZyBwb3N0IHdvcmtmbG93IHdpdGggcGVyc2lzdGVuY2UgYW5kIHNlYXJjaCIsCiAgInBsYWNlcyI6IFsKICAgIHsKICAgICAgImlkIjogImRyYWZ0IiwKICAgICAgImRlc2NyaXB0aW9uIjogIlBvc3QgaXMgYmVpbmcgd3JpdHRlbiIsCiAgICAgICJpbml0aWFsIjogMSwKICAgICAgImtpbmQiOiAidG9rZW4iCiAgICB9LAogICAgewogICAgICAiaWQiOiAiaW5fcmV2aWV3IiwKICAgICAgImRlc2NyaXB0aW9uIjogIlBvc3QgaXMgYXdhaXRpbmcgZWRpdG9yaWFsIHJldmlldyIsCiAgICAgICJpbml0aWFsIjogMCwKICAgICAgImtpbmQiOiAidG9rZW4iCiAgICB9LAogICAgewogICAgICAiaWQiOiAicHVibGlzaGVkIiwKICAgICAgImRlc2NyaXB0aW9uIjogIlBvc3QgaXMgbGl2ZSBvbiB0aGUgc2l0ZSIsCiAgICAgICJpbml0aWFsIjogMCwKICAgICAgImtpbmQiOiAidG9rZW4iCiAgICB9LAogICAgewogICAgICAiaWQiOiAiYXJjaGl2ZWQiLAogICAgICAiZGVzY3JpcHRpb24iOiAiUG9zdCBoYXMgYmVlbiB0YWtlbiBkb3duIiwKICAgICAgImluaXRpYWwiOiAwLAogICAgICAia2luZCI6ICJ0b2tlbiIKICAgIH0KICBdLAogICJ0cmFuc2l0aW9ucyI6IFsKICAgIHsKICAgICAgImlkIjogImNyZWF0ZV9wb3N0IiwKICAgICAgImRlc2NyaXB0aW9uIjogIkNyZWF0ZSBhIG5ldyBibG9nIHBvc3QiLAogICAgICAiZXZlbnQiOiAicG9zdF9jcmVhdGVkIiwKICAgICAgImZpZWxkcyI6IFsKICAgICAgICB7CiAgICAgICAgICAibmFtZSI6ICJ0aXRsZSIsCiAgICAgICAgICAibGFiZWwiOiAiVGl0bGUiLAogICAgICAgICAgInR5cGUiOiAidGV4dCIsCiAgICAgICAgICAicmVxdWlyZWQiOiB0cnVlLAogICAgICAgICAgInBsYWNlaG9sZGVyIjogIlBvc3QgdGl0bGUiCiAgICAgICAgfSwKICAgICAgICB7CiAgICAgICAgICAibmFtZSI6ICJjb250ZW50IiwKICAgICAgICAgICJsYWJlbCI6ICJDb250ZW50IiwKICAgICAgICAgICJ0eXBlIjogInRleHRhcmVhIiwKICAgICAgICAgICJyZXF1aXJlZCI6IHRydWUsCiAgICAgICAgICAicGxhY2Vob2xkZXIiOiAiV3JpdGUgeW91ciBwb3N0Li4uIgogICAgICAgIH0sCiAgICAgICAgewogICAgICAgICAgIm5hbWUiOiAidGFncyIsCiAgICAgICAgICAibGFiZWwiOiAiVGFncyIsCiAgICAgICAgICAidHlwZSI6ICJ0ZXh0IiwKICAgICAgICAgICJwbGFjZWhvbGRlciI6ICJDb21tYS1zZXBhcmF0ZWQgdGFncyIKICAgICAgICB9CiAgICAgIF0sCiAgICAgICJodHRwX21ldGhvZCI6ICJQT1NUIiwKICAgICAgImh0dHBfcGF0aCI6ICIvYXBpL2NyZWF0ZV9wb3N0IiwKICAgICAgImV2ZW50X3R5cGUiOiAiQ3JlYXRlUG9zdGVkIgogICAgfSwKICAgIHsKICAgICAgImlkIjogInVwZGF0ZSIsCiAgICAgICJkZXNjcmlwdGlvbiI6ICJVcGRhdGUgcG9zdCBjb250ZW50IiwKICAgICAgImV2ZW50IjogInBvc3RfdXBkYXRlZCIsCiAgICAgICJmaWVsZHMiOiBbCiAgICAgICAgewogICAgICAgICAgIm5hbWUiOiAidGl0bGUiLAogICAgICAgICAgImxhYmVsIjogIlRpdGxlIiwKICAgICAgICAgICJ0eXBlIjogInRleHQiLAogICAgICAgICAgInBsYWNlaG9sZGVyIjogIlBvc3QgdGl0bGUiCiAgICAgICAgfSwKICAgICAgICB7CiAgICAgICAgICAibmFtZSI6ICJjb250ZW50IiwKICAgICAgICAgICJsYWJlbCI6ICJDb250ZW50IiwKICAgICAgICAgICJ0eXBlIjogInRleHRhcmVhIiwKICAgICAgICAgICJwbGFjZWhvbGRlciI6ICJXcml0ZSB5b3VyIHBvc3QuLi4iCiAgICAgICAgfSwKICAgICAgICB7CiAgICAgICAgICAibmFtZSI6ICJ0YWdzIiwKICAgICAgICAgICJsYWJlbCI6ICJUYWdzIiwKICAgICAgICAgICJ0eXBlIjogInRleHQiLAogICAgICAgICAgInBsYWNlaG9sZGVyIjogIkNvbW1hLXNlcGFyYXRlZCB0YWdzIgogICAgICAgIH0KICAgICAgXSwKICAgICAgImh0dHBfbWV0aG9kIjogIlBPU1QiLAogICAgICAiaHR0cF9wYXRoIjogIi9hcGkvdXBkYXRlIiwKICAgICAgImV2ZW50X3R5cGUiOiAiVXBkYXRlZWQiCiAgICB9LAogICAgewogICAgICAiaWQiOiAic3VibWl0IiwKICAgICAgImRlc2NyaXB0aW9uIjogIlN1Ym1pdCBkcmFmdCBmb3IgcmV2aWV3IiwKICAgICAgImV2ZW50IjogInBvc3Rfc3VibWl0dGVkIiwKICAgICAgImh0dHBfbWV0aG9kIjogIlBPU1QiLAogICAgICAiaHR0cF9wYXRoIjogIi9hcGkvc3VibWl0IiwKICAgICAgImV2ZW50X3R5cGUiOiAiU3VibWl0ZWQiCiAgICB9LAogICAgewogICAgICAiaWQiOiAiYXBwcm92ZSIsCiAgICAgICJkZXNjcmlwdGlvbiI6ICJBcHByb3ZlIGFuZCBwdWJsaXNoIHRoZSBwb3N0IiwKICAgICAgImV2ZW50IjogInBvc3RfYXBwcm92ZWQiLAogICAgICAiaHR0cF9tZXRob2QiOiAiUE9TVCIsCiAgICAgICJodHRwX3BhdGgiOiAiL2FwaS9hcHByb3ZlIiwKICAgICAgImV2ZW50X3R5cGUiOiAiQXBwcm92ZWVkIgogICAgfSwKICAgIHsKICAgICAgImlkIjogInJlamVjdCIsCiAgICAgICJkZXNjcmlwdGlvbiI6ICJSZWplY3QgYW5kIHJldHVybiB0byBkcmFmdCIsCiAgICAgICJldmVudCI6ICJwb3N0X3JlamVjdGVkIiwKICAgICAgImZpZWxkcyI6IFsKICAgICAgICB7CiAgICAgICAgICAibmFtZSI6ICJyZWFzb24iLAogICAgICAgICAgImxhYmVsIjogIlJlYXNvbiIsCiAgICAgICAgICAidHlwZSI6ICJ0ZXh0YXJlYSIsCiAgICAgICAgICAicGxhY2Vob2xkZXIiOiAiV2h5IGlzIHRoaXMgYmVpbmcgcmVqZWN0ZWQ/IgogICAgICAgIH0KICAgICAgXSwKICAgICAgImh0dHBfbWV0aG9kIjogIlBPU1QiLAogICAgICAiaHR0cF9wYXRoIjogIi9hcGkvcmVqZWN0IiwKICAgICAgImV2ZW50X3R5cGUiOiAiUmVqZWN0ZWQiCiAgICB9LAogICAgewogICAgICAiaWQiOiAidW5wdWJsaXNoIiwKICAgICAgImRlc2NyaXB0aW9uIjogIlRha2UgZG93biBhIHB1Ymxpc2hlZCBwb3N0IiwKICAgICAgImV2ZW50IjogInBvc3RfdW5wdWJsaXNoZWQiLAogICAgICAiaHR0cF9tZXRob2QiOiAiUE9TVCIsCiAgICAgICJodHRwX3BhdGgiOiAiL2FwaS91bnB1Ymxpc2giLAogICAgICAiZXZlbnRfdHlwZSI6ICJVbnB1Ymxpc2hlZCIKICAgIH0sCiAgICB7CiAgICAgICJpZCI6ICJyZXN0b3JlIiwKICAgICAgImRlc2NyaXB0aW9uIjogIlJlc3RvcmUgYXJjaGl2ZWQgcG9zdCB0byBkcmFmdCIsCiAgICAgICJldmVudCI6ICJwb3N0X3Jlc3RvcmVkIiwKICAgICAgImh0dHBfbWV0aG9kIjogIlBPU1QiLAogICAgICAiaHR0cF9wYXRoIjogIi9hcGkvcmVzdG9yZSIsCiAgICAgICJldmVudF90eXBlIjogIlJlc3RvcmVlZCIKICAgIH0KICBdLAogICJhcmNzIjogWwogICAgewogICAgICAiZnJvbSI6ICJjcmVhdGVfcG9zdCIsCiAgICAgICJ0byI6ICJkcmFmdCIKICAgIH0sCiAgICB7CiAgICAgICJmcm9tIjogImRyYWZ0IiwKICAgICAgInRvIjogInVwZGF0ZSIKICAgIH0sCiAgICB7CiAgICAgICJmcm9tIjogInVwZGF0ZSIsCiAgICAgICJ0byI6ICJkcmFmdCIKICAgIH0sCiAgICB7CiAgICAgICJmcm9tIjogImRyYWZ0IiwKICAgICAgInRvIjogInN1Ym1pdCIKICAgIH0sCiAgICB7CiAgICAgICJmcm9tIjogInN1Ym1pdCIsCiAgICAgICJ0byI6ICJpbl9yZXZpZXciCiAgICB9LAogICAgewogICAgICAiZnJvbSI6ICJpbl9yZXZpZXciLAogICAgICAidG8iOiAiYXBwcm92ZSIKICAgIH0sCiAgICB7CiAgICAgICJmcm9tIjogImFwcHJvdmUiLAogICAgICAidG8iOiAicHVibGlzaGVkIgogICAgfSwKICAgIHsKICAgICAgImZyb20iOiAiaW5fcmV2aWV3IiwKICAgICAgInRvIjogInJlamVjdCIKICAgIH0sCiAgICB7CiAgICAgICJmcm9tIjogInJlamVjdCIsCiAgICAgICJ0byI6ICJkcmFmdCIKICAgIH0sCiAgICB7CiAgICAgICJmcm9tIjogInB1Ymxpc2hlZCIsCiAgICAgICJ0byI6ICJ1bnB1Ymxpc2giCiAgICB9LAogICAgewogICAgICAiZnJvbSI6ICJ1bnB1Ymxpc2giLAogICAgICAidG8iOiAiYXJjaGl2ZWQiCiAgICB9LAogICAgewogICAgICAiZnJvbSI6ICJhcmNoaXZlZCIsCiAgICAgICJ0byI6ICJyZXN0b3JlIgogICAgfSwKICAgIHsKICAgICAgImZyb20iOiAicmVzdG9yZSIsCiAgICAgICJ0byI6ICJkcmFmdCIKICAgIH0KICBdLAogICJldmVudHMiOiBbCiAgICB7CiAgICAgICJpZCI6ICJwb3N0X2NyZWF0ZWQiLAogICAgICAibmFtZSI6ICJQb3N0Q3JlYXRlZCIsCiAgICAgICJkZXNjcmlwdGlvbiI6ICJBIG5ldyBibG9nIHBvc3Qgd2FzIGNyZWF0ZWQiLAogICAgICAiZmllbGRzIjogWwogICAgICAgIHsKICAgICAgICAgICJuYW1lIjogInRpdGxlIiwKICAgICAgICAgICJ0eXBlIjogInN0cmluZyIsCiAgICAgICAgICAicmVxdWlyZWQiOiB0cnVlCiAgICAgICAgfSwKICAgICAgICB7CiAgICAgICAgICAibmFtZSI6ICJjb250ZW50IiwKICAgICAgICAgICJ0eXBlIjogInN0cmluZyIsCiAgICAgICAgICAicmVxdWlyZWQiOiB0cnVlCiAgICAgICAgfSwKICAgICAgICB7CiAgICAgICAgICAibmFtZSI6ICJhdXRob3JfaWQiLAogICAgICAgICAgInR5cGUiOiAic3RyaW5nIiwKICAgICAgICAgICJyZXF1aXJlZCI6IHRydWUKICAgICAgICB9LAogICAgICAgIHsKICAgICAgICAgICJuYW1lIjogImF1dGhvcl9uYW1lIiwKICAgICAgICAgICJ0eXBlIjogInN0cmluZyIsCiAgICAgICAgICAicmVxdWlyZWQiOiB0cnVlCiAgICAgICAgfSwKICAgICAgICB7CiAgICAgICAgICAibmFtZSI6ICJ0YWdzIiwKICAgICAgICAgICJ0eXBlIjogIltdc3RyaW5nIgogICAgICAgIH0KICAgICAgXQogICAgfSwKICAgIHsKICAgICAgImlkIjogInBvc3RfdXBkYXRlZCIsCiAgICAgICJuYW1lIjogIlBvc3RVcGRhdGVkIiwKICAgICAgImRlc2NyaXB0aW9uIjogIkJsb2cgcG9zdCBjb250ZW50IHdhcyB1cGRhdGVkIiwKICAgICAgImZpZWxkcyI6IFsKICAgICAgICB7CiAgICAgICAgICAibmFtZSI6ICJ0aXRsZSIsCiAgICAgICAgICAidHlwZSI6ICJzdHJpbmciCiAgICAgICAgfSwKICAgICAgICB7CiAgICAgICAgICAibmFtZSI6ICJjb250ZW50IiwKICAgICAgICAgICJ0eXBlIjogInN0cmluZyIKICAgICAgICB9LAogICAgICAgIHsKICAgICAgICAgICJuYW1lIjogInRhZ3MiLAogICAgICAgICAgInR5cGUiOiAiW11zdHJpbmciCiAgICAgICAgfQogICAgICBdCiAgICB9LAogICAgewogICAgICAiaWQiOiAicG9zdF9zdWJtaXR0ZWQiLAogICAgICAibmFtZSI6ICJQb3N0U3VibWl0dGVkIiwKICAgICAgImRlc2NyaXB0aW9uIjogIlBvc3Qgc3VibWl0dGVkIGZvciByZXZpZXciLAogICAgICAiZmllbGRzIjogbnVsbAogICAgfSwKICAgIHsKICAgICAgImlkIjogInBvc3RfYXBwcm92ZWQiLAogICAgICAibmFtZSI6ICJQb3N0QXBwcm92ZWQiLAogICAgICAiZGVzY3JpcHRpb24iOiAiUG9zdCBhcHByb3ZlZCBhbmQgcHVibGlzaGVkIiwKICAgICAgImZpZWxkcyI6IFsKICAgICAgICB7CiAgICAgICAgICAibmFtZSI6ICJhcHByb3ZlZF9ieSIsCiAgICAgICAgICAidHlwZSI6ICJzdHJpbmciLAogICAgICAgICAgInJlcXVpcmVkIjogdHJ1ZQogICAgICAgIH0KICAgICAgXQogICAgfSwKICAgIHsKICAgICAgImlkIjogInBvc3RfcmVqZWN0ZWQiLAogICAgICAibmFtZSI6ICJQb3N0UmVqZWN0ZWQiLAogICAgICAiZGVzY3JpcHRpb24iOiAiUG9zdCByZWplY3RlZCBiYWNrIHRvIGRyYWZ0IiwKICAgICAgImZpZWxkcyI6IFsKICAgICAgICB7CiAgICAgICAgICAibmFtZSI6ICJyZWplY3RlZF9ieSIsCiAgICAgICAgICAidHlwZSI6ICJzdHJpbmciLAogICAgICAgICAgInJlcXVpcmVkIjogdHJ1ZQogICAgICAgIH0sCiAgICAgICAgewogICAgICAgICAgIm5hbWUiOiAicmVhc29uIiwKICAgICAgICAgICJ0eXBlIjogInN0cmluZyIKICAgICAgICB9CiAgICAgIF0KICAgIH0sCiAgICB7CiAgICAgICJpZCI6ICJwb3N0X3VucHVibGlzaGVkIiwKICAgICAgIm5hbWUiOiAiUG9zdFVucHVibGlzaGVkIiwKICAgICAgImRlc2NyaXB0aW9uIjogIlB1Ymxpc2hlZCBwb3N0IHRha2VuIGRvd24iLAogICAgICAiZmllbGRzIjogbnVsbAogICAgfSwKICAgIHsKICAgICAgImlkIjogInBvc3RfcmVzdG9yZWQiLAogICAgICAibmFtZSI6ICJQb3N0UmVzdG9yZWQiLAogICAgICAiZGVzY3JpcHRpb24iOiAiQXJjaGl2ZWQgcG9zdCByZXN0b3JlZCB0byBkcmFmdCIsCiAgICAgICJmaWVsZHMiOiBudWxsCiAgICB9CiAgXSwKICAicm9sZXMiOiBbCiAgICB7CiAgICAgICJpZCI6ICJhdXRob3IiLAogICAgICAibmFtZSI6ICJBdXRob3IiLAogICAgICAiZGVzY3JpcHRpb24iOiAiQ29udGVudCBjcmVhdG9yIHdobyB3cml0ZXMgYW5kIHN1Ym1pdHMgcG9zdHMiCiAgICB9LAogICAgewogICAgICAiaWQiOiAiZWRpdG9yIiwKICAgICAgIm5hbWUiOiAiRWRpdG9yIiwKICAgICAgImRlc2NyaXB0aW9uIjogIlJldmlld3MgYW5kIGFwcHJvdmVzL3JlamVjdHMgc3VibWl0dGVkIHBvc3RzIgogICAgfSwKICAgIHsKICAgICAgImlkIjogImFkbWluIiwKICAgICAgIm5hbWUiOiAiQWRtaW5pc3RyYXRvciIsCiAgICAgICJkZXNjcmlwdGlvbiI6ICJGdWxsIGFjY2VzcyB0byBhbGwgb3BlcmF0aW9ucyIsCiAgICAgICJpbmhlcml0cyI6IFsKICAgICAgICAiYXV0aG9yIiwKICAgICAgICAiZWRpdG9yIgogICAgICBdCiAgICB9CiAgXSwKICAiYWNjZXNzIjogWwogICAgewogICAgICAidHJhbnNpdGlvbiI6ICJjcmVhdGVfcG9zdCIsCiAgICAgICJyb2xlcyI6IFsKICAgICAgICAiYXV0aG9yIgogICAgICBdCiAgICB9LAogICAgewogICAgICAidHJhbnNpdGlvbiI6ICJ1cGRhdGUiLAogICAgICAicm9sZXMiOiBbCiAgICAgICAgImF1dGhvciIKICAgICAgXQogICAgfSwKICAgIHsKICAgICAgInRyYW5zaXRpb24iOiAic3VibWl0IiwKICAgICAgInJvbGVzIjogWwogICAgICAgICJhdXRob3IiCiAgICAgIF0KICAgIH0sCiAgICB7CiAgICAgICJ0cmFuc2l0aW9uIjogImFwcHJvdmUiLAogICAgICAicm9sZXMiOiBbCiAgICAgICAgImVkaXRvciIKICAgICAgXQogICAgfSwKICAgIHsKICAgICAgInRyYW5zaXRpb24iOiAicmVqZWN0IiwKICAgICAgInJvbGVzIjogWwogICAgICAgICJlZGl0b3IiCiAgICAgIF0KICAgIH0sCiAgICB7CiAgICAgICJ0cmFuc2l0aW9uIjogInVucHVibGlzaCIsCiAgICAgICJyb2xlcyI6IFsKICAgICAgICAiZWRpdG9yIgogICAgICBdCiAgICB9LAogICAgewogICAgICAidHJhbnNpdGlvbiI6ICJyZXN0b3JlIiwKICAgICAgInJvbGVzIjogWwogICAgICAgICJhZG1pbiIKICAgICAgXQogICAgfQogIF0sCiAgInZpZXdzIjogWwogICAgewogICAgICAiaWQiOiAicG9zdC1saXN0IiwKICAgICAgIm5hbWUiOiAiQWxsIFBvc3RzIiwKICAgICAgImtpbmQiOiAidGFibGUiLAogICAgICAiZGVzY3JpcHRpb24iOiAiTGlzdCB2aWV3IG9mIGFsbCBibG9nIHBvc3RzIiwKICAgICAgImdyb3VwcyI6IFsKICAgICAgICB7CiAgICAgICAgICAiaWQiOiAiY29sdW1ucyIsCiAgICAgICAgICAiZmllbGRzIjogWwogICAgICAgICAgICB7CiAgICAgICAgICAgICAgImJpbmRpbmciOiAic3RhdHVzIiwKICAgICAgICAgICAgICAibGFiZWwiOiAiU3RhdHVzIiwKICAgICAgICAgICAgICAidHlwZSI6ICJiYWRnZSIsCiAgICAgICAgICAgICAgInJlYWRvbmx5IjogdHJ1ZQogICAgICAgICAgICB9CiAgICAgICAgICBdCiAgICAgICAgfQogICAgICBdLAogICAgICAiYWN0aW9ucyI6IFsKICAgICAgICAic3VibWl0IiwKICAgICAgICAiYXBwcm92ZSIsCiAgICAgICAgInJlamVjdCIKICAgICAgXQogICAgfSwKICAgIHsKICAgICAgImlkIjogInBvc3QtZGV0YWlsIiwKICAgICAgIm5hbWUiOiAiUG9zdCBEZXRhaWwiLAogICAgICAia2luZCI6ICJkZXRhaWwiLAogICAgICAiZGVzY3JpcHRpb24iOiAiRnVsbCBkZXRhaWwgdmlldyBvZiBhIGJsb2cgcG9zdCIsCiAgICAgICJncm91cHMiOiBbCiAgICAgICAgewogICAgICAgICAgImlkIjogIndvcmtmbG93IiwKICAgICAgICAgICJuYW1lIjogIldvcmtmbG93IiwKICAgICAgICAgICJmaWVsZHMiOiBbCiAgICAgICAgICAgIHsKICAgICAgICAgICAgICAiYmluZGluZyI6ICJzdGF0dXMiLAogICAgICAgICAgICAgICJsYWJlbCI6ICJTdGF0dXMiLAogICAgICAgICAgICAgICJ0eXBlIjogImJhZGdlIiwKICAgICAgICAgICAgICAicmVhZG9ubHkiOiB0cnVlCiAgICAgICAgICAgIH0KICAgICAgICAgIF0KICAgICAgICB9CiAgICAgIF0sCiAgICAgICJhY3Rpb25zIjogWwogICAgICAgICJ1cGRhdGUiLAogICAgICAgICJzdWJtaXQiLAogICAgICAgICJhcHByb3ZlIiwKICAgICAgICAicmVqZWN0IiwKICAgICAgICAidW5wdWJsaXNoIiwKICAgICAgICAicmVzdG9yZSIKICAgICAgXQogICAgfQogIF0sCiAgIm5hdmlnYXRpb24iOiB7CiAgICAiYnJhbmQiOiAiQmxvZyIsCiAgICAiaXRlbXMiOiBbCiAgICAgIHsKICAgICAgICAibGFiZWwiOiAiUG9zdHMiLAogICAgICAgICJwYXRoIjogIi8iLAogICAgICAgICJpY29uIjogIvCfk50iCiAgICAgIH0sCiAgICAgIHsKICAgICAgICAibGFiZWwiOiAiQWRtaW4iLAogICAgICAgICJwYXRoIjogIi9hZG1pbiIsCiAgICAgICAgImljb24iOiAi4pqZ77iPIiwKICAgICAgICAicm9sZXMiOiBbCiAgICAgICAgICAiYWRtaW4iLAogICAgICAgICAgImVkaXRvciIKICAgICAgICBdCiAgICAgIH0KICAgIF0KICB9LAogICJhZG1pbiI6IHsKICAgICJlbmFibGVkIjogdHJ1ZSwKICAgICJwYXRoIjogIi9hZG1pbiIsCiAgICAicm9sZXMiOiBbCiAgICAgICJhZG1pbiIsCiAgICAgICJlZGl0b3IiCiAgICBdLAogICAgImZlYXR1cmVzIjogWwogICAgICAibGlzdCIsCiAgICAgICJkZXRhaWwiLAogICAgICAiaGlzdG9yeSIKICAgIF0KICB9LAogICJkZWJ1ZyI6IHsKICAgICJlbmFibGVkIjogdHJ1ZSwKICAgICJldmFsIjogdHJ1ZQogIH0KfQ=="

	return func(w http.ResponseWriter, r *http.Request) {
		schemaJSON, err := base64.StdEncoding.DecodeString(schemaBase64)
		if err != nil {
			api.Error(w, http.StatusInternalServerError, "schema_decode_error", "Failed to decode schema")
			return
		}
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusOK)
		w.Write(schemaJSON)
	}
}

