// Code generated by petri-pilot. DO NOT EDIT.

package blogpost

import (
	"context"
	"crypto/rand"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/http"
	"strings"
	"time"

	"golang.org/x/oauth2"
	"golang.org/x/oauth2/github"
)

// User represents an authenticated GitHub user.
type User struct {
	ID        int64    `json:"id"`
	Login     string   `json:"login"`
	Name      string   `json:"name"`
	Email     string   `json:"email"`
	AvatarURL string   `json:"avatar_url"`
	Roles     []string `json:"roles,omitempty"` // User roles for access control
}

// Session represents an authenticated session.
type Session struct {
	User      *User     `json:"user"`
	Token     string    `json:"token"`
	ExpiresAt time.Time `json:"expires_at"`
}

// SessionStore manages user sessions.
type SessionStore interface {
	Create(ctx context.Context, user *User) (*Session, error)
	Get(ctx context.Context, token string) (*Session, error)
	Delete(ctx context.Context, token string) error
}

// InMemorySessionStore is a simple in-memory session store.
type InMemorySessionStore struct {
	sessions map[string]*Session
}

// NewInMemorySessionStore creates a new in-memory session store.
func NewInMemorySessionStore() *InMemorySessionStore {
	return &InMemorySessionStore{
		sessions: make(map[string]*Session),
	}
}

func (s *InMemorySessionStore) Create(ctx context.Context, user *User) (*Session, error) {
	token := generateToken(32)
	session := &Session{
		User:      user,
		Token:     token,
		ExpiresAt: time.Now().Add(24 * time.Hour),
	}
	s.sessions[token] = session
	return session, nil
}

func (s *InMemorySessionStore) Get(ctx context.Context, token string) (*Session, error) {
	session, ok := s.sessions[token]
	if !ok {
		return nil, fmt.Errorf("session not found")
	}
	if time.Now().After(session.ExpiresAt) {
		delete(s.sessions, token)
		return nil, fmt.Errorf("session expired")
	}
	return session, nil
}

func (s *InMemorySessionStore) Delete(ctx context.Context, token string) error {
	delete(s.sessions, token)
	return nil
}

func generateToken(length int) string {
	b := make([]byte, length)
	rand.Read(b)
	return base64.URLEncoding.EncodeToString(b)
}

// AuthHandler handles GitHub OAuth authentication.
type AuthHandler struct {
	config      *oauth2.Config
	sessions    SessionStore
	states      map[string]time.Time // CSRF state tokens
	frontendURL string               // URL to redirect to after OAuth
}

// NewAuthHandler creates a new auth handler.
func NewAuthHandler(clientID, clientSecret, callbackURL, frontendURL string, sessions SessionStore) *AuthHandler {
	return &AuthHandler{
		config: &oauth2.Config{
			ClientID:     clientID,
			ClientSecret: clientSecret,
			Scopes:       []string{"user:email"},
			Endpoint:     github.Endpoint,
			RedirectURL:  callbackURL,
		},
		sessions:    sessions,
		states:      make(map[string]time.Time),
		frontendURL: frontendURL,
	}
}

// HandleLogin redirects to GitHub OAuth.
func (h *AuthHandler) HandleLogin(w http.ResponseWriter, r *http.Request) {
	state := generateToken(16)
	h.states[state] = time.Now().Add(10 * time.Minute)

	// Clean up old states
	for s, exp := range h.states {
		if time.Now().After(exp) {
			delete(h.states, s)
		}
	}

	url := h.config.AuthCodeURL(state)
	http.Redirect(w, r, url, http.StatusTemporaryRedirect)
}

// HandleCallback handles the GitHub OAuth callback.
func (h *AuthHandler) HandleCallback(w http.ResponseWriter, r *http.Request) {
	state := r.URL.Query().Get("state")
	exp, ok := h.states[state]
	if !ok || time.Now().After(exp) {
		http.Error(w, "invalid state", http.StatusBadRequest)
		return
	}
	delete(h.states, state)

	code := r.URL.Query().Get("code")
	token, err := h.config.Exchange(r.Context(), code)
	if err != nil {
		http.Error(w, "failed to exchange token", http.StatusInternalServerError)
		return
	}

	// Fetch user info from GitHub
	client := h.config.Client(r.Context(), token)
	resp, err := client.Get("https://api.github.com/user")
	if err != nil {
		http.Error(w, "failed to fetch user", http.StatusInternalServerError)
		return
	}
	defer resp.Body.Close()

	var user User
	if err := json.NewDecoder(resp.Body).Decode(&user); err != nil {
		http.Error(w, "failed to decode user", http.StatusInternalServerError)
		return
	}

	// Create session
	session, err := h.sessions.Create(r.Context(), &user)
	if err != nil {
		http.Error(w, "failed to create session", http.StatusInternalServerError)
		return
	}

	// Redirect to frontend with token in URL params
	// The frontend will extract these and store in localStorage
	redirectURL := h.frontendURL + "?token=" + session.Token + "&expires_at=" + session.ExpiresAt.Format(time.RFC3339)
	http.Redirect(w, r, redirectURL, http.StatusTemporaryRedirect)
}

// HandleLogout invalidates the session.
func (h *AuthHandler) HandleLogout(w http.ResponseWriter, r *http.Request) {
	token := extractToken(r)
	if token != "" {
		h.sessions.Delete(r.Context(), token)
	}
	w.WriteHeader(http.StatusNoContent)
}

// HandleMe returns the current user.
func (h *AuthHandler) HandleMe(w http.ResponseWriter, r *http.Request) {
	user := UserFromContext(r.Context())
	if user == nil {
		http.Error(w, "unauthorized", http.StatusUnauthorized)
		return
	}
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(user)
}

// Context keys
type contextKey string

const userContextKey contextKey = "user"

// UserFromContext extracts the user from context.
func UserFromContext(ctx context.Context) *User {
	user, _ := ctx.Value(userContextKey).(*User)
	return user
}

// AuthMiddleware validates session tokens.
func AuthMiddleware(sessions SessionStore) func(http.Handler) http.Handler {
	return func(next http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			token := extractToken(r)
			if token == "" {
				http.Error(w, "unauthorized", http.StatusUnauthorized)
				return
			}

			session, err := sessions.Get(r.Context(), token)
			if err != nil {
				http.Error(w, "unauthorized", http.StatusUnauthorized)
				return
			}

			ctx := context.WithValue(r.Context(), userContextKey, session.User)
			next.ServeHTTP(w, r.WithContext(ctx))
		})
	}
}

// OptionalAuthMiddleware adds user to context if authenticated, but doesn't require it.
func OptionalAuthMiddleware(sessions SessionStore) func(http.Handler) http.Handler {
	return func(next http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			token := extractToken(r)
			if token != "" {
				if session, err := sessions.Get(r.Context(), token); err == nil {
					ctx := context.WithValue(r.Context(), userContextKey, session.User)
					r = r.WithContext(ctx)
				}
			}
			next.ServeHTTP(w, r)
		})
	}
}

func extractToken(r *http.Request) string {
	// Check Authorization header
	auth := r.Header.Get("Authorization")
	if strings.HasPrefix(auth, "Bearer ") {
		return strings.TrimPrefix(auth, "Bearer ")
	}
	// Check cookie
	if cookie, err := r.Cookie("session"); err == nil {
		return cookie.Value
	}
	return ""
}

// HandleAuthStatus returns the authentication configuration status.
// This allows the frontend to know whether GitHub OAuth is available.
func (h *AuthHandler) HandleAuthStatus(w http.ResponseWriter, r *http.Request) {
	enabled := h.config.ClientID != ""
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(map[string]any{
		"github_enabled": enabled,
	})
}

// RegisterAuthRoutes registers authentication routes.
func RegisterAuthRoutes(mux *http.ServeMux, auth *AuthHandler) {
	mux.HandleFunc("GET /auth/status", auth.HandleAuthStatus)
	mux.HandleFunc("GET /auth/login", auth.HandleLogin)
	mux.HandleFunc("GET /auth/callback", auth.HandleCallback)
	mux.HandleFunc("POST /auth/logout", auth.HandleLogout)
	mux.HandleFunc("GET /auth/me", auth.HandleMe)
}
