# Code generated by petri-pilot. DO NOT EDIT.
# GraphQL schema for blog-post

scalar Time

type Query {
  # Get aggregate state by ID
  blogpost(id: ID!): AggregateState

  # List aggregates with optional filtering
  blogpostList(place: String, page: Int, perPage: Int): AggregateList!

  # Admin statistics
  adminStats: AdminStats!

  # Event history for an aggregate
  events(aggregateId: ID!, from: Int): [Event!]!

  # Get state at specific version
  stateAtVersion(aggregateId: ID!, version: Int!): AggregateState
}

type Mutation {
  # Create a new blog-post instance
  createBlogpost: AggregateState!

  # Create a new blog post
  createPost(input: CreatePostInput!): TransitionResult!

  # Update post content
  update(input: UpdateInput!): TransitionResult!

  # Submit draft for review
  submit(input: SubmitInput!): TransitionResult!

  # Approve and publish the post
  approve(input: ApproveInput!): TransitionResult!

  # Reject and return to draft
  reject(input: RejectInput!): TransitionResult!

  # Take down a published post
  unpublish(input: UnpublishInput!): TransitionResult!

  # Restore archived post to draft
  restore(input: RestoreInput!): TransitionResult!
}

# Aggregate state representation
type AggregateState {
  id: ID!
  version: Int!
  state: State!
  places: Places!
  enabledTransitions: [String!]!
}

# Workflow state with all places
type State {
  draft: Int!
  inReview: Int!
  published: Int!
  archived: Int!
}

# Token counts for each place
type Places {
  draft: Int!
  inReview: Int!
  published: Int!
  archived: Int!
}

# Result of a transition execution
type TransitionResult {
  success: Boolean!
  aggregateId: ID
  version: Int
  state: Places
  enabledTransitions: [String!]
  error: String
}

# Paginated list of aggregates
type AggregateList {
  items: [AggregateState!]!
  total: Int!
  page: Int!
  perPage: Int!
}

# Admin statistics
type AdminStats {
  totalInstances: Int!
  byPlace: [PlaceCount!]!
}

type PlaceCount {
  place: String!
  count: Int!
}


# Event record
type Event {
  id: ID!
  streamId: String!
  type: String!
  version: Int!
  timestamp: Time!
  data: String!
}


# Input types for mutations

input CreatePostInput {
  aggregateId: ID!
  title: String
  content: String
  author_id: String
  author_name: String
  tags: String
}


input UpdateInput {
  aggregateId: ID!
  title: String
  content: String
  tags: String
}


input SubmitInput {
  aggregateId: ID!
}


input ApproveInput {
  aggregateId: ID!
}


input RejectInput {
  aggregateId: ID!
  rejected_by: String
  reason: String
}


input UnpublishInput {
  aggregateId: ID!
}


input RestoreInput {
  aggregateId: ID!
}

