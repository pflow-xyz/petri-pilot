// Code generated by petri-pilot. DO NOT EDIT.

package coffeeshop

import (
	"encoding/base64"
	"encoding/json"
	"io/fs"
	"net/http"
	"os"
	"path/filepath"
	"strconv"
	"strings"

	"github.com/pflow-xyz/petri-pilot/pkg/runtime/api"
)

// BuildRouter creates an HTTP router for the coffeeshop workflow.
func BuildRouter(app *Application, debugBroker *DebugBroker) http.Handler {
	r := api.NewRouter()

	// Health check - always returns ok if server is running
	r.GET("/health", "Health check", func(w http.ResponseWriter, r *http.Request) {
		api.JSON(w, http.StatusOK, map[string]string{"status": "ok"})
	})

	// Readiness check - verifies dependencies (database, etc.)
	r.GET("/ready", "Readiness check", HandleReady(app))

	// Create new aggregate
	r.POST("/api/coffeeshop", "Create new coffeeshop", HandleCreate(app))

	// Get aggregate state
	r.GET("/api/coffeeshop/{id}", "Get coffeeshop state", HandleGetState(app))


	// Schema viewer endpoint
	r.GET("/api/schema", "Get model schema", HandleGetSchema())



	// Event replay endpoints
	r.GET("/api/coffeeshop/{id}/events", "Get event history", HandleGetEvents(app))
	r.GET("/api/coffeeshop/{id}/at/{version}", "Get state at version", HandleGetStateAtVersion(app))
	r.POST("/api/coffeeshop/{id}/truncate", "Truncate event history to version", HandleTruncate(app))



	// Prediction endpoints
	r.GET("/api/coffeeshop/predict", "Run simulation prediction", HandlePredict(app))
	r.GET("/api/coffeeshop/runout", "Get runout predictions", HandleRunout(app))




	// Debug WebSocket and eval endpoints
	r.GET("/ws", "Debug WebSocket connection", HandleDebugWebSocket(debugBroker))
	r.GET("/api/debug/sessions", "List debug sessions", HandleListSessions(debugBroker))
	r.POST("/api/debug/sessions/{id}/eval", "Evaluate code in browser session", HandleSessionEval(debugBroker))
	// Guest login endpoint (debug mode without access control)
	r.POST("/api/debug/login", "Create debug guest session", HandleDebugGuestLogin())

















	// Transition endpoints
	r.Transition("order_espresso", "/api/order_espresso", "Customer orders espresso", HandleOrderEspresso(app))
	r.Transition("order_latte", "/api/order_latte", "Customer orders latte", HandleOrderLatte(app))
	r.Transition("order_cappuccino", "/api/order_cappuccino", "Customer orders cappuccino", HandleOrderCappuccino(app))
	r.Transition("make_espresso", "/api/make_espresso", "Barista makes espresso", HandleMakeEspresso(app))
	r.Transition("make_latte", "/api/make_latte", "Barista makes latte", HandleMakeLatte(app))
	r.Transition("make_cappuccino", "/api/make_cappuccino", "Barista makes cappuccino", HandleMakeCappuccino(app))
	r.Transition("serve_espresso", "/api/serve_espresso", "Serve espresso to customer", HandleServeEspresso(app))
	r.Transition("serve_latte", "/api/serve_latte", "Serve latte to customer", HandleServeLatte(app))
	r.Transition("serve_cappuccino", "/api/serve_cappuccino", "Serve cappuccino to customer", HandleServeCappuccino(app))
	r.Transition("restock_coffee_beans", "/api/restock_coffee_beans", "Restock coffee beans inventory", HandleRestockCoffeeBeans(app))
	r.Transition("restock_milk", "/api/restock_milk", "Restock milk inventory", HandleRestockMilk(app))
	r.Transition("restock_cups", "/api/restock_cups", "Restock cup inventory", HandleRestockCups(app))

	// Serve frontend static files
	r.StaticFiles("/", StaticFileHandler())

	return r.Build()
}

// StaticFileHandler returns an http.Handler that serves static files from frontend/.
// It supports SPA routing by returning index.html for paths that don't match static files.
func StaticFileHandler() http.HandlerFunc {
	// Find frontend directory - try custom frontends first, then generated
	frontendPath := ""
	candidates := []string{
		"frontends/coffeeshop",                    // Custom frontend (top priority)
		"frontend",                                    // Running from service directory
		"generated/coffeeshop/frontend",         // Generated frontend from repo root
		filepath.Join("generated", "coffeeshop", "frontend"), // Platform-safe
	}

	// Also try relative to executable
	if exe, err := os.Executable(); err == nil {
		exeDir := filepath.Dir(exe)
		candidates = append(candidates,
			filepath.Join(exeDir, "frontends", "coffeeshop"),
			filepath.Join(exeDir, "frontend"),
			filepath.Join(exeDir, "generated", "coffeeshop", "frontend"),
		)
	}

	for _, candidate := range candidates {
		if _, err := os.Stat(candidate); err == nil {
			frontendPath = candidate
			break
		}
	}

	return func(w http.ResponseWriter, r *http.Request) {
		// No frontend found
		if frontendPath == "" {
			http.Error(w, "Frontend not found", http.StatusNotFound)
			return
		}

		// Clean the path
		path := strings.TrimPrefix(r.URL.Path, "/")
		if path == "" {
			path = "index.html"
		}

		// Try to serve the file
		fullPath := filepath.Join(frontendPath, path)

		// Check if file exists
		info, err := os.Stat(fullPath)
		if err != nil || info.IsDir() {
			// File doesn't exist, serve index.html for SPA routing
			http.ServeFile(w, r, filepath.Join(frontendPath, "index.html"))
			return
		}

		http.ServeFile(w, r, fullPath)
	}
}

// StaticFS is a helper interface for embedding static files (optional).
type StaticFS interface {
	fs.FS
}

// HandleCreate creates a new aggregate instance.
func HandleCreate(app *Application) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()

		id, err := app.Create(ctx)
		if err != nil {
			api.Error(w, http.StatusInternalServerError, "CREATE_FAILED", err.Error())
			return
		}

		// Load the new aggregate to get initial state
		agg, err := app.Load(ctx, id)
		if err != nil {
			api.Error(w, http.StatusInternalServerError, "LOAD_FAILED", err.Error())
			return
		}

		api.JSON(w, http.StatusCreated, api.StateResponse{
			AggregateID:        agg.ID(),
			Version:            agg.Version(),
			State:              agg.State(),
			Places:             agg.Places(),
			EnabledTransitions: agg.EnabledTransitions(),
		})
	}
}

// HandleGetState returns the current state of an aggregate.
func HandleGetState(app *Application) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()
		id := r.PathValue("id")
		if id == "" {
			api.Error(w, http.StatusBadRequest, "MISSING_ID", "aggregate ID is required")
			return
		}

		agg, err := app.GetState(ctx, id)
		if err != nil {
			api.Error(w, http.StatusNotFound, "NOT_FOUND", err.Error())
			return
		}

		api.JSON(w, http.StatusOK, api.StateResponse{
			AggregateID:        agg.ID(),
			Version:            agg.Version(),
			State:              agg.State(),
			Places:             agg.Places(),
			EnabledTransitions: agg.EnabledTransitions(),
		})
	}
}

// HandleReady checks if the application is ready to serve requests.
// Returns 200 if all dependencies are available, 503 otherwise.
func HandleReady(app *Application) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		checks := make(map[string]string)
		ready := true

		// Check event store connectivity
		if err := app.HealthCheck(r.Context()); err != nil {
			checks["eventstore"] = err.Error()
			ready = false
		} else {
			checks["eventstore"] = "ok"
		}

		status := http.StatusOK
		statusText := "ready"
		if !ready {
			status = http.StatusServiceUnavailable
			statusText = "not ready"
		}

		api.JSON(w, status, map[string]any{
			"status": statusText,
			"checks": checks,
		})
	}
}


// HandleOrderEspresso handles the order_espresso transition.
func HandleOrderEspresso(app *Application) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()

		var req api.TransitionRequest
		if err := api.DecodeJSON(r, &req); err != nil {
			api.Error(w, http.StatusBadRequest, "INVALID_REQUEST", err.Error())
			return
		}

		if req.AggregateID == "" {
			api.Error(w, http.StatusBadRequest, "MISSING_ID", "aggregate_id is required")
			return
		}

		agg, err := app.Execute(ctx, req.AggregateID, TransitionOrderEspresso, req.Data)
		if err != nil {
			api.Error(w, http.StatusConflict, "TRANSITION_FAILED", err.Error())
			return
		}

		api.JSON(w, http.StatusOK, api.TransitionResult{
			Success:            true,
			AggregateID:        agg.ID(),
			Version:            agg.Version(),
			State:              agg.Places(),
			EnabledTransitions: agg.EnabledTransitions(),
		})
	}
}


// HandleOrderLatte handles the order_latte transition.
func HandleOrderLatte(app *Application) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()

		var req api.TransitionRequest
		if err := api.DecodeJSON(r, &req); err != nil {
			api.Error(w, http.StatusBadRequest, "INVALID_REQUEST", err.Error())
			return
		}

		if req.AggregateID == "" {
			api.Error(w, http.StatusBadRequest, "MISSING_ID", "aggregate_id is required")
			return
		}

		agg, err := app.Execute(ctx, req.AggregateID, TransitionOrderLatte, req.Data)
		if err != nil {
			api.Error(w, http.StatusConflict, "TRANSITION_FAILED", err.Error())
			return
		}

		api.JSON(w, http.StatusOK, api.TransitionResult{
			Success:            true,
			AggregateID:        agg.ID(),
			Version:            agg.Version(),
			State:              agg.Places(),
			EnabledTransitions: agg.EnabledTransitions(),
		})
	}
}


// HandleOrderCappuccino handles the order_cappuccino transition.
func HandleOrderCappuccino(app *Application) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()

		var req api.TransitionRequest
		if err := api.DecodeJSON(r, &req); err != nil {
			api.Error(w, http.StatusBadRequest, "INVALID_REQUEST", err.Error())
			return
		}

		if req.AggregateID == "" {
			api.Error(w, http.StatusBadRequest, "MISSING_ID", "aggregate_id is required")
			return
		}

		agg, err := app.Execute(ctx, req.AggregateID, TransitionOrderCappuccino, req.Data)
		if err != nil {
			api.Error(w, http.StatusConflict, "TRANSITION_FAILED", err.Error())
			return
		}

		api.JSON(w, http.StatusOK, api.TransitionResult{
			Success:            true,
			AggregateID:        agg.ID(),
			Version:            agg.Version(),
			State:              agg.Places(),
			EnabledTransitions: agg.EnabledTransitions(),
		})
	}
}


// HandleMakeEspresso handles the make_espresso transition.
func HandleMakeEspresso(app *Application) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()

		var req api.TransitionRequest
		if err := api.DecodeJSON(r, &req); err != nil {
			api.Error(w, http.StatusBadRequest, "INVALID_REQUEST", err.Error())
			return
		}

		if req.AggregateID == "" {
			api.Error(w, http.StatusBadRequest, "MISSING_ID", "aggregate_id is required")
			return
		}

		agg, err := app.Execute(ctx, req.AggregateID, TransitionMakeEspresso, req.Data)
		if err != nil {
			api.Error(w, http.StatusConflict, "TRANSITION_FAILED", err.Error())
			return
		}

		api.JSON(w, http.StatusOK, api.TransitionResult{
			Success:            true,
			AggregateID:        agg.ID(),
			Version:            agg.Version(),
			State:              agg.Places(),
			EnabledTransitions: agg.EnabledTransitions(),
		})
	}
}


// HandleMakeLatte handles the make_latte transition.
func HandleMakeLatte(app *Application) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()

		var req api.TransitionRequest
		if err := api.DecodeJSON(r, &req); err != nil {
			api.Error(w, http.StatusBadRequest, "INVALID_REQUEST", err.Error())
			return
		}

		if req.AggregateID == "" {
			api.Error(w, http.StatusBadRequest, "MISSING_ID", "aggregate_id is required")
			return
		}

		agg, err := app.Execute(ctx, req.AggregateID, TransitionMakeLatte, req.Data)
		if err != nil {
			api.Error(w, http.StatusConflict, "TRANSITION_FAILED", err.Error())
			return
		}

		api.JSON(w, http.StatusOK, api.TransitionResult{
			Success:            true,
			AggregateID:        agg.ID(),
			Version:            agg.Version(),
			State:              agg.Places(),
			EnabledTransitions: agg.EnabledTransitions(),
		})
	}
}


// HandleMakeCappuccino handles the make_cappuccino transition.
func HandleMakeCappuccino(app *Application) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()

		var req api.TransitionRequest
		if err := api.DecodeJSON(r, &req); err != nil {
			api.Error(w, http.StatusBadRequest, "INVALID_REQUEST", err.Error())
			return
		}

		if req.AggregateID == "" {
			api.Error(w, http.StatusBadRequest, "MISSING_ID", "aggregate_id is required")
			return
		}

		agg, err := app.Execute(ctx, req.AggregateID, TransitionMakeCappuccino, req.Data)
		if err != nil {
			api.Error(w, http.StatusConflict, "TRANSITION_FAILED", err.Error())
			return
		}

		api.JSON(w, http.StatusOK, api.TransitionResult{
			Success:            true,
			AggregateID:        agg.ID(),
			Version:            agg.Version(),
			State:              agg.Places(),
			EnabledTransitions: agg.EnabledTransitions(),
		})
	}
}


// HandleServeEspresso handles the serve_espresso transition.
func HandleServeEspresso(app *Application) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()

		var req api.TransitionRequest
		if err := api.DecodeJSON(r, &req); err != nil {
			api.Error(w, http.StatusBadRequest, "INVALID_REQUEST", err.Error())
			return
		}

		if req.AggregateID == "" {
			api.Error(w, http.StatusBadRequest, "MISSING_ID", "aggregate_id is required")
			return
		}

		agg, err := app.Execute(ctx, req.AggregateID, TransitionServeEspresso, req.Data)
		if err != nil {
			api.Error(w, http.StatusConflict, "TRANSITION_FAILED", err.Error())
			return
		}

		api.JSON(w, http.StatusOK, api.TransitionResult{
			Success:            true,
			AggregateID:        agg.ID(),
			Version:            agg.Version(),
			State:              agg.Places(),
			EnabledTransitions: agg.EnabledTransitions(),
		})
	}
}


// HandleServeLatte handles the serve_latte transition.
func HandleServeLatte(app *Application) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()

		var req api.TransitionRequest
		if err := api.DecodeJSON(r, &req); err != nil {
			api.Error(w, http.StatusBadRequest, "INVALID_REQUEST", err.Error())
			return
		}

		if req.AggregateID == "" {
			api.Error(w, http.StatusBadRequest, "MISSING_ID", "aggregate_id is required")
			return
		}

		agg, err := app.Execute(ctx, req.AggregateID, TransitionServeLatte, req.Data)
		if err != nil {
			api.Error(w, http.StatusConflict, "TRANSITION_FAILED", err.Error())
			return
		}

		api.JSON(w, http.StatusOK, api.TransitionResult{
			Success:            true,
			AggregateID:        agg.ID(),
			Version:            agg.Version(),
			State:              agg.Places(),
			EnabledTransitions: agg.EnabledTransitions(),
		})
	}
}


// HandleServeCappuccino handles the serve_cappuccino transition.
func HandleServeCappuccino(app *Application) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()

		var req api.TransitionRequest
		if err := api.DecodeJSON(r, &req); err != nil {
			api.Error(w, http.StatusBadRequest, "INVALID_REQUEST", err.Error())
			return
		}

		if req.AggregateID == "" {
			api.Error(w, http.StatusBadRequest, "MISSING_ID", "aggregate_id is required")
			return
		}

		agg, err := app.Execute(ctx, req.AggregateID, TransitionServeCappuccino, req.Data)
		if err != nil {
			api.Error(w, http.StatusConflict, "TRANSITION_FAILED", err.Error())
			return
		}

		api.JSON(w, http.StatusOK, api.TransitionResult{
			Success:            true,
			AggregateID:        agg.ID(),
			Version:            agg.Version(),
			State:              agg.Places(),
			EnabledTransitions: agg.EnabledTransitions(),
		})
	}
}


// HandleRestockCoffeeBeans handles the restock_coffee_beans transition.
func HandleRestockCoffeeBeans(app *Application) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()

		var req api.TransitionRequest
		if err := api.DecodeJSON(r, &req); err != nil {
			api.Error(w, http.StatusBadRequest, "INVALID_REQUEST", err.Error())
			return
		}

		if req.AggregateID == "" {
			api.Error(w, http.StatusBadRequest, "MISSING_ID", "aggregate_id is required")
			return
		}

		agg, err := app.Execute(ctx, req.AggregateID, TransitionRestockCoffeeBeans, req.Data)
		if err != nil {
			api.Error(w, http.StatusConflict, "TRANSITION_FAILED", err.Error())
			return
		}

		api.JSON(w, http.StatusOK, api.TransitionResult{
			Success:            true,
			AggregateID:        agg.ID(),
			Version:            agg.Version(),
			State:              agg.Places(),
			EnabledTransitions: agg.EnabledTransitions(),
		})
	}
}


// HandleRestockMilk handles the restock_milk transition.
func HandleRestockMilk(app *Application) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()

		var req api.TransitionRequest
		if err := api.DecodeJSON(r, &req); err != nil {
			api.Error(w, http.StatusBadRequest, "INVALID_REQUEST", err.Error())
			return
		}

		if req.AggregateID == "" {
			api.Error(w, http.StatusBadRequest, "MISSING_ID", "aggregate_id is required")
			return
		}

		agg, err := app.Execute(ctx, req.AggregateID, TransitionRestockMilk, req.Data)
		if err != nil {
			api.Error(w, http.StatusConflict, "TRANSITION_FAILED", err.Error())
			return
		}

		api.JSON(w, http.StatusOK, api.TransitionResult{
			Success:            true,
			AggregateID:        agg.ID(),
			Version:            agg.Version(),
			State:              agg.Places(),
			EnabledTransitions: agg.EnabledTransitions(),
		})
	}
}


// HandleRestockCups handles the restock_cups transition.
func HandleRestockCups(app *Application) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()

		var req api.TransitionRequest
		if err := api.DecodeJSON(r, &req); err != nil {
			api.Error(w, http.StatusBadRequest, "INVALID_REQUEST", err.Error())
			return
		}

		if req.AggregateID == "" {
			api.Error(w, http.StatusBadRequest, "MISSING_ID", "aggregate_id is required")
			return
		}

		agg, err := app.Execute(ctx, req.AggregateID, TransitionRestockCups, req.Data)
		if err != nil {
			api.Error(w, http.StatusConflict, "TRANSITION_FAILED", err.Error())
			return
		}

		api.JSON(w, http.StatusOK, api.TransitionResult{
			Success:            true,
			AggregateID:        agg.ID(),
			Version:            agg.Version(),
			State:              agg.Places(),
			EnabledTransitions: agg.EnabledTransitions(),
		})
	}
}


// HandlePredict runs ODE simulation and returns predicted resource levels.
func HandlePredict(app *Application) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()
		hoursStr := r.URL.Query().Get("hours")
		hours := PredictionConfig.TimeHours
		if hoursStr != "" {
			if h, err := strconv.ParseFloat(hoursStr, 64); err == nil && h > 0 {
				hours = h
			}
		}

		// Get current token counts from aggregate if provided
		currentTokens := GetCurrentInventory()
		if aggID := r.URL.Query().Get("aggregate_id"); aggID != "" {
			if agg, err := app.Load(ctx, aggID); err == nil {
				currentTokens = make(map[string]int)
				for place, tokens := range agg.Places() {
					currentTokens[place] = tokens
				}
			}
		}

		// Parse custom rates if provided
		rates := getCustomRates(r)

		result, err := RunSimulationWithRates(currentTokens, hours, rates)
		if err != nil {
			api.Error(w, http.StatusInternalServerError, "SIMULATION_FAILED", err.Error())
			return
		}

		api.JSON(w, http.StatusOK, result)
	}
}

// HandleRunout returns predicted runout times for resources.
func HandleRunout(app *Application) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()

		// Get current token counts from aggregate if provided
		currentTokens := GetCurrentInventory()
		if aggID := r.URL.Query().Get("aggregate_id"); aggID != "" {
			if agg, err := app.Load(ctx, aggID); err == nil {
				currentTokens = make(map[string]int)
				for place, tokens := range agg.Places() {
					currentTokens[place] = tokens
				}
			}
		}

		// Parse custom rates if provided
		rates := getCustomRates(r)

		result, err := RunSimulationWithRates(currentTokens, PredictionConfig.TimeHours, rates)
		if err != nil {
			api.Error(w, http.StatusInternalServerError, "SIMULATION_FAILED", err.Error())
			return
		}

		api.JSON(w, http.StatusOK, result.RunoutTime)
	}
}

// getCustomRates extracts transition rates from query parameters.
func getCustomRates(r *http.Request) map[string]float64 {
	rates := make(map[string]float64)
	rateParams := []string{
		"order_espresso", "order_latte", "order_cappuccino",
		"make_espresso", "make_latte", "make_cappuccino",
		"serve_espresso", "serve_latte", "serve_cappuccino",
	}
	for _, param := range rateParams {
		if val := r.URL.Query().Get(param); val != "" {
			if rate, err := strconv.ParseFloat(val, 64); err == nil {
				rates[param] = rate
			}
		}
	}
	return rates
}






// HandleGetEvents returns the event history for an aggregate.
func HandleGetEvents(app *Application) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()
		id := r.PathValue("id")
		from := getIntQueryParam(r, "from", 0)

		events, err := app.store.Read(ctx, id, from)
		if err != nil {
			api.Error(w, http.StatusInternalServerError, "READ_FAILED", err.Error())
			return
		}

		api.JSON(w, http.StatusOK, map[string]interface{}{
			"events": events,
		})
	}
}

// HandleGetStateAtVersion returns the aggregate state at a specific version.
func HandleGetStateAtVersion(app *Application) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()
		id := r.PathValue("id")
		versionStr := r.PathValue("version")

		version := getInt(versionStr, 0)
		if version <= 0 {
			api.Error(w, http.StatusBadRequest, "INVALID_VERSION", "version must be a positive integer")
			return
		}

		events, err := app.store.Read(ctx, id, 0)
		if err != nil {
			api.Error(w, http.StatusInternalServerError, "READ_FAILED", err.Error())
			return
		}

		// Create temporary aggregate and replay up to version
		agg := NewAggregate(id)
		for _, evt := range events {
			if evt.Version > version {
				break
			}
			if err := agg.Apply(evt); err != nil {
				api.Error(w, http.StatusInternalServerError, "APPLY_FAILED", err.Error())
				return
			}
		}

		api.JSON(w, http.StatusOK, map[string]interface{}{
			"id":      agg.ID(),
			"version": version,
			"state":   agg.State(),
		})
	}
}

// HandleTruncate truncates the event stream to a specific version.
// This enables "undo and redo differently" workflows by discarding events after the target version.
func HandleTruncate(app *Application) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()
		id := r.PathValue("id")

		var req struct {
			Version int `json:"version"`
		}
		if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
			api.Error(w, http.StatusBadRequest, "INVALID_REQUEST", "request body must contain version field")
			return
		}

		if req.Version < 0 {
			api.Error(w, http.StatusBadRequest, "INVALID_VERSION", "version must be non-negative")
			return
		}

		agg, err := app.TruncateTo(ctx, id, req.Version)
		if err != nil {
			api.Error(w, http.StatusInternalServerError, "TRUNCATE_FAILED", err.Error())
			return
		}

		api.JSON(w, http.StatusOK, map[string]interface{}{
			"id":                    agg.ID(),
			"version":               agg.Version(),
			"state":                 agg.State(),
			"enabled_transitions":   agg.EnabledTransitions(),
		})
	}
}





// Helper functions

func getIntQueryParam(r *http.Request, name string, defaultVal int) int {
	val := r.URL.Query().Get(name)
	return getInt(val, defaultVal)
}

func getInt(s string, defaultVal int) int {
	if s == "" {
		return defaultVal
	}

	intVal, err := strconv.Atoi(s)
	if err != nil {
		return defaultVal
	}

	return intVal
}


// HandleGetSchema returns the model schema JSON for the schema viewer.
func HandleGetSchema() http.HandlerFunc {
	// Schema JSON is embedded at generation time (base64 encoded)
	schemaBase64 := "ewogICJuYW1lIjogImNvZmZlZXNob3AiLAogICJkZXNjcmlwdGlvbiI6ICJDb2ZmZWUgc2hvcCBpbnZlbnRvcnkgYW5kIG9yZGVyIHByb2Nlc3Npbmcgd2l0aCByZXNvdXJjZSBwcmVkaWN0aW9uIiwKICAicGxhY2VzIjogWwogICAgewogICAgICAiaWQiOiAiY29mZmVlX2JlYW5zIiwKICAgICAgImRlc2NyaXB0aW9uIjogIkNvZmZlZSBiZWFucyBpbnZlbnRvcnkgKGdyYW1zKSIsCiAgICAgICJpbml0aWFsIjogMTAwMCwKICAgICAgImtpbmQiOiAidG9rZW4iLAogICAgICAiY2FwYWNpdHkiOiAyMDAwLAogICAgICAicmVzb3VyY2UiOiB0cnVlCiAgICB9LAogICAgewogICAgICAiaWQiOiAibWlsayIsCiAgICAgICJkZXNjcmlwdGlvbiI6ICJNaWxrIGludmVudG9yeSAobWwpIiwKICAgICAgImluaXRpYWwiOiA1MDAsCiAgICAgICJraW5kIjogInRva2VuIiwKICAgICAgImNhcGFjaXR5IjogMTAwMCwKICAgICAgInJlc291cmNlIjogdHJ1ZQogICAgfSwKICAgIHsKICAgICAgImlkIjogImN1cHMiLAogICAgICAiZGVzY3JpcHRpb24iOiAiQ3VwIGludmVudG9yeSIsCiAgICAgICJpbml0aWFsIjogMjAwLAogICAgICAia2luZCI6ICJ0b2tlbiIsCiAgICAgICJjYXBhY2l0eSI6IDUwMCwKICAgICAgInJlc291cmNlIjogdHJ1ZQogICAgfSwKICAgIHsKICAgICAgImlkIjogIm9yZGVyc19wZW5kaW5nIiwKICAgICAgImRlc2NyaXB0aW9uIjogIk9yZGVycyB3YWl0aW5nIHRvIGJlIG1hZGUiLAogICAgICAiaW5pdGlhbCI6IDAsCiAgICAgICJraW5kIjogInRva2VuIgogICAgfSwKICAgIHsKICAgICAgImlkIjogImVzcHJlc3NvX3JlYWR5IiwKICAgICAgImRlc2NyaXB0aW9uIjogIkVzcHJlc3NvIGRyaW5rcyByZWFkeSIsCiAgICAgICJpbml0aWFsIjogMCwKICAgICAgImtpbmQiOiAidG9rZW4iCiAgICB9LAogICAgewogICAgICAiaWQiOiAibGF0dGVfcmVhZHkiLAogICAgICAiZGVzY3JpcHRpb24iOiAiTGF0dGUgZHJpbmtzIHJlYWR5IiwKICAgICAgImluaXRpYWwiOiAwLAogICAgICAia2luZCI6ICJ0b2tlbiIKICAgIH0sCiAgICB7CiAgICAgICJpZCI6ICJjYXBwdWNjaW5vX3JlYWR5IiwKICAgICAgImRlc2NyaXB0aW9uIjogIkNhcHB1Y2Npbm8gZHJpbmtzIHJlYWR5IiwKICAgICAgImluaXRpYWwiOiAwLAogICAgICAia2luZCI6ICJ0b2tlbiIKICAgIH0sCiAgICB7CiAgICAgICJpZCI6ICJvcmRlcnNfY29tcGxldGUiLAogICAgICAiZGVzY3JpcHRpb24iOiAiQ29tcGxldGVkIGFuZCBzZXJ2ZWQgb3JkZXJzIiwKICAgICAgImluaXRpYWwiOiAwLAogICAgICAia2luZCI6ICJ0b2tlbiIKICAgIH0KICBdLAogICJ0cmFuc2l0aW9ucyI6IFsKICAgIHsKICAgICAgImlkIjogIm9yZGVyX2VzcHJlc3NvIiwKICAgICAgImRlc2NyaXB0aW9uIjogIkN1c3RvbWVyIG9yZGVycyBlc3ByZXNzbyIsCiAgICAgICJodHRwX21ldGhvZCI6ICJQT1NUIiwKICAgICAgImh0dHBfcGF0aCI6ICIvYXBpL29yZGVyX2VzcHJlc3NvIiwKICAgICAgInJhdGUiOiAxMCwKICAgICAgImV2ZW50X3R5cGUiOiAiT3JkZXJFc3ByZXNzb2VkIgogICAgfSwKICAgIHsKICAgICAgImlkIjogIm9yZGVyX2xhdHRlIiwKICAgICAgImRlc2NyaXB0aW9uIjogIkN1c3RvbWVyIG9yZGVycyBsYXR0ZSIsCiAgICAgICJodHRwX21ldGhvZCI6ICJQT1NUIiwKICAgICAgImh0dHBfcGF0aCI6ICIvYXBpL29yZGVyX2xhdHRlIiwKICAgICAgInJhdGUiOiAxNSwKICAgICAgImV2ZW50X3R5cGUiOiAiT3JkZXJMYXR0ZWVkIgogICAgfSwKICAgIHsKICAgICAgImlkIjogIm9yZGVyX2NhcHB1Y2Npbm8iLAogICAgICAiZGVzY3JpcHRpb24iOiAiQ3VzdG9tZXIgb3JkZXJzIGNhcHB1Y2Npbm8iLAogICAgICAiaHR0cF9tZXRob2QiOiAiUE9TVCIsCiAgICAgICJodHRwX3BhdGgiOiAiL2FwaS9vcmRlcl9jYXBwdWNjaW5vIiwKICAgICAgInJhdGUiOiA4LAogICAgICAiZXZlbnRfdHlwZSI6ICJPcmRlckNhcHB1Y2Npbm9lZCIKICAgIH0sCiAgICB7CiAgICAgICJpZCI6ICJtYWtlX2VzcHJlc3NvIiwKICAgICAgImRlc2NyaXB0aW9uIjogIkJhcmlzdGEgbWFrZXMgZXNwcmVzc28iLAogICAgICAiaHR0cF9tZXRob2QiOiAiUE9TVCIsCiAgICAgICJodHRwX3BhdGgiOiAiL2FwaS9tYWtlX2VzcHJlc3NvIiwKICAgICAgInJhdGUiOiAyMCwKICAgICAgImV2ZW50X3R5cGUiOiAiTWFrZUVzcHJlc3NvZWQiCiAgICB9LAogICAgewogICAgICAiaWQiOiAibWFrZV9sYXR0ZSIsCiAgICAgICJkZXNjcmlwdGlvbiI6ICJCYXJpc3RhIG1ha2VzIGxhdHRlIiwKICAgICAgImh0dHBfbWV0aG9kIjogIlBPU1QiLAogICAgICAiaHR0cF9wYXRoIjogIi9hcGkvbWFrZV9sYXR0ZSIsCiAgICAgICJyYXRlIjogMTIsCiAgICAgICJldmVudF90eXBlIjogIk1ha2VMYXR0ZWVkIgogICAgfSwKICAgIHsKICAgICAgImlkIjogIm1ha2VfY2FwcHVjY2lubyIsCiAgICAgICJkZXNjcmlwdGlvbiI6ICJCYXJpc3RhIG1ha2VzIGNhcHB1Y2Npbm8iLAogICAgICAiaHR0cF9tZXRob2QiOiAiUE9TVCIsCiAgICAgICJodHRwX3BhdGgiOiAiL2FwaS9tYWtlX2NhcHB1Y2Npbm8iLAogICAgICAicmF0ZSI6IDEwLAogICAgICAiZXZlbnRfdHlwZSI6ICJNYWtlQ2FwcHVjY2lub2VkIgogICAgfSwKICAgIHsKICAgICAgImlkIjogInNlcnZlX2VzcHJlc3NvIiwKICAgICAgImRlc2NyaXB0aW9uIjogIlNlcnZlIGVzcHJlc3NvIHRvIGN1c3RvbWVyIiwKICAgICAgImh0dHBfbWV0aG9kIjogIlBPU1QiLAogICAgICAiaHR0cF9wYXRoIjogIi9hcGkvc2VydmVfZXNwcmVzc28iLAogICAgICAicmF0ZSI6IDMwLAogICAgICAiZXZlbnRfdHlwZSI6ICJTZXJ2ZUVzcHJlc3NvZWQiCiAgICB9LAogICAgewogICAgICAiaWQiOiAic2VydmVfbGF0dGUiLAogICAgICAiZGVzY3JpcHRpb24iOiAiU2VydmUgbGF0dGUgdG8gY3VzdG9tZXIiLAogICAgICAiaHR0cF9tZXRob2QiOiAiUE9TVCIsCiAgICAgICJodHRwX3BhdGgiOiAiL2FwaS9zZXJ2ZV9sYXR0ZSIsCiAgICAgICJyYXRlIjogMzAsCiAgICAgICJldmVudF90eXBlIjogIlNlcnZlTGF0dGVlZCIKICAgIH0sCiAgICB7CiAgICAgICJpZCI6ICJzZXJ2ZV9jYXBwdWNjaW5vIiwKICAgICAgImRlc2NyaXB0aW9uIjogIlNlcnZlIGNhcHB1Y2Npbm8gdG8gY3VzdG9tZXIiLAogICAgICAiaHR0cF9tZXRob2QiOiAiUE9TVCIsCiAgICAgICJodHRwX3BhdGgiOiAiL2FwaS9zZXJ2ZV9jYXBwdWNjaW5vIiwKICAgICAgInJhdGUiOiAzMCwKICAgICAgImV2ZW50X3R5cGUiOiAiU2VydmVDYXBwdWNjaW5vZWQiCiAgICB9LAogICAgewogICAgICAiaWQiOiAicmVzdG9ja19jb2ZmZWVfYmVhbnMiLAogICAgICAiZGVzY3JpcHRpb24iOiAiUmVzdG9jayBjb2ZmZWUgYmVhbnMgaW52ZW50b3J5IiwKICAgICAgImh0dHBfbWV0aG9kIjogIlBPU1QiLAogICAgICAiaHR0cF9wYXRoIjogIi9hcGkvcmVzdG9ja19jb2ZmZWVfYmVhbnMiLAogICAgICAiZXZlbnRfdHlwZSI6ICJSZXN0b2NrQ29mZmVlQmVhbnNlZCIKICAgIH0sCiAgICB7CiAgICAgICJpZCI6ICJyZXN0b2NrX21pbGsiLAogICAgICAiZGVzY3JpcHRpb24iOiAiUmVzdG9jayBtaWxrIGludmVudG9yeSIsCiAgICAgICJodHRwX21ldGhvZCI6ICJQT1NUIiwKICAgICAgImh0dHBfcGF0aCI6ICIvYXBpL3Jlc3RvY2tfbWlsayIsCiAgICAgICJldmVudF90eXBlIjogIlJlc3RvY2tNaWxrZWQiCiAgICB9LAogICAgewogICAgICAiaWQiOiAicmVzdG9ja19jdXBzIiwKICAgICAgImRlc2NyaXB0aW9uIjogIlJlc3RvY2sgY3VwIGludmVudG9yeSIsCiAgICAgICJodHRwX21ldGhvZCI6ICJQT1NUIiwKICAgICAgImh0dHBfcGF0aCI6ICIvYXBpL3Jlc3RvY2tfY3VwcyIsCiAgICAgICJldmVudF90eXBlIjogIlJlc3RvY2tDdXBzZWQiCiAgICB9CiAgXSwKICAiYXJjcyI6IFsKICAgIHsKICAgICAgImZyb20iOiAib3JkZXJfZXNwcmVzc28iLAogICAgICAidG8iOiAib3JkZXJzX3BlbmRpbmciCiAgICB9LAogICAgewogICAgICAiZnJvbSI6ICJvcmRlcnNfcGVuZGluZyIsCiAgICAgICJ0byI6ICJtYWtlX2VzcHJlc3NvIgogICAgfSwKICAgIHsKICAgICAgImZyb20iOiAiY29mZmVlX2JlYW5zIiwKICAgICAgInRvIjogIm1ha2VfZXNwcmVzc28iLAogICAgICAid2VpZ2h0IjogMjAKICAgIH0sCiAgICB7CiAgICAgICJmcm9tIjogImN1cHMiLAogICAgICAidG8iOiAibWFrZV9lc3ByZXNzbyIKICAgIH0sCiAgICB7CiAgICAgICJmcm9tIjogIm1ha2VfZXNwcmVzc28iLAogICAgICAidG8iOiAiZXNwcmVzc29fcmVhZHkiCiAgICB9LAogICAgewogICAgICAiZnJvbSI6ICJvcmRlcl9sYXR0ZSIsCiAgICAgICJ0byI6ICJvcmRlcnNfcGVuZGluZyIKICAgIH0sCiAgICB7CiAgICAgICJmcm9tIjogIm9yZGVyc19wZW5kaW5nIiwKICAgICAgInRvIjogIm1ha2VfbGF0dGUiCiAgICB9LAogICAgewogICAgICAiZnJvbSI6ICJjb2ZmZWVfYmVhbnMiLAogICAgICAidG8iOiAibWFrZV9sYXR0ZSIsCiAgICAgICJ3ZWlnaHQiOiAxNQogICAgfSwKICAgIHsKICAgICAgImZyb20iOiAibWlsayIsCiAgICAgICJ0byI6ICJtYWtlX2xhdHRlIiwKICAgICAgIndlaWdodCI6IDUwCiAgICB9LAogICAgewogICAgICAiZnJvbSI6ICJjdXBzIiwKICAgICAgInRvIjogIm1ha2VfbGF0dGUiCiAgICB9LAogICAgewogICAgICAiZnJvbSI6ICJtYWtlX2xhdHRlIiwKICAgICAgInRvIjogImxhdHRlX3JlYWR5IgogICAgfSwKICAgIHsKICAgICAgImZyb20iOiAib3JkZXJfY2FwcHVjY2lubyIsCiAgICAgICJ0byI6ICJvcmRlcnNfcGVuZGluZyIKICAgIH0sCiAgICB7CiAgICAgICJmcm9tIjogIm9yZGVyc19wZW5kaW5nIiwKICAgICAgInRvIjogIm1ha2VfY2FwcHVjY2lubyIKICAgIH0sCiAgICB7CiAgICAgICJmcm9tIjogImNvZmZlZV9iZWFucyIsCiAgICAgICJ0byI6ICJtYWtlX2NhcHB1Y2Npbm8iLAogICAgICAid2VpZ2h0IjogMTUKICAgIH0sCiAgICB7CiAgICAgICJmcm9tIjogIm1pbGsiLAogICAgICAidG8iOiAibWFrZV9jYXBwdWNjaW5vIiwKICAgICAgIndlaWdodCI6IDMwCiAgICB9LAogICAgewogICAgICAiZnJvbSI6ICJjdXBzIiwKICAgICAgInRvIjogIm1ha2VfY2FwcHVjY2lubyIKICAgIH0sCiAgICB7CiAgICAgICJmcm9tIjogIm1ha2VfY2FwcHVjY2lubyIsCiAgICAgICJ0byI6ICJjYXBwdWNjaW5vX3JlYWR5IgogICAgfSwKICAgIHsKICAgICAgImZyb20iOiAiZXNwcmVzc29fcmVhZHkiLAogICAgICAidG8iOiAic2VydmVfZXNwcmVzc28iCiAgICB9LAogICAgewogICAgICAiZnJvbSI6ICJzZXJ2ZV9lc3ByZXNzbyIsCiAgICAgICJ0byI6ICJvcmRlcnNfY29tcGxldGUiCiAgICB9LAogICAgewogICAgICAiZnJvbSI6ICJsYXR0ZV9yZWFkeSIsCiAgICAgICJ0byI6ICJzZXJ2ZV9sYXR0ZSIKICAgIH0sCiAgICB7CiAgICAgICJmcm9tIjogInNlcnZlX2xhdHRlIiwKICAgICAgInRvIjogIm9yZGVyc19jb21wbGV0ZSIKICAgIH0sCiAgICB7CiAgICAgICJmcm9tIjogImNhcHB1Y2Npbm9fcmVhZHkiLAogICAgICAidG8iOiAic2VydmVfY2FwcHVjY2lubyIKICAgIH0sCiAgICB7CiAgICAgICJmcm9tIjogInNlcnZlX2NhcHB1Y2Npbm8iLAogICAgICAidG8iOiAib3JkZXJzX2NvbXBsZXRlIgogICAgfSwKICAgIHsKICAgICAgImZyb20iOiAicmVzdG9ja19jb2ZmZWVfYmVhbnMiLAogICAgICAidG8iOiAiY29mZmVlX2JlYW5zIiwKICAgICAgIndlaWdodCI6IDUwMAogICAgfSwKICAgIHsKICAgICAgImZyb20iOiAicmVzdG9ja19taWxrIiwKICAgICAgInRvIjogIm1pbGsiLAogICAgICAid2VpZ2h0IjogNTAwCiAgICB9LAogICAgewogICAgICAiZnJvbSI6ICJyZXN0b2NrX2N1cHMiLAogICAgICAidG8iOiAiY3VwcyIsCiAgICAgICJ3ZWlnaHQiOiAxMDAKICAgIH0KICBdLAogICJkZWJ1ZyI6IHsKICAgICJlbmFibGVkIjogdHJ1ZQogIH0sCiAgInByZWRpY3Rpb24iOiB7CiAgICAiZW5hYmxlZCI6IHRydWUsCiAgICAidGltZUhvdXJzIjogOCwKICAgICJyYXRlU2NhbGUiOiAwLjAwMDEKICB9Cn0="

	return func(w http.ResponseWriter, r *http.Request) {
		schemaJSON, err := base64.StdEncoding.DecodeString(schemaBase64)
		if err != nil {
			api.Error(w, http.StatusInternalServerError, "schema_decode_error", "Failed to decode schema")
			return
		}
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusOK)
		w.Write(schemaJSON)
	}
}

