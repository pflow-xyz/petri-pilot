// Code generated by petri-pilot. DO NOT EDIT.

package coffeeshop

import (
	"github.com/pflow-xyz/go-pflow/petri"
	"github.com/pflow-xyz/go-pflow/solver"
)

// PredictionConfig holds simulation parameters.
var PredictionConfig = struct {
	TimeHours float64
	RateScale float64
}{
	TimeHours: 8.0,
	RateScale: 0.016700,
}

// SimulationResult represents predicted resource levels over time.
type SimulationResult struct {
	TimePoints []float64            `json:"timePoints"`
	Resources  map[string][]float64 `json:"resources"`
	RunoutTime map[string]*float64  `json:"runoutTime,omitempty"`
}

// ResourcePlaceIDs returns the IDs of places marked as resources.
func ResourcePlaceIDs() []string {
	return []string{
		"coffee_beans",
		"milk",
		"cups",
	}
}

// RunSimulation executes ODE prediction from current state.
func RunSimulation(currentTokens map[string]int, hours float64) (*SimulationResult, error) {
	// Build Petri net
	net := buildPredictionPetriNet()

	// Build initial state (map[string]float64)
	initialState := make(map[string]float64)
	for placeID, tokens := range currentTokens {
		initialState[placeID] = float64(tokens)
	}
	// Ensure all places have a value
	for label := range net.Places {
		if _, ok := initialState[label]; !ok {
			initialState[label] = 0
		}
	}

	// Build transition rates
	rates := make(map[string]float64)
	rates["order_espresso"] = 10.00 * PredictionConfig.RateScale
	rates["order_latte"] = 15.00 * PredictionConfig.RateScale
	rates["order_cappuccino"] = 8.00 * PredictionConfig.RateScale
	rates["make_espresso"] = 20.00 * PredictionConfig.RateScale
	rates["make_latte"] = 12.00 * PredictionConfig.RateScale
	rates["make_cappuccino"] = 10.00 * PredictionConfig.RateScale
	rates["serve_espresso"] = 30.00 * PredictionConfig.RateScale
	rates["serve_latte"] = 30.00 * PredictionConfig.RateScale
	rates["serve_cappuccino"] = 30.00 * PredictionConfig.RateScale
	rates["restock_coffee_beans"] = 1.0 * PredictionConfig.RateScale
	rates["restock_milk"] = 1.0 * PredictionConfig.RateScale
	rates["restock_cups"] = 1.0 * PredictionConfig.RateScale

	// Create and solve ODE problem
	tspan := [2]float64{0, hours * 60} // Convert hours to minutes
	prob := solver.NewProblem(net, initialState, tspan, rates)
	solution := solver.Solve(prob, solver.Tsit5(), solver.WorkflowOptions())

	// Extract results
	result := &SimulationResult{
		TimePoints: solution.T,
		Resources:  make(map[string][]float64),
		RunoutTime: make(map[string]*float64),
	}

	// Extract resource place trajectories
	resourcePlaces := ResourcePlaceIDs()
	for _, resourceID := range resourcePlaces {
		trajectory := solution.GetVariable(resourceID)
		if trajectory != nil {
			result.Resources[resourceID] = trajectory

			// Find runout time (when resource <= 0)
			if rt := findRunoutTime(solution.T, trajectory); rt != nil {
				result.RunoutTime[resourceID] = rt
			}
		}
	}

	return result, nil
}

// buildPredictionPetriNet constructs the Petri net from the workflow definition.
func buildPredictionPetriNet() *petri.PetriNet {
	net := petri.NewPetriNet()

	// Add places
	net.AddPlace("coffee_beans", float64(1000), nil, 0, 0, nil)
	net.AddPlace("milk", float64(500), nil, 0, 0, nil)
	net.AddPlace("cups", float64(200), nil, 0, 0, nil)
	net.AddPlace("orders_pending", float64(0), nil, 0, 0, nil)
	net.AddPlace("espresso_ready", float64(0), nil, 0, 0, nil)
	net.AddPlace("latte_ready", float64(0), nil, 0, 0, nil)
	net.AddPlace("cappuccino_ready", float64(0), nil, 0, 0, nil)
	net.AddPlace("orders_complete", float64(0), nil, 0, 0, nil)

	// Add transitions
	net.AddTransition("order_espresso", "default", 0, 0, nil)
	net.AddTransition("order_latte", "default", 0, 0, nil)
	net.AddTransition("order_cappuccino", "default", 0, 0, nil)
	net.AddTransition("make_espresso", "default", 0, 0, nil)
	net.AddTransition("make_latte", "default", 0, 0, nil)
	net.AddTransition("make_cappuccino", "default", 0, 0, nil)
	net.AddTransition("serve_espresso", "default", 0, 0, nil)
	net.AddTransition("serve_latte", "default", 0, 0, nil)
	net.AddTransition("serve_cappuccino", "default", 0, 0, nil)
	net.AddTransition("restock_coffee_beans", "default", 0, 0, nil)
	net.AddTransition("restock_milk", "default", 0, 0, nil)
	net.AddTransition("restock_cups", "default", 0, 0, nil)

	// Add arcs (from model definition)
	net.AddArc("order_espresso", "orders_pending", float64(1), false)
	net.AddArc("orders_pending", "make_espresso", float64(1), false)
	net.AddArc("coffee_beans", "make_espresso", float64(20), false)
	net.AddArc("cups", "make_espresso", float64(1), false)
	net.AddArc("make_espresso", "espresso_ready", float64(1), false)
	net.AddArc("order_latte", "orders_pending", float64(1), false)
	net.AddArc("orders_pending", "make_latte", float64(1), false)
	net.AddArc("coffee_beans", "make_latte", float64(15), false)
	net.AddArc("milk", "make_latte", float64(50), false)
	net.AddArc("cups", "make_latte", float64(1), false)
	net.AddArc("make_latte", "latte_ready", float64(1), false)
	net.AddArc("order_cappuccino", "orders_pending", float64(1), false)
	net.AddArc("orders_pending", "make_cappuccino", float64(1), false)
	net.AddArc("coffee_beans", "make_cappuccino", float64(15), false)
	net.AddArc("milk", "make_cappuccino", float64(30), false)
	net.AddArc("cups", "make_cappuccino", float64(1), false)
	net.AddArc("make_cappuccino", "cappuccino_ready", float64(1), false)
	net.AddArc("espresso_ready", "serve_espresso", float64(1), false)
	net.AddArc("serve_espresso", "orders_complete", float64(1), false)
	net.AddArc("latte_ready", "serve_latte", float64(1), false)
	net.AddArc("serve_latte", "orders_complete", float64(1), false)
	net.AddArc("cappuccino_ready", "serve_cappuccino", float64(1), false)
	net.AddArc("serve_cappuccino", "orders_complete", float64(1), false)
	net.AddArc("restock_coffee_beans", "coffee_beans", float64(500), false)
	net.AddArc("restock_milk", "milk", float64(500), false)
	net.AddArc("restock_cups", "cups", float64(100), false)

	return net
}

// findRunoutTime finds the first time point where the value drops to or below zero.
func findRunoutTime(t, values []float64) *float64 {
	for i, v := range values {
		if v <= 0 {
			runoutTime := t[i]
			return &runoutTime
		}
	}
	return nil
}

// GetCurrentInventory returns the current token counts for resource places.
// This function should be implemented to read from your aggregate state.
func GetCurrentInventory() map[string]int {
	// Default implementation returns initial values
	// Override this to read actual state from your application
	inventory := make(map[string]int)
	inventory["coffee_beans"] = 1000
	inventory["milk"] = 500
	inventory["cups"] = 200
	return inventory
}
