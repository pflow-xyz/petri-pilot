// Code generated by petri-pilot. DO NOT EDIT.

package coffeeshop

// Simplified prediction model - calculates resource depletion based on order rates.

// PredictionConfig holds simulation parameters.
var PredictionConfig = struct {
	TimeHours float64
	RateScale float64
}{
	TimeHours: 8.0,
	RateScale: 1.0, // Not used in simplified model
}

// SimulationResult represents predicted resource levels over time.
type SimulationResult struct {
	TimePoints []float64            `json:"timePoints"`
	Resources  map[string][]float64 `json:"resources"`
	RunoutTime map[string]*float64  `json:"runoutTime,omitempty"`
}

// ResourcePlaceIDs returns the IDs of places marked as resources.
func ResourcePlaceIDs() []string {
	return []string{
		"coffee_beans",
		"milk",
		"cups",
	}
}

// RunSimulation executes prediction from current state with default rates.
func RunSimulation(currentTokens map[string]int, hours float64) (*SimulationResult, error) {
	return RunSimulationWithRates(currentTokens, hours, nil)
}

// RunSimulationWithRates calculates resource depletion based on order rates.
// Uses a simplified model: orders arrive at configured rates, each order type
// consumes specific amounts of resources.
func RunSimulationWithRates(currentTokens map[string]int, hours float64, customRates map[string]float64) (*SimulationResult, error) {
	// Default rates (per hour)
	defaultRates := map[string]float64{
		"order_espresso":   10.00,
		"order_latte":      15.00,
		"order_cappuccino": 8.00,
	}

	// Get effective order rates
	orderRates := make(map[string]float64)
	for order, defaultRate := range defaultRates {
		if customRates != nil {
			if customRate, ok := customRates[order]; ok {
				orderRates[order] = customRate
				continue
			}
		}
		orderRates[order] = defaultRate
	}

	// Resource consumption per order type (from Petri net arcs)
	// espresso: 20g coffee, 0ml milk, 1 cup
	// latte: 15g coffee, 50ml milk, 1 cup
	// cappuccino: 15g coffee, 30ml milk, 1 cup
	consumption := map[string]map[string]float64{
		"order_espresso":   {"coffee_beans": 20, "milk": 0, "cups": 1},
		"order_latte":      {"coffee_beans": 15, "milk": 50, "cups": 1},
		"order_cappuccino": {"coffee_beans": 15, "milk": 30, "cups": 1},
	}

	// Calculate consumption rates per hour for each resource
	coffeePerHour := orderRates["order_espresso"]*consumption["order_espresso"]["coffee_beans"] +
		orderRates["order_latte"]*consumption["order_latte"]["coffee_beans"] +
		orderRates["order_cappuccino"]*consumption["order_cappuccino"]["coffee_beans"]

	milkPerHour := orderRates["order_espresso"]*consumption["order_espresso"]["milk"] +
		orderRates["order_latte"]*consumption["order_latte"]["milk"] +
		orderRates["order_cappuccino"]*consumption["order_cappuccino"]["milk"]

	cupsPerHour := orderRates["order_espresso"]*consumption["order_espresso"]["cups"] +
		orderRates["order_latte"]*consumption["order_latte"]["cups"] +
		orderRates["order_cappuccino"]*consumption["order_cappuccino"]["cups"]

	// Get current inventory
	coffeeBeans := float64(currentTokens["coffee_beans"])
	milk := float64(currentTokens["milk"])
	cups := float64(currentTokens["cups"])

	// Generate time points (every minute for the duration)
	totalMinutes := int(hours * 60)
	timePoints := make([]float64, totalMinutes+1)
	coffeeTrajectory := make([]float64, totalMinutes+1)
	milkTrajectory := make([]float64, totalMinutes+1)
	cupsTrajectory := make([]float64, totalMinutes+1)

	for i := 0; i <= totalMinutes; i++ {
		t := float64(i) // minutes
		timePoints[i] = t

		// Calculate remaining resources at time t
		hoursElapsed := t / 60.0
		coffeeTrajectory[i] = coffeeBeans - coffeePerHour*hoursElapsed
		milkTrajectory[i] = milk - milkPerHour*hoursElapsed
		cupsTrajectory[i] = cups - cupsPerHour*hoursElapsed
	}

	result := &SimulationResult{
		TimePoints: timePoints,
		Resources: map[string][]float64{
			"coffee_beans": coffeeTrajectory,
			"milk":         milkTrajectory,
			"cups":         cupsTrajectory,
		},
		RunoutTime: make(map[string]*float64),
	}

	// Calculate runout times (when resource hits 0)
	if coffeePerHour > 0 {
		rt := (coffeeBeans / coffeePerHour) * 60 // Convert hours to minutes
		if rt <= hours*60 {
			result.RunoutTime["coffee_beans"] = &rt
		}
	}
	if milkPerHour > 0 {
		rt := (milk / milkPerHour) * 60
		if rt <= hours*60 {
			result.RunoutTime["milk"] = &rt
		}
	}
	if cupsPerHour > 0 {
		rt := (cups / cupsPerHour) * 60
		if rt <= hours*60 {
			result.RunoutTime["cups"] = &rt
		}
	}

	return result, nil
}

// GetCurrentInventory returns the current token counts for resource places.
// This function should be implemented to read from your aggregate state.
func GetCurrentInventory() map[string]int {
	// Default implementation returns initial values
	// Override this to read actual state from your application
	inventory := make(map[string]int)
	inventory["coffee_beans"] = 1000
	inventory["milk"] = 500
	inventory["cups"] = 200
	return inventory
}
