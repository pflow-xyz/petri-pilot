// Code generated by petri-pilot. DO NOT EDIT.

package graph

import (
	"context"
	"encoding/json"
	"fmt"

	"github.com/pflow-xyz/go-pflow/eventsource"
)

// Resolver is the root resolver for GraphQL queries and mutations.
type Resolver struct {
	App interface {
		Create(ctx context.Context) (string, error)
		Load(ctx context.Context, id string) (Aggregate, error)
		GetState(ctx context.Context, id string) (Aggregate, error)
		Execute(ctx context.Context, id, transition string, data map[string]any) (Aggregate, error)
		HealthCheck(ctx context.Context) error
		GetStore() eventsource.Store
	}
}

// Aggregate interface for type safety
type Aggregate interface {
	ID() string
	Version() int
	State() any
	Places() map[string]int
	EnabledTransitions() []string
}

// NewResolver creates a new GraphQL resolver.
func NewResolver(app interface {
	Create(ctx context.Context) (string, error)
	Load(ctx context.Context, id string) (Aggregate, error)
	GetState(ctx context.Context, id string) (Aggregate, error)
	Execute(ctx context.Context, id, transition string, data map[string]any) (Aggregate, error)
	HealthCheck(ctx context.Context) error
	GetStore() eventsource.Store
}) *Resolver {
	return &Resolver{App: app}
}

// Query resolvers

// Coffeeshop returns the aggregate state by ID.
func (r *Resolver) Coffeeshop(ctx context.Context, id string) (*AggregateState, error) {
	agg, err := r.App.GetState(ctx, id)
	if err != nil {
		return nil, err
	}
	return aggregateToState(agg), nil
}

// CoffeeshopList returns a paginated list of aggregates.
func (r *Resolver) CoffeeshopList(ctx context.Context, place *string, page *int, perPage *int) (*AggregateList, error) {
	// Default pagination
	p := 1
	pp := 50
	if page != nil {
		p = *page
	}
	if perPage != nil {
		pp = *perPage
	}

	placeFilter := ""
	if place != nil {
		placeFilter = *place
	}
	// Admin features not enabled - return empty list
	_ = placeFilter
	return &AggregateList{
		Items:   []*AggregateState{},
		Total:   0,
		Page:    p,
		PerPage: pp,
	}, nil
}


// Events returns the event history for an aggregate.
func (r *Resolver) Events(ctx context.Context, aggregateID string, from *int) ([]*Event, error) {
	store := r.App.GetStore()
	fromVersion := 0
	if from != nil {
		fromVersion = *from
	}

	events, err := store.Read(ctx, aggregateID, fromVersion)
	if err != nil {
		return nil, err
	}

	result := make([]*Event, len(events))
	for i, evt := range events {
		data, _ := json.Marshal(evt.Data)
		result[i] = &Event{
			ID:        fmt.Sprintf("%s-%d", evt.StreamID, evt.Version),
			StreamID:  evt.StreamID,
			Type:      evt.Type,
			Version:   evt.Version,
			Timestamp: evt.Timestamp,
			Data:      string(data),
		}
	}

	return result, nil
}

// StateAtVersion returns the aggregate state at a specific version.
func (r *Resolver) StateAtVersion(ctx context.Context, aggregateID string, version int) (*AggregateState, error) {
	// This is a simplified implementation - would need aggregate rebuild logic
	agg, err := r.App.GetState(ctx, aggregateID)
	if err != nil {
		return nil, err
	}

	// TODO: Implement proper version replay
	state := aggregateToState(agg)
	state.Version = version
	return state, nil
}


// Mutation resolvers

// CreateCoffeeshop creates a new aggregate instance.
func (r *Resolver) CreateCoffeeshop(ctx context.Context) (*AggregateState, error) {
	id, err := r.App.Create(ctx)
	if err != nil {
		return nil, err
	}

	agg, err := r.App.Load(ctx, id)
	if err != nil {
		return nil, err
	}

	return aggregateToState(agg), nil
}


// OrderEspresso executes the order_espresso transition.
func (r *Resolver) OrderEspresso(ctx context.Context, input OrderEspressoInput) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "order_espresso", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// OrderLatte executes the order_latte transition.
func (r *Resolver) OrderLatte(ctx context.Context, input OrderLatteInput) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "order_latte", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// OrderCappuccino executes the order_cappuccino transition.
func (r *Resolver) OrderCappuccino(ctx context.Context, input OrderCappuccinoInput) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "order_cappuccino", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// MakeEspresso executes the make_espresso transition.
func (r *Resolver) MakeEspresso(ctx context.Context, input MakeEspressoInput) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "make_espresso", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// MakeLatte executes the make_latte transition.
func (r *Resolver) MakeLatte(ctx context.Context, input MakeLatteInput) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "make_latte", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// MakeCappuccino executes the make_cappuccino transition.
func (r *Resolver) MakeCappuccino(ctx context.Context, input MakeCappuccinoInput) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "make_cappuccino", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// ServeEspresso executes the serve_espresso transition.
func (r *Resolver) ServeEspresso(ctx context.Context, input ServeEspressoInput) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "serve_espresso", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// ServeLatte executes the serve_latte transition.
func (r *Resolver) ServeLatte(ctx context.Context, input ServeLatteInput) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "serve_latte", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// ServeCappuccino executes the serve_cappuccino transition.
func (r *Resolver) ServeCappuccino(ctx context.Context, input ServeCappuccinoInput) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "serve_cappuccino", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// RestockCoffeeBeans executes the restock_coffee_beans transition.
func (r *Resolver) RestockCoffeeBeans(ctx context.Context, input RestockCoffeeBeansInput) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "restock_coffee_beans", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// RestockMilk executes the restock_milk transition.
func (r *Resolver) RestockMilk(ctx context.Context, input RestockMilkInput) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "restock_milk", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}


// RestockCups executes the restock_cups transition.
func (r *Resolver) RestockCups(ctx context.Context, input RestockCupsInput) (*TransitionResult, error) {
	data := make(map[string]any)

	agg, err := r.App.Execute(ctx, input.AggregateID, "restock_cups", data)
	if err != nil {
		errMsg := err.Error()
		return &TransitionResult{
			Success: false,
			Error:   &errMsg,
		}, nil
	}

	places := agg.Places()
	enabled := agg.EnabledTransitions()
	id := agg.ID()
	version := agg.Version()

	return &TransitionResult{
		Success:            true,
		AggregateID:        &id,
		Version:            &version,
		State:              placesToModel(places),
		EnabledTransitions: enabled,
	}, nil
}



// Helper functions

func aggregateToState(agg Aggregate) *AggregateState {
	places := agg.Places()
	return &AggregateState{
		ID:                 agg.ID(),
		Version:            agg.Version(),
		State:              stateToModel(agg.State()),
		Places:             placesToModel(places),
		EnabledTransitions: agg.EnabledTransitions(),
	}
}

func stateToModel(state any) *State {
	s := &State{}
	if m, ok := state.(map[string]any); ok {
		if v, ok := m["coffee_beans"].(int); ok {
			s.CoffeeBeans = v
		}
		if v, ok := m["milk"].(int); ok {
			s.Milk = v
		}
		if v, ok := m["cups"].(int); ok {
			s.Cups = v
		}
		if v, ok := m["orders_pending"].(int); ok {
			s.OrdersPending = v
		}
		if v, ok := m["espresso_ready"].(int); ok {
			s.EspressoReady = v
		}
		if v, ok := m["latte_ready"].(int); ok {
			s.LatteReady = v
		}
		if v, ok := m["cappuccino_ready"].(int); ok {
			s.CappuccinoReady = v
		}
		if v, ok := m["orders_complete"].(int); ok {
			s.OrdersComplete = v
		}
	}
	return s
}

func placesToModel(places map[string]int) *Places {
	p := &Places{}
	if v, ok := places["coffee_beans"]; ok {
		p.CoffeeBeans = v
	}
	if v, ok := places["milk"]; ok {
		p.Milk = v
	}
	if v, ok := places["cups"]; ok {
		p.Cups = v
	}
	if v, ok := places["orders_pending"]; ok {
		p.OrdersPending = v
	}
	if v, ok := places["espresso_ready"]; ok {
		p.EspressoReady = v
	}
	if v, ok := places["latte_ready"]; ok {
		p.LatteReady = v
	}
	if v, ok := places["cappuccino_ready"]; ok {
		p.CappuccinoReady = v
	}
	if v, ok := places["orders_complete"]; ok {
		p.OrdersComplete = v
	}
	return p
}

// GraphQL model types

type AggregateState struct {
	ID                 string
	Version            int
	State              *State
	Places             *Places
	EnabledTransitions []string
}

type State struct {
	CoffeeBeans int
	Milk int
	Cups int
	OrdersPending int
	EspressoReady int
	LatteReady int
	CappuccinoReady int
	OrdersComplete int
}

type Places struct {
	CoffeeBeans int
	Milk int
	Cups int
	OrdersPending int
	EspressoReady int
	LatteReady int
	CappuccinoReady int
	OrdersComplete int
}

type TransitionResult struct {
	Success            bool
	AggregateID        *string
	Version            *int
	State              *Places
	EnabledTransitions []string
	Error              *string
}

type AggregateList struct {
	Items   []*AggregateState
	Total   int
	Page    int
	PerPage int
}


type Event struct {
	ID        string
	StreamID  string
	Type      string
	Version   int
	Timestamp any
	Data      string
}


// Input types

type OrderEspressoInput struct {
	AggregateID string
}


type OrderLatteInput struct {
	AggregateID string
}


type OrderCappuccinoInput struct {
	AggregateID string
}


type MakeEspressoInput struct {
	AggregateID string
}


type MakeLatteInput struct {
	AggregateID string
}


type MakeCappuccinoInput struct {
	AggregateID string
}


type ServeEspressoInput struct {
	AggregateID string
}


type ServeLatteInput struct {
	AggregateID string
}


type ServeCappuccinoInput struct {
	AggregateID string
}


type RestockCoffeeBeansInput struct {
	AggregateID string
}


type RestockMilkInput struct {
	AggregateID string
}


type RestockCupsInput struct {
	AggregateID string
}

