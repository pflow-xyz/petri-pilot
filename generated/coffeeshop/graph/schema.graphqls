# Code generated by petri-pilot. DO NOT EDIT.
# GraphQL schema for coffeeshop

scalar Time

type Query {
  # Get aggregate state by ID
  coffeeshop(id: ID!): AggregateState

  # List aggregates with optional filtering
  coffeeshopList(place: String, page: Int, perPage: Int): AggregateList!

  # Event history for an aggregate
  events(aggregateId: ID!, from: Int): [Event!]!

  # Get state at specific version
  stateAtVersion(aggregateId: ID!, version: Int!): AggregateState
}

type Mutation {
  # Create a new coffeeshop instance
  createCoffeeshop: AggregateState!

  # Customer orders espresso
  orderEspresso(input: OrderEspressoInput!): TransitionResult!

  # Customer orders latte
  orderLatte(input: OrderLatteInput!): TransitionResult!

  # Customer orders cappuccino
  orderCappuccino(input: OrderCappuccinoInput!): TransitionResult!

  # Barista makes espresso
  makeEspresso(input: MakeEspressoInput!): TransitionResult!

  # Barista makes latte
  makeLatte(input: MakeLatteInput!): TransitionResult!

  # Barista makes cappuccino
  makeCappuccino(input: MakeCappuccinoInput!): TransitionResult!

  # Serve espresso to customer
  serveEspresso(input: ServeEspressoInput!): TransitionResult!

  # Serve latte to customer
  serveLatte(input: ServeLatteInput!): TransitionResult!

  # Serve cappuccino to customer
  serveCappuccino(input: ServeCappuccinoInput!): TransitionResult!

  # Restock coffee beans inventory
  restockCoffeeBeans(input: RestockCoffeeBeansInput!): TransitionResult!

  # Restock milk inventory
  restockMilk(input: RestockMilkInput!): TransitionResult!

  # Restock cup inventory
  restockCups(input: RestockCupsInput!): TransitionResult!
}

# Aggregate state representation
type AggregateState {
  id: ID!
  version: Int!
  state: State!
  places: Places!
  enabledTransitions: [String!]!
}

# Workflow state with all places
type State {
  coffeeBeans: Int!
  milk: Int!
  cups: Int!
  ordersPending: Int!
  espressoReady: Int!
  latteReady: Int!
  cappuccinoReady: Int!
  ordersComplete: Int!
}

# Token counts for each place
type Places {
  coffeeBeans: Int!
  milk: Int!
  cups: Int!
  ordersPending: Int!
  espressoReady: Int!
  latteReady: Int!
  cappuccinoReady: Int!
  ordersComplete: Int!
}

# Result of a transition execution
type TransitionResult {
  success: Boolean!
  aggregateId: ID
  version: Int
  state: Places
  enabledTransitions: [String!]
  error: String
}

# Paginated list of aggregates
type AggregateList {
  items: [AggregateState!]!
  total: Int!
  page: Int!
  perPage: Int!
}


# Event record
type Event {
  id: ID!
  streamId: String!
  type: String!
  version: Int!
  timestamp: Time!
  data: String!
}


# Input types for mutations

input OrderEspressoInput {
  aggregateId: ID!
}


input OrderLatteInput {
  aggregateId: ID!
}


input OrderCappuccinoInput {
  aggregateId: ID!
}


input MakeEspressoInput {
  aggregateId: ID!
}


input MakeLatteInput {
  aggregateId: ID!
}


input MakeCappuccinoInput {
  aggregateId: ID!
}


input ServeEspressoInput {
  aggregateId: ID!
}


input ServeLatteInput {
  aggregateId: ID!
}


input ServeCappuccinoInput {
  aggregateId: ID!
}


input RestockCoffeeBeansInput {
  aggregateId: ID!
}


input RestockMilkInput {
  aggregateId: ID!
}


input RestockCupsInput {
  aggregateId: ID!
}

