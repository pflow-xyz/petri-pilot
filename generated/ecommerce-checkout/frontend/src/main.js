// Generated by petri-pilot. DO NOT EDIT.

// API client
const API_BASE = ''  // Uses Vite proxy in development

// Auth state
let currentUser = null
let authToken = null

// Load auth from localStorage
function loadAuth() {
  const stored = localStorage.getItem('auth')
  if (stored) {
    try {
      const auth = JSON.parse(stored)
      if (auth.expires_at && new Date(auth.expires_at) > new Date()) {
        authToken = auth.token
        currentUser = auth.user
        return true
      }
      localStorage.removeItem('auth')
    } catch (e) {
      localStorage.removeItem('auth')
    }
  }
  return false
}

// Save auth to localStorage
function saveAuth(data) {
  localStorage.setItem('auth', JSON.stringify(data))
  authToken = data.token
  currentUser = data.user
}

// Clear auth
function clearAuth() {
  localStorage.removeItem('auth')
  authToken = null
  currentUser = null
}

// API helpers
function getHeaders() {
  const headers = { 'Content-Type': 'application/json' }
  if (authToken) {
    headers['Authorization'] = `Bearer ${authToken}`
  }
  return headers
}

async function handleResponse(response) {
  if (response.status === 401) {
    clearAuth()
    renderAuth()
    throw new Error('Session expired. Please log in again.')
  }
  if (!response.ok) {
    const error = await response.json().catch(() => ({}))
    throw new Error(error.message || response.statusText)
  }
  return response.json()
}

const api = {
  // Auth endpoints
  async getMe() {
    const response = await fetch(`${API_BASE}/auth/me`, {
      headers: getHeaders(),
    })
    return handleResponse(response)
  },

  async logout() {
    await fetch(`${API_BASE}/auth/logout`, {
      method: 'POST',
      headers: getHeaders(),
    })
    clearAuth()
  },

  // Workflow endpoints
  async create() {
    const response = await fetch(`${API_BASE}/api/ecommerce-checkout`, {
      method: 'POST',
      headers: getHeaders(),
    })
    return handleResponse(response)
  },

  async getState(id) {
    const response = await fetch(`${API_BASE}/api/ecommerce-checkout/${id}`, {
      headers: getHeaders(),
    })
    return handleResponse(response)
  },

  async executeTransition(transitionId, aggregateId) {
    const response = await fetch(`${API_BASE}/api/ecommerce-checkout/transitions/${transitionId}`, {
      method: 'POST',
      headers: getHeaders(),
      body: JSON.stringify({ aggregate_id: aggregateId }),
    })
    return handleResponse(response)
  },
}

// UI state
let currentState = null
let aggregateId = null

// DOM elements
const errorEl = document.getElementById('error')
const authSection = document.getElementById('auth-section')
const loginBtn = document.getElementById('login-btn')
const logoutBtn = document.getElementById('logout-btn')
const userInfo = document.getElementById('user-info')
const aggregateInput = document.getElementById('aggregate-id')
const loadBtn = document.getElementById('load-btn')
const createBtn = document.getElementById('create-btn')
const stateSection = document.getElementById('state-section')
const actionsSection = document.getElementById('actions-section')
const displayId = document.getElementById('display-id')
const displayVersion = document.getElementById('display-version')
const placesGrid = document.getElementById('places-grid')
const enabledList = document.getElementById('enabled-list')
const transitionsGrid = document.getElementById('transitions-grid')

// Transitions metadata
const transitions = [
  { id: 'start_checkout', name: 'Start Checkout', description: 'Begin checkout process' },
  { id: 'enter_payment', name: 'Enter Payment', description: 'Enter payment details' },
  { id: 'process_payment', name: 'Process Payment', description: 'Process the payment' },
  { id: 'payment_success', name: 'Payment Success', description: 'Payment processed successfully' },
  { id: 'payment_fail_1', name: 'Payment Fail 1', description: 'First payment attempt failed' },
  { id: 'retry_payment_1', name: 'Retry Payment 1', description: 'Retry payment (attempt 2)' },
  { id: 'payment_fail_2', name: 'Payment Fail 2', description: 'Second payment attempt failed' },
  { id: 'retry_payment_2', name: 'Retry Payment 2', description: 'Retry payment (attempt 3)' },
  { id: 'payment_fail_3', name: 'Payment Fail 3', description: 'Third payment attempt failed' },
  { id: 'cancel_order', name: 'Cancel Order', description: 'Cancel order after max retries' },
  { id: 'fulfill', name: 'Fulfill', description: 'Fulfill the order' },
]

// Show/hide error
function showError(message) {
  errorEl.textContent = message
  errorEl.style.display = 'block'
}

function hideError() {
  errorEl.style.display = 'none'
}

// Render auth state
function renderAuth() {
  if (currentUser) {
    loginBtn.style.display = 'none'
    logoutBtn.style.display = 'inline-block'
    userInfo.textContent = currentUser.login || currentUser.name || 'User'
    userInfo.style.display = 'inline'
  } else {
    loginBtn.style.display = 'inline-block'
    logoutBtn.style.display = 'none'
    userInfo.style.display = 'none'
  }
}

// Render current state
function renderState() {
  if (!currentState) {
    stateSection.style.display = 'none'
    actionsSection.style.display = 'none'
    return
  }

  stateSection.style.display = 'block'
  actionsSection.style.display = 'block'

  displayId.textContent = aggregateId
  displayVersion.textContent = currentState.version || 0

  // Render places
  placesGrid.innerHTML = ''
  const places = currentState.places || currentState.marking || {}
  for (const [placeId, tokens] of Object.entries(places)) {
    const placeEl = document.createElement('div')
    placeEl.className = `place ${tokens > 0 ? 'active' : 'inactive'}`
    placeEl.innerHTML = `
      <span class="token-count">${tokens}</span>
      <span>${placeId}</span>
    `
    placesGrid.appendChild(placeEl)
  }

  // Render enabled transitions
  enabledList.innerHTML = ''
  const enabled = currentState.enabled || []
  for (const transitionId of enabled) {
    const tag = document.createElement('span')
    tag.className = 'enabled-tag'
    tag.textContent = transitionId
    enabledList.appendChild(tag)
  }
  if (enabled.length === 0) {
    enabledList.innerHTML = '<span style="color: #666;">No transitions enabled</span>'
  }

  // Render transition cards
  transitionsGrid.innerHTML = ''
  for (const t of transitions) {
    const isEnabled = enabled.includes(t.id)
    const card = document.createElement('div')
    card.className = `transition-card ${isEnabled ? '' : 'disabled'}`
    card.innerHTML = `
      <div class="transition-title">${t.name}</div>
      ${t.description ? `<div class="transition-desc">${t.description}</div>` : ''}
      <button ${isEnabled ? '' : 'disabled'} data-transition="${t.id}">
        Execute
      </button>
    `
    transitionsGrid.appendChild(card)
  }
}

// Load state
async function loadState() {
  hideError()
  const id = aggregateInput.value.trim()
  if (!id) {
    showError('Please enter an aggregate ID')
    return
  }

  try {
    aggregateId = id
    currentState = await api.getState(id)
    renderState()
  } catch (err) {
    showError(`Failed to load: ${err.message}`)
    currentState = null
    renderState()
  }
}

// Create new instance
async function createNew() {
  hideError()
  try {
    const result = await api.create()
    aggregateId = result.aggregate_id || result.id
    aggregateInput.value = aggregateId
    currentState = result.state || result
    renderState()
  } catch (err) {
    showError(`Failed to create: ${err.message}`)
  }
}

// Execute transition
async function executeTransition(transitionId) {
  hideError()
  if (!aggregateId) {
    showError('No aggregate loaded')
    return
  }

  try {
    const result = await api.executeTransition(transitionId, aggregateId)
    currentState = result.state || result
    renderState()
  } catch (err) {
    showError(`Failed to execute ${transitionId}: ${err.message}`)
  }
}

// Login with GitHub
function login() {
  window.location.href = `${API_BASE}/auth/login`
}

// Logout
async function logout() {
  try {
    await api.logout()
  } catch (err) {
    console.error('Logout error:', err)
  }
  clearAuth()
  renderAuth()
}

// Handle OAuth callback
async function handleCallback() {
  const params = new URLSearchParams(window.location.search)
  const token = params.get('token')
  const expiresAt = params.get('expires_at')

  if (token) {
    // Token returned directly in URL (simplified flow)
    authToken = token
    try {
      const user = await api.getMe()
      saveAuth({ token, expires_at: expiresAt, user })
      window.history.replaceState({}, '', window.location.pathname)
      renderAuth()
    } catch (err) {
      clearAuth()
      showError('Failed to complete login')
    }
  }
}

// Real-time updates
let eventSource = null

function subscribeToUpdates() {
  if (!aggregateId) return
  unsubscribeFromUpdates()

  // Use Server-Sent Events for real-time updates
  eventSource = new EventSource(`${API_BASE}/events?id=${encodeURIComponent(aggregateId)}`)

  eventSource.addEventListener('connected', (e) => {
    console.log('Connected to real-time updates')
  })

  eventSource.addEventListener('state', (e) => {
    try {
      const change = JSON.parse(e.data)
      // Update state from real-time event
      currentState = {
        version: change.version,
        places: change.state,
        marking: change.state,
        enabled: change.enabled,
      }
      renderState()
    } catch (err) {
      console.error('Failed to parse state update:', err)
    }
  })

  eventSource.onerror = (e) => {
    console.error('SSE connection error:', e)
    // Reconnect after a delay
    setTimeout(() => {
      if (aggregateId) subscribeToUpdates()
    }, 3000)
  }
}

function unsubscribeFromUpdates() {
  if (eventSource) {
    eventSource.close()
    eventSource = null
  }
}

// Event handlers
loginBtn.addEventListener('click', login)
logoutBtn.addEventListener('click', logout)
loadBtn.addEventListener('click', async () => {
  await loadState()
  subscribeToUpdates()
})
createBtn.addEventListener('click', async () => {
  await createNew()
  subscribeToUpdates()
})

aggregateInput.addEventListener('keypress', async (e) => {
  if (e.key === 'Enter') {
    await loadState()
    subscribeToUpdates()
  }
})

transitionsGrid.addEventListener('click', (e) => {
  const btn = e.target.closest('button[data-transition]')
  if (btn && !btn.disabled) {
    executeTransition(btn.dataset.transition)
  }
})

// Cleanup on page unload
window.addEventListener('beforeunload', unsubscribeFromUpdates)

// Initialize
loadAuth()
handleCallback()
renderAuth()
renderState()
