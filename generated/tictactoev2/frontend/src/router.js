// Generated by petri-pilot. DO NOT EDIT.

/**
 * Router configuration for tic-tac-toe application
 * Provides client-side routing with dynamic route matching
 */

// API base path for when service is mounted at a prefix
const API_BASE = window.API_BASE || ''

// Helper to strip API_BASE from a path for route matching
function stripBase(path) {
  if (API_BASE && path.startsWith(API_BASE)) {
    return path.slice(API_BASE.length) || '/'
  }
  return path
}

// Route definitions - order matters! More specific routes first
export const routes = [
  // Root redirects to list
  {
    path: '/',
    component: 'List',
    title: 'tic-tac-toe',
  },
  // Entity routes
  {
    path: '/tic-tac-toe',
    component: 'List',
    title: 'tic-tac-toe',
  },
  {
    path: '/tic-tac-toe/new',
    component: 'Form',
    title: 'New tic-tac-toe',
  },
  {
    path: '/tic-tac-toe/:id',
    component: 'Detail',
    title: 'tic-tac-toe Detail',
  },
  // Schema viewer
  {
    path: '/schema',
    component: 'Schema',
    title: 'Schema Viewer',
  },
  // Admin routes
  {
    path: '/admin',
    component: 'AdminDashboard',
    title: 'Admin Dashboard',
  },
  {
    path: '/admin/instances',
    component: 'AdminInstances',
    title: 'Instances',
  },
  {
    path: '/admin/instances/:id',
    component: 'AdminInstance',
    title: 'Instance Detail',
  },
]

// Current route state
let currentRoute = null
let currentParams = {}

// Route matcher - tries routes in order, returns first match
function matchRoute(path) {
  // Normalize path
  path = path || '/'
  if (path !== '/' && path.endsWith('/')) {
    path = path.slice(0, -1)
  }

  for (const route of routes) {
    const params = {}
    // Escape special regex chars except our param pattern
    let pattern = route.path.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
    // Replace :param with capture group
    pattern = pattern.replace(/:[^/]+/g, '([^/]+)')
    const regex = new RegExp(`^${pattern}$`)
    const match = path.match(regex)

    if (match) {
      // Extract params from dynamic segments
      const paramNames = (route.path.match(/:[^/]+/g) || []).map(p => p.slice(1))
      paramNames.forEach((name, i) => {
        params[name] = decodeURIComponent(match[i + 1])
      })

      return { route, params }
    }
  }
  return null
}

// Navigate to a path
export function navigate(path, state = {}) {
  // Handle relative paths
  if (!path.startsWith('/')) {
    path = '/' + path
  }

  // Strip API_BASE if present for route matching
  const routePath = stripBase(path)
  const match = matchRoute(routePath)

  if (!match) {
    // Fallback to list page for unknown routes
    console.warn(`No route found for path: ${path}, falling back to list`)
    const fallbackPath = '/tic-tac-toe'
    const fallback = matchRoute(fallbackPath)
    if (fallback) {
      currentRoute = fallback.route
      currentParams = fallback.params
      window.history.pushState(state, '', `${API_BASE}${fallbackPath}`)
      renderCurrentRoute()
    }
    return
  }

  // Check role requirements
  if (match.route.roles && match.route.roles.length > 0) {
    const user = getCurrentUser()
    if (!user || !hasAnyRole(user, match.route.roles)) {
      console.warn('Access denied:', path)
      navigate(`${API_BASE}/tic-tac-toe`)
      return
    }
  }

  currentRoute = match.route
  currentParams = match.params

  // Update browser history - use full path with API_BASE
  const historyPath = path.startsWith(API_BASE) ? path : `${API_BASE}${routePath}`
  window.history.pushState(state, '', historyPath)

  // Trigger render
  renderCurrentRoute()
}

// Handle browser back/forward
window.addEventListener('popstate', () => {
  const path = stripBase(window.location.pathname)
  const match = matchRoute(path)
  if (match) {
    currentRoute = match.route
    currentParams = match.params
    renderCurrentRoute()
  } else {
    // Fallback to list
    navigate(`${API_BASE}/tic-tac-toe`)
  }
})

// Get current user from auth
function getCurrentUser() {
  const auth = localStorage.getItem('auth')
  if (auth) {
    try {
      return JSON.parse(auth).user
    } catch (e) {
      return null
    }
  }
  return null
}

// Check if user has any of the required roles
function hasAnyRole(user, roles) {
  if (!user || !user.roles) {
    return false
  }
  return roles.some(role => user.roles.includes(role))
}

// Render the current route
function renderCurrentRoute() {
  // Dispatch custom event for page changes
  window.dispatchEvent(new CustomEvent('route-change', {
    detail: {
      route: currentRoute,
      params: currentParams
    }
  }))
}

// Get current route params
export function getRouteParams() {
  return currentParams
}

// Get current route
export function getCurrentRoute() {
  return currentRoute
}

// Initialize router
export function initRouter() {
  const path = stripBase(window.location.pathname)
  const match = matchRoute(path)

  if (match) {
    currentRoute = match.route
    currentParams = match.params
  } else {
    // Default to list page
    currentRoute = routes.find(r => r.path === '/tic-tac-toe') || routes[0]
    currentParams = {}
  }
}
