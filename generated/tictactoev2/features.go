// Code generated by petri-pilot. DO NOT EDIT.

package tictactoev2

import (
	"database/sql"
	"net/http"
	"time"

	"github.com/pflow-xyz/petri-pilot/pkg/runtime/api"
)
















// ============================================================================
// SOFT DELETE
// ============================================================================

// SoftDeleteStore manages soft deletion.
type SoftDeleteStore struct {
	db            *sql.DB
	retentionDays int
}

// NewSoftDeleteStore creates a new SoftDeleteStore.
func NewSoftDeleteStore(db *sql.DB, retentionDays int) *SoftDeleteStore {
	return &SoftDeleteStore{db: db, retentionDays: retentionDays}
}

// InitSchema creates the soft_deletes table.
func (sds *SoftDeleteStore) InitSchema() error {
	_, err := sds.db.Exec(`
		CREATE TABLE IF NOT EXISTS soft_deletes (
			aggregate_id TEXT PRIMARY KEY,
			deleted_by TEXT,
			deleted_at TEXT NOT NULL,
			expires_at TEXT
		);
	`)
	return err
}

// SoftDelete marks an aggregate as deleted.
func (sds *SoftDeleteStore) SoftDelete(aggregateID, deletedBy string) error {
	now := time.Now().UTC()
	var expiresAt *time.Time
	if sds.retentionDays > 0 {
		exp := now.AddDate(0, 0, sds.retentionDays)
		expiresAt = &exp
	}

	var expiresAtStr interface{}
	if expiresAt != nil {
		expiresAtStr = expiresAt.Format(time.RFC3339)
	}

	_, err := sds.db.Exec(`
		INSERT OR REPLACE INTO soft_deletes (aggregate_id, deleted_by, deleted_at, expires_at)
		VALUES (?, ?, ?, ?)
	`, aggregateID, deletedBy, now.Format(time.RFC3339), expiresAtStr)
	return err
}

// Restore restores a soft-deleted aggregate.
func (sds *SoftDeleteStore) Restore(aggregateID string) error {
	_, err := sds.db.Exec(`DELETE FROM soft_deletes WHERE aggregate_id = ?`, aggregateID)
	return err
}

// IsDeleted checks if an aggregate is soft-deleted.
func (sds *SoftDeleteStore) IsDeleted(aggregateID string) bool {
	var count int
	sds.db.QueryRow(`SELECT COUNT(*) FROM soft_deletes WHERE aggregate_id = ?`, aggregateID).Scan(&count)
	return count > 0
}

// HandleSoftDelete handles soft delete requests.
func (sds *SoftDeleteStore) HandleSoftDelete(w http.ResponseWriter, r *http.Request) {
	aggregateID := r.PathValue("id")
	userID := getSoftDeleteUserID(r)

	if err := sds.SoftDelete(aggregateID, userID); err != nil {
		api.Error(w, http.StatusInternalServerError, "DELETE_FAILED", err.Error())
		return
	}

	api.JSON(w, http.StatusOK, map[string]interface{}{"success": true, "deleted": true})
}

// HandleRestore handles restore requests.
func (sds *SoftDeleteStore) HandleRestore(w http.ResponseWriter, r *http.Request) {
	aggregateID := r.PathValue("id")

	if err := sds.Restore(aggregateID); err != nil {
		api.Error(w, http.StatusInternalServerError, "RESTORE_FAILED", err.Error())
		return
	}

	api.JSON(w, http.StatusOK, map[string]interface{}{"success": true, "restored": true})
}

func getSoftDeleteUserID(r *http.Request) string {
	return "anonymous"
}

















